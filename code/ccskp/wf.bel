%%% WF: well-foundedness

% Test: accessibility of natural numbers (keys)

% Less or equal
LF leq: keys → keys → type =
  | l_eq: leq M M
  | l_ls: less M N → leq M N
;

% Auxiliary lemma: if M < s(N), then M <= N
rec less_impl_leq: [⊢ less M (s N)] → [⊢ leq M N] =
/ total l (less_impl_leq _ _ l) /
fn l ⇒ case l of
  | [⊢ lzero N] ⇒ (case dec_eq_keys [] [⊢ z] [⊢ N] of
       | [⊢ c_eq] ⇒ [⊢ l_eq]
       | [⊢ c_neq (nless L)] ⇒ [⊢ l_ls L]
       | [⊢ c_neq (ngreat L)] ⇒ impossible [⊢ L])
  | [⊢ lsucc L]:[⊢ less (s M) (s N)] ⇒ (case [⊢ N] of
       | [⊢ z] ⇒ impossible [⊢ L]
       | [⊢ s N'] ⇒ (case less_impl_leq [⊢ L] of
            | [⊢ l_eq] ⇒ [⊢ l_eq]
            | [⊢ l_ls L'] ⇒ [⊢ l_ls (lsucc L')]))
;

% Accessibility of natural numbers
inductive acc_nat: [⊢ keys] → ctype =
  | acc_intro_nat: {N:[⊢ keys]} ({M:[⊢ keys]} [⊢ less M N] → acc_nat [⊢ M]) → acc_nat [⊢ N]
;

% Well-foundedness of natural numbers: all numbers are accessible
rec wf_nat: {N:[⊢ keys]} acc_nat [⊢ N] =
/ total n (wf_nat n) /
mlam N ⇒ case [⊢ N] of
  | [⊢ z] ⇒ acc_intro_nat [⊢ z] (mlam M ⇒ fn l ⇒ impossible l)
  | [⊢ s N'] ⇒ acc_intro_nat [⊢ s N'] (mlam M ⇒ fn l ⇒
    (case less_impl_leq l of
       | [⊢ l_eq] ⇒ wf_nat [⊢ N']
       | [⊢ l_ls L'] ⇒ let acc_intro_nat [⊢ N'] a = wf_nat [⊢ N'] in a [⊢ M] [⊢ L']))
;


% Accessibility of CCSKP processes
inductive acc: (g:ctx) [g ⊢ proc] → ctype =
  | acc_intro: {g:ctx} {X':[g ⊢ proc]}
    ({X:[g ⊢ proc]} {T:[g ⊢ pr_lab]} [g ⊢ fstep X T X'] → acc [g ⊢ X]) → acc [g ⊢ X']
;

% If X is accessible, then A[K].X is accessible
rec wf_kpref: (g:ctx) {A:[g ⊢ labels]} {K:[⊢ keys]} acc [g ⊢ X] → acc [g ⊢ kpref A K[] X] =
/ total x (wf_kpref _ _ _ x _) /
mlam A,K ⇒ fn a ⇒ let acc_intro [g] [g ⊢ X] h = a in
acc_intro [g] [g ⊢ kpref A K[] X] (mlam Y,T ⇒ fn f ⇒ (case f of 
       | [g ⊢ fc (fc_pref _)] ⇒ acc_intro [g] [_ ⊢ pref A X] (mlam _,_ ⇒ fn f' ⇒
         (case f' of
            | [g ⊢ fc F'] ⇒ impossible [g ⊢ F']
            | [g ⊢ fo F'] ⇒ impossible [g ⊢ F']))
       | [g ⊢ fc (fc_kpref F _ _)] ⇒ wf_kpref [_ ⊢ _] [_ ⊢ _] (h [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F])
       | [g ⊢ fo (fo_kpref F (\_._) _)] ⇒ wf_kpref [_ ⊢ _] [_ ⊢ _] (h [_ ⊢ _] [_ ⊢ _] [_ ⊢ fo F])))
;

% Well-foundedness of processes: all processes are accessible
rec wf_proc: (g:ctx) {X:[g ⊢ proc]} acc [g ⊢ X] =
/ total x (wf_proc _ x) /
mlam X ⇒ case [_ ⊢ X] of
  | [g ⊢ null] ⇒ acc_intro [g] [_ ⊢ null] (mlam _,_ ⇒ fn f ⇒ (case f of 
       | [g ⊢ fc F] ⇒ impossible [g ⊢ F]
       | [g ⊢ fo F] ⇒ impossible [g ⊢ F]))
  | [g ⊢ pref A X1] ⇒ acc_intro [g] [_ ⊢ pref A X1] (mlam _,_ ⇒ fn f ⇒ (case f of 
       | [g ⊢ fc F] ⇒ impossible [g ⊢ F]
       | [g ⊢ fo F] ⇒ impossible [g ⊢ F]))
  | [g ⊢ kpref A K[] X1] ⇒ wf_kpref [_ ⊢ _] [_ ⊢ _] (wf_proc [g ⊢ X1])
  | [g ⊢ sum X1 X2] ⇒ ?
  | [g ⊢ par X1 X2] ⇒ ?
  | [g ⊢ nu \a.X1] ⇒ ?
;



% Infinite ascending sequence of natural numbers:
% A sequence x0 < x1 < ... < xn < xn+1 < ... is given by
% a function F: keys → keys, denoting an enumeration of natural numbers,
% with the property that F(n) < F(n+1) for all n in keys.
% seq_nat_up x0 holds iff there is an infinite ascending sequence starting from x0
inductive seq_nat_up: [⊢ keys] → ctype =
  | snu_intro: {F:[⊢ keys → keys]}
    ({N:[⊢ keys]} [⊢ less (F N) (F (s N))]) → seq_nat_up [⊢ F z]
;

% Auxiliary lemma: each natural number is less than its successor
rec aux: {N:[⊢ keys]} [⊢ less N (s N)] =
/ total n (aux n) /
mlam N ⇒ case [⊢ N] of
  | [⊢ z] ⇒ [⊢ lzero _]
  | [⊢ s N'] ⇒ let [⊢ L] = aux [⊢ N'] in [⊢ lsucc L]
;

% Example of infinite ascending sequence: 0 < 1 < 2 < ...
% Encoded by using F = id on keys, which satisfies F (n) = n < n+1 = F(n+1)
let D1:seq_nat_up [⊢ z] = snu_intro [⊢ \x.x] (mlam N ⇒ aux [⊢ N]);

% Example of infinite ascending sequence: 1 < 2 < 3 < ...
% Encoded by using F = \x.(s x) on keys, which satisfies F (n) = s n < s (n+1) = F(n+1)
let D2:seq_nat_up [⊢ s z] = snu_intro [⊢ \x.(s x)] (mlam N ⇒ aux [⊢ s N]);

% Infinite descending sequence of natural numbers:
% A sequence ... < xn+1 < xn < ... < x1 < x0 is given by
% a function F: keys → keys, denoting an enumeration of natural numbers,
% with the property that F(n+1) < F(n) for all n in keys.
% seq_nat_dn x0 holds iff there is an infinite descending sequence starting from x0
inductive seq_nat_dn: [⊢ keys] → ctype =
  | snd_intro: {F:[⊢ keys → keys]}
    ({N:[⊢ keys]} [⊢ less (F (s N)) (F N)]) → seq_nat_dn [⊢ F z]
;

% If n is accessible and there is an infinite descending sequence starting from n,
% then we have a contradiction
rec acc_impl_no_seq_nat: acc_nat [⊢ N] → seq_nat_dn [⊢ N] → [⊢ false] =
/ total a (acc_impl_no_seq_nat _ a _) /
fn a,sq ⇒ let snd_intro [⊢ \x.F] h2 = sq in
let acc_intro_nat [⊢ _] h1 = a in 
acc_impl_no_seq_nat (h1 [⊢ F[s z]] (h2 [⊢ z])) (snd_intro [⊢ \x. F[s x]] (mlam N ⇒ h2 [⊢ s N]))
;

% There is no infinite descending sequence of natural numbers.
% Proved using the fact that each natural number is accessible, and
% there is no infinite descending sequence starting from an accessible number
rec no_seq_nat_up: {N:[⊢ keys]} seq_nat_dn [⊢ N] → [⊢ false] =
/ total (no_seq_nat_up) /
mlam N ⇒ fn sq ⇒ let a = wf_nat [⊢ N] in 
acc_impl_no_seq_nat a sq
;