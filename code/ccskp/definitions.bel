%%% Semantics of CCSKP %%%

module ccskp = struct

% Recall that, unlike in the paper, restriction of names in processes is considered as
% a binding operator and processes are identified up to alpha-renaming of bound names.
% However, the LTS rules for restrictions (res, \bar{res} in Fig.4) are not closed
% under alpha-equivalence. In fact, the name "a" bound by the restrictions may occur
% free in the used proof label theta.
% Our solution consists in considering such occurrence of "a" in theta as bound, and
% identifying proof labels up to alpha-renaming of bound names.
% Thus, the encoding distinguishes between proof labels where occurrences of names are
% free ("closed proof labels") and proof labels where we abstract over the particular
% choice of a bound name ("open proof labels"). We adopt HOAS to represent the bound
% name of an open proof label as the argument of a function from names to pr_lab_cl.

% Closed proof keyed labels 
LF pr_lab_cl: type =
  | pr_base: labels â†’ keys â†’ pr_lab_cl
  | pr_suml: pr_lab_cl â†’ pr_lab_cl
  | pr_sumr: pr_lab_cl â†’ pr_lab_cl
  | pr_parl: pr_lab_cl â†’ pr_lab_cl
  | pr_parr: pr_lab_cl â†’ pr_lab_cl
  | pr_sync: pr_lab_cl â†’ pr_lab_cl â†’ pr_lab_cl
;

% Open proof keyed labels
LF pr_lab_op: type =
  | open: (names â†’ pr_lab_cl) â†’ pr_lab_op
;

% Proof keyed labels as the union of closed and open proof labels
LF pr_lab: type =
  | p_cl: pr_lab_cl â†’ pr_lab
  | p_op: pr_lab_op â†’ pr_lab 
;

% Label of a closed proof label
LF lab: pr_lab_cl â†’ labels â†’ type =
  | lab_base: lab (pr_base A K) A
  | lab_suml: lab T A â†’ lab (pr_suml T) A
  | lab_sumr: lab T A â†’ lab (pr_sumr T) A
  | lab_parl: lab T A â†’ lab (pr_parl T) A
  | lab_parr: lab T A â†’ lab (pr_parr T) A
  | lab_sync: lab (pr_sync T1 T2) tau
;

% Key of a closed proof label
LF key: pr_lab_cl â†’ keys â†’ type =
  | key_base: key (pr_base A K) K
  | key_suml: key T K â†’ key (pr_suml T) K
  | key_sumr: key T K â†’ key (pr_sumr T) K
  | key_parl: key T K â†’ key (pr_parl T) K
  | key_parr: key T K â†’ key (pr_parr T) K
  | key_sync: key T1 K â†’ key (pr_sync T1 T2) K
;

% Occurrence of names in closed proof labels
LF occurs: names â†’ pr_lab_cl â†’ type =
  | occ_basel: occurs A (pr_base (inp A) K)
  | occ_baser: occurs A (pr_base (out A) K)
  | occ_suml: occurs A T â†’ occurs A (pr_suml T)
  | occ_sumr: occurs A T â†’ occurs A (pr_sumr T)
  | occ_parl: occurs A T â†’ occurs A (pr_parl T)
  | occ_parr: occurs A T â†’ occurs A (pr_parr T)
  | occ_sync: occurs A T1 â†’ occurs A (pr_sync T1 T2)
;

% The chosen encoding of proof labels is operationally simpler, but pays the price
% of being over-expressive. To rule out ill-formed proof labels such as
% âŸ¨|_L ğ‘[ğ‘˜], |_R ğ‘[ğ‘˜]âŸ© and âŸ¨|_L ğ‘[ğ‘˜], |_R ğ‘[ğ‘™]âŸ©, we introduce predicates
% expressing the validity of (closed/open) proof labels.

% Valid closed proof labels
LF valid_cl: pr_lab_cl â†’ type =
  | v_base: valid_cl (pr_base A K)
  | v_suml: valid_cl T â†’ valid_cl (pr_suml T)
  | v_sumr: valid_cl T â†’ valid_cl (pr_sumr T)
  | v_parl: valid_cl T â†’ valid_cl (pr_parl T)
  | v_parr: valid_cl T â†’ valid_cl (pr_parr T)
  | v_synl: valid_cl T1 â†’ valid_cl T2 â†’ lab T1 (inp A) â†’ key T1 K
          â†’ lab T2 (out A) â†’ key T2 K â†’ valid_cl (pr_sync T1 T2)
  | v_synr: valid_cl T1 â†’ valid_cl T2 â†’ lab T1 (out A) â†’ key T1 K
          â†’ lab T2 (inp A) â†’ key T2 K â†’ valid_cl (pr_sync T1 T2)
;

% Valid open proof labels
LF valid_op: pr_lab_op â†’ type =
  | vo_base: ({a:names} occurs a (T a)) â†’ ({a:names} lab (T a) A)
           â†’ ({a:names} valid_cl (T a)) â†’ valid_op (open T)
;

% Valid proof labels
LF valid: pr_lab â†’ type =
  | v_cl: valid_cl T â†’ valid (p_cl T)
  | v_op: valid_op T â†’ valid (p_op T)
;


% The forward LTS rules for CCSKP are given by the type family fstep, which
% is in practice the union of two type families fstep_cl and fstep_op.
% The former denotes transitions labelled by closed proof labels, while the
% latter denotes transitions labelled by open proof labels.

% Closed forward transitions
LF fstep_cl: proc â†’ pr_lab_cl â†’ proc â†’ type =
  | fc_pref: std X â†’ fstep_cl (pref A X) (pr_base A K) (kpref A K X)
  | fc_kpref: fstep_cl X T X' â†’ key T M â†’ neq K M
            â†’ fstep_cl (kpref A K X) T (kpref A K X')
  | fc_suml: fstep_cl X T X' â†’ std Y â†’ fstep_cl (sum X Y) (pr_suml T) (sum X' Y)
  | fc_sumr: fstep_cl Y T Y' â†’ std X â†’ fstep_cl (sum X Y) (pr_sumr T) (sum X Y')
  | fc_parl: fstep_cl X T X' â†’ key T K â†’ notin K Y
           â†’ fstep_cl (par X Y) (pr_parl T) (par X' Y)
  | fc_parr: fstep_cl Y T Y' â†’ key T K â†’ notin K X
           â†’ fstep_cl (par X Y) (pr_parr T) (par X Y')
  | fc_synl: fstep_cl X T1 X' â†’ lab T1 (inp L) â†’ key T1 K
           â†’ fstep_cl Y T2 Y' â†’ lab T2 (out L) â†’ key T2 K
           â†’ fstep_cl (par X Y) (pr_sync T1 T2) (par X' Y')
  | fc_synr: fstep_cl X T1 X' â†’ lab T1 (out L) â†’ key T1 K
           â†’ fstep_cl Y T2 Y' â†’ lab T2 (inp L) â†’ key T2 K
           â†’ fstep_cl (par X Y) (pr_sync T1 T2) (par X' Y')
  | fc_nu: ({a:names} fstep_cl (X a) T (X' a)) â†’ fstep_cl (nu X) T (nu X')
;

% Open forward transitions
LF fstep_op: proc â†’ pr_lab_op â†’ proc â†’ type =
  | fo_nu_cl: ({a:names} occurs a (T a)) â†’ ({a:names} lab (T a) A)
            â†’ ({a:names} fstep_cl (X a) (T a) (X' a))
            â†’ fstep_op (nu X) (open T) (nu X')
  | fo_kpref: fstep_op X (open T) X' â†’ ({a:names} key (T a) M) â†’ neq K M
            â†’ fstep_op (kpref A K X) (open T) (kpref A K X')
  | fo_suml: fstep_op X (open \a.(T a)) X' â†’ std Y
           â†’ fstep_op (sum X Y) (open \a.(pr_suml (T a))) (sum X' Y)
  | fo_sumr: fstep_op Y (open \a.(T a)) Y' â†’ std X
           â†’ fstep_op (sum X Y) (open \a.(pr_sumr (T a))) (sum X Y')
  | fo_parl: fstep_op X (open \a.(T a)) X' â†’ ({a:names} key (T a) K) â†’ notin K Y
           â†’ fstep_op (par X Y) (open \a.(pr_parl (T a))) (par X' Y)
  | fo_parr: fstep_op Y (open \a.(T a)) Y' â†’ ({a:names} key (T a) K) â†’ notin K X
           â†’ fstep_op (par X Y) (open \a.(pr_parr (T a))) (par X Y')
  | fo_nu_op: ({a:names} fstep_op (X a) T (X' a))
            â†’ fstep_op (nu X) T (nu X')
;

% Forward transitions
LF fstep: proc â†’ pr_lab â†’ proc â†’ type =
  | fc: fstep_cl X T X' â†’ fstep X (p_cl T) X'
  | fo: fstep_op X T X' â†’ fstep X (p_op T) X'
;

% Closed backward transitions
LF bstep_cl: proc â†’ pr_lab_cl â†’ proc â†’ type =
  | bc_pref: std X â†’ bstep_cl (kpref A K X) (pr_base A K) (pref A X)
  | bc_kpref: bstep_cl X' T X â†’ key T M â†’ neq K M
            â†’ bstep_cl (kpref A K X') T (kpref A K X)
  | bc_suml: bstep_cl X' T X â†’ std Y â†’ bstep_cl (sum X' Y) (pr_suml T) (sum X Y)
  | bc_sumr: bstep_cl Y' T Y â†’ std X â†’ bstep_cl (sum X Y') (pr_sumr T) (sum X Y)
  | bc_parl: bstep_cl X' T X â†’ key T K â†’ notin K Y
           â†’ bstep_cl (par X' Y) (pr_parl T) (par X Y)
  | bc_parr: bstep_cl Y' T Y â†’ key T K â†’ notin K X
           â†’ bstep_cl (par X Y') (pr_parr T) (par X Y)
  | bc_synl: bstep_cl X' T1 X â†’ lab T1 (inp L) â†’ key T1 K
           â†’ bstep_cl Y' T2 Y â†’ lab T2 (out L) â†’ key T2 K
           â†’ bstep_cl (par X' Y') (pr_sync T1 T2) (par X Y)
  | bc_synr: bstep_cl X' T1 X â†’ lab T1 (out L) â†’ key T1 K
           â†’ bstep_cl Y' T2 Y â†’ lab T2 (inp L) â†’ key T2 K
           â†’ bstep_cl (par X' Y') (pr_sync T1 T2) (par X Y)
  | bc_nu: ({a:names} bstep_cl (X' a) T (X a)) â†’ bstep_cl (nu X') T (nu X)
;

% Open backward transitions
LF bstep_op: proc â†’ pr_lab_op â†’ proc â†’ type =
  | bo_nu_cl: ({a:names} occurs a (T a))
            â†’ ({a:names} lab (T a) A)
            â†’ ({a:names} bstep_cl (X' a) (T a) (X a))
            â†’ bstep_op (nu X') (open T) (nu X)
  | bo_kpref: bstep_op X' (open T) X â†’ ({a:names} key (T a) M) â†’ neq K M
            â†’ bstep_op (kpref A K X') (open T) (kpref A K X)
  | bo_suml: bstep_op X' (open \a.(T a)) X â†’ std Y
           â†’ bstep_op (sum X' Y) (open \a.(pr_suml (T a))) (sum X Y)
  | bo_sumr: bstep_op Y' (open \a.(T a)) Y â†’ std X
           â†’ bstep_op (sum X Y') (open \a.(pr_sumr (T a))) (sum X Y)
  | bo_parl: bstep_op X' (open \a.(T a)) X â†’ ({a:names} key (T a) K) â†’ notin K Y
           â†’ bstep_op (par X' Y) (open \a.(pr_parl (T a))) (par X Y)
  | bo_parr: bstep_op Y' (open \a.(T a)) Y â†’ ({a:names} key (T a) K) â†’ notin K X
           â†’ bstep_op (par X Y') (open \a.(pr_parr (T a))) (par X Y)
  | bo_nu_op: ({a:names} bstep_op (X' a) T (X a))
            â†’ bstep_op (nu X') T (nu X)
;

% Backward transitions
LF bstep: proc â†’ pr_lab â†’ proc â†’ type =
  | bc: bstep_cl X T X' â†’ bstep X (p_cl T) X'
  | bo: bstep_op X T X' â†’ bstep X (p_op T) X'
;

% Closed combined transitions
LF step_cl: proc â†’ pr_lab_cl â†’ proc â†’ type =
  | fwc: fstep_cl X T X' â†’ step_cl X T X'
  | bwc: bstep_cl X' T X â†’ step_cl X' T X
;

% Open combined transitions
LF step_op: proc â†’ pr_lab_op â†’ proc â†’ type =
  | fwo: fstep_op X T X' â†’ step_op X T X'
  | bwo: bstep_op X' T X â†’ step_op X' T X
;

% Combined transitions
LF step: proc â†’ pr_lab â†’ proc â†’ type =
  | sc: step_cl X T X' â†’ step X (p_cl T) X'
  | so: step_op X T X' â†’ step X (p_op T) X'
;

% Paths
LF step*: proc â†’ proc â†’ type =
  | id_s*: step* X X
  | st_s*: step X T Y â†’ step* X Y
  | tr_s*: step* X Y â†’ step* Y Z â†’ step* X Z
;

% Reachable processes
LF reachable: proc â†’ type =
  | rch: std X â†’ step* X Y â†’ reachable Y
;

% Connected transitions
LF conn_tr: step X T1 X' â†’ step Y T2 Y' â†’ type =
  | ct: {S1:step X T1 X'}{S2: step Y T2 Y'} step* X Y' â†’ conn_tr S1 S2
;

%%% Connectivity, dependence and independence of proof labels %%%

% Connectivity, dependence and independence of closed proof labels are defined
% according to the rules in Fig. 7 and 8.

% Connectivity of closed proof labels
LF conn_cl: pr_lab_cl â†’ pr_lab_cl â†’ type =
  | c_a1: conn_cl (pr_base A K) T
  | c_a2: conn_cl T (pr_base A K)
  | c_c1l: conn_cl T1 T2 â†’ conn_cl (pr_suml T1) (pr_suml T2)
  | c_c1r: conn_cl T1 T2 â†’ conn_cl (pr_sumr T1) (pr_sumr T2)
  | c_c2l: conn_cl (pr_suml T1) (pr_sumr T2)
  | c_c2r: conn_cl (pr_sumr T1) (pr_suml T2)
  | c_p1l: conn_cl T1 T2 â†’ conn_cl (pr_parl T1) (pr_parl T2)
  | c_p1r: conn_cl T1 T2 â†’ conn_cl (pr_parr T1) (pr_parr T2)
  | c_p2l: conn_cl (pr_parl T1) (pr_parr T2)
  | c_p2r: conn_cl (pr_parr T1) (pr_parl T2)
  | c_s1l: conn_cl T TL â†’ conn_cl (pr_parl T) (pr_sync TL TR)
  | c_s1r: conn_cl T TR â†’ conn_cl (pr_parr T) (pr_sync TL TR)
  | c_s2l: conn_cl TL T â†’ conn_cl (pr_sync TL TR) (pr_parl T)
  | c_s2r: conn_cl TR T â†’ conn_cl (pr_sync TL TR) (pr_parr T)
  | c_s3: conn_cl T1 T1' â†’ conn_cl T2 T2' â†’ conn_cl (pr_sync T1 T2) (pr_sync T1' T2');

% Dependence of closed proof labels
LF dep_cl: pr_lab_cl â†’ pr_lab_cl â†’ type =
  | d_a1: dep_cl (pr_base A K) T
  | d_a2: dep_cl T (pr_base A K)
  | d_c1l: dep_cl T1 T2 â†’ dep_cl (pr_suml T1) (pr_suml T2)
  | d_c1r: dep_cl T1 T2 â†’ dep_cl (pr_sumr T1) (pr_sumr T2)
  | d_c2l: dep_cl (pr_suml T1) (pr_sumr T2)
  | d_c2r: dep_cl (pr_sumr T1) (pr_suml T2)
  | d_p1l: dep_cl T1 T2 â†’ dep_cl (pr_parl T1) (pr_parl T2)
  | d_p1r: dep_cl T1 T2 â†’ dep_cl (pr_parr T1) (pr_parr T2)
  | d_p2l: key T1 K â†’ key T2 K â†’ dep_cl (pr_parl T1) (pr_parr T2)
  | d_p2r: key T1 K â†’ key T2 K â†’ dep_cl (pr_parr T1) (pr_parl T2)
  | d_s1l: dep_cl T TL â†’ dep_cl (pr_parl T) (pr_sync TL TR)
  | d_s1r: dep_cl T TR â†’ dep_cl (pr_parr T) (pr_sync TL TR)
  | d_s2l: dep_cl TL T â†’ dep_cl (pr_sync TL TR) (pr_parl T)
  | d_s2r: dep_cl TR T â†’ dep_cl (pr_sync TL TR) (pr_parr T)
  | d_s3l: dep_cl T1 T1' â†’ conn_cl T2 T2' â†’ dep_cl (pr_sync T1 T2) (pr_sync T1' T2')
  | d_s3r: conn_cl T1 T1' â†’ dep_cl T2 T2' â†’ dep_cl (pr_sync T1 T2) (pr_sync T1' T2')
;

% Independence of closed proof labels
LF indep_cl: pr_lab_cl â†’ pr_lab_cl â†’ type =
  | i_c1l: indep_cl T1 T2 â†’ indep_cl (pr_suml T1) (pr_suml T2)
  | i_c1r: indep_cl T1 T2 â†’ indep_cl (pr_sumr T1) (pr_sumr T2)
  | i_p1l: indep_cl T1 T2 â†’ indep_cl (pr_parl T1) (pr_parl T2)
  | i_p1r: indep_cl T1 T2 â†’ indep_cl (pr_parr T1) (pr_parr T2)
  | i_p2l: key T1 K â†’ key T2 M â†’ neq K M â†’ indep_cl (pr_parl T1) (pr_parr T2)
  | i_p2r: key T1 K â†’ key T2 M â†’ neq K M â†’ indep_cl (pr_parr T1) (pr_parl T2)
  | i_s1l: indep_cl T TL â†’ indep_cl (pr_parl T) (pr_sync TL TR)
  | i_s1r: indep_cl T TR â†’ indep_cl (pr_parr T) (pr_sync TL TR)
  | i_s2l: indep_cl TL T â†’ indep_cl (pr_sync TL TR) (pr_parl T)
  | i_s2r: indep_cl TR T â†’ indep_cl (pr_sync TL TR) (pr_parr T)
  | i_s3: indep_cl T1 T1' â†’ indep_cl T2 T2' â†’ indep_cl (pr_sync T1 T2) (pr_sync T1' T2')
;

% We extend the connectivity relation to open proof labels by universally quantifying
% over names and applying such name to the open proof label. This corresponds to
% the choice of an arbitrary name for the proof label.

% Connectivity of proof labels
LF conn: pr_lab â†’ pr_lab â†’ type =
  | c_cc: conn_cl T1 T2 â†’ conn (p_cl T1) (p_cl T2)
  | c_oc: ({a:names} conn_cl (T1 a) T2) â†’ conn (p_op (open T1)) (p_cl T2)
  | c_co: ({a:names} conn_cl T1 (T2 a)) â†’ conn (p_cl T1) (p_op (open T2))
  | c_oo: ({a:names} conn_cl (T1 a) (T2 a)) â†’ conn (p_op (open T1)) (p_op (open T2))
;

end;