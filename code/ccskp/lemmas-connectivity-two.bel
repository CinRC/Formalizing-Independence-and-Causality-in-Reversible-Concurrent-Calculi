%%% Auxiliary lemmas for Theorem 2.1(ii)

% Type families encoding realisation of a closed/open/generalized proof keyed label.
% With respect to the informal definition of realisation in the paper (Def. 2.4), these type
% families are slightly stronger, so that a stronger result can be later proved and applied.

% A closed proof label T is realised if there is a closed forward transition
% whose source is a standard process and whose proof label is T.
LF realised_cl: pr_lab_cl → type =
  | crl: std X → fstep_cl X T X' → realised_cl T
;
% An open proof label T is realised if there is an open forward transition
% whose source is a standard process and whose proof label is T.
LF realised_op: pr_lab_op → type =
  | orl: std X → fstep_op X T X' → realised_op T
;
% A generalized proof label T is realised if there is a forward transition
% whose source is a standard process and whose proof label is T.
LF realised: pr_lab → type =
  | rl: std X → fstep X T X' → realised T
;

% Lemma 2.5: every valid_cl proof label is realised

% Lemma 2.5 for closed proof labels
rec cl_pr_lab_is_realised: (g:ctx) [g ⊢ valid_cl T] → [g ⊢ realised_cl T] =
/ total v (cl_pr_lab_is_realised _ _ v) /
fn v ⇒ case v of
  | [g ⊢ v_base] ⇒ [g ⊢ crl (std_pref std_null) (fc_pref std_null)]
  | [g ⊢ v_suml V] ⇒ let [g ⊢ crl D F] = cl_pr_lab_is_realised [g ⊢ V] in [g ⊢ crl (std_sum D std_null) (fc_suml F std_null)]
  | [g ⊢ v_sumr V] ⇒ let [g ⊢ crl D F] = cl_pr_lab_is_realised [g ⊢ V] in [g ⊢ crl (std_sum std_null D) (fc_sumr F std_null)]
  | [g ⊢ v_parl V] ⇒ let [g ⊢ crl D F]:[g ⊢ realised_cl T] = cl_pr_lab_is_realised [g ⊢ V] in
    let [g ⊢ ex_k H] = existence_of_key [g ⊢ T] in
    [g ⊢ crl (std_par D std_null) (fc_parl F H not_null)]
  | [g ⊢ v_parr V] ⇒ let [g ⊢ crl D F]:[g ⊢ realised_cl T] = cl_pr_lab_is_realised [g ⊢ V] in
    let [g ⊢ ex_k H] = existence_of_key [g ⊢ T] in
    [g ⊢ crl (std_par std_null D) (fc_parr F H not_null)]
  | [g ⊢ v_synl V1 V2 L1 H1 L2 H2] ⇒ let [g ⊢ crl D1 F1] = cl_pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ crl D2 F2] = cl_pr_lab_is_realised [g ⊢ V2] in
    [g ⊢ crl (std_par D1 D2) (fc_synl F1 L1 H1 F2 L2 H2)]
  | [g ⊢ v_synr V1 V2 L1 H1 L2 H2] ⇒ let [g ⊢ crl D1 F1] = cl_pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ crl D2 F2] = cl_pr_lab_is_realised [g ⊢ V2] in
    [g ⊢ crl (std_par D1 D2) (fc_synr F1 L1 H1 F2 L2 H2)]
;
% Lemma 2.5 for open proof labels
rec op_pr_lab_is_realised: (g:ctx) [g ⊢ valid_op T] → [g ⊢ realised_op T] =
/ total v (op_pr_lab_is_realised _ _ v) /
fn v ⇒ case v of
  | [g ⊢ ov_base (\a.O) (\a.L) (\a.V)] ⇒ let [g,a:names ⊢ crl D F] = cl_pr_lab_is_realised [g,a:names ⊢ V] in
    [g ⊢ orl (std_nu \a.D) (fo_nu_closed (\a.O) (\a.L) (\a.F))]
;
% Lemma 2.5 for generalized proof labels
rec pr_lab_cl_is_realised: (g:ctx) [g ⊢ valid T] → [g ⊢ realised T] =
/ total v (pr_lab_cl_is_realised _ _ v) /
fn v ⇒ case v of
  | [g ⊢ gpv V] ⇒ let [g ⊢ crl D F] = cl_pr_lab_is_realised [g ⊢ V] in [g ⊢ rl D (fc F)]
  | [g ⊢ gov V] ⇒ let [g ⊢ orl D F] = op_pr_lab_is_realised [g ⊢ V] in [g ⊢ rl D (fo F)]
;


% The following lemmas build new paths starting from given paths.

% Given a path between X and X', there is a path between X+0 and X'+0
rec step*_sumleft_null: (g:ctx) [g ⊢ step* X X'] → [g ⊢ step* (sum X null) (sum X' null)] =
/ total s (step*_sumleft_null _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ [g ⊢ st_s* (sc (fwc (fc_suml F std_null)))]
       | [g ⊢ so (fwo F)]:[g ⊢ step _ (go (open \_._)) _] ⇒ [g ⊢ st_s* (so (fwo (fo_suml F std_null)))]
       | [g ⊢ sc (bwc B)] ⇒ [g ⊢ st_s* (sc (bwc (bc_suml B std_null)))]
       | [g ⊢ so (bwo B)]:[g ⊢ step _ (go (open \_._)) _]  ⇒ [g ⊢ st_s* (so (bwo (bo_suml B std_null)))])
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ S1*'] = step*_sumleft_null [g ⊢ S1*] in
    let [g ⊢ S2*'] = step*_sumleft_null [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
;

% Given a path between X and X', there is a path between 0+X and 0+X'
rec step*_sumright_null: (g:ctx) [g ⊢ step* X X'] → [g ⊢ step* (sum null X) (sum null X')] =
/ total s (step*_sumright_null _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ [g ⊢ st_s* (sc (fwc (fc_sumr F std_null)))]
       | [g ⊢ so (fwo F)]:[g ⊢ step _ (go (open \_._)) _] ⇒ [g ⊢ st_s* (so (fwo (fo_sumr F std_null)))]
       | [g ⊢ sc (bwc B)] ⇒ [g ⊢ st_s* (sc (bwc (bc_sumr B std_null)))]
       | [g ⊢ so (bwo B)]:[g ⊢ step _ (go (open \_._)) _]  ⇒ [g ⊢ st_s* (so (bwo (bo_sumr B std_null)))])
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ S1*'] = step*_sumright_null [g ⊢ S1*] in
    let [g ⊢ S2*'] = step*_sumright_null [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
;

% Given a path between X and X' and a standard process Y, there is a path between X|Y and X'|Y
rec step*_parleft_std: (g:ctx) [g ⊢ step* X X'] → [g ⊢ std Y] → [g ⊢ step* (par X Y) (par X' Y)] =
/ total s (step*_parleft_std _ _ _ _ s _) /
fn s,d ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)]:[g ⊢ step _ (gp T) _] ⇒ let [g ⊢ D] = d in
         let [g ⊢ ex_kn _ H N] = no_key_of_prlab_in_std [g ⊢ T] [g ⊢ D] in [g ⊢ st_s* (sc (fwc (fc_parl F H N)))]
       | [g ⊢ so (fwo F)]:[g ⊢ step _ (go (open \a.T)) _] ⇒ let [g ⊢ D] = d in
         let [g,a:names ⊢ ex_k H] = existence_of_key [g,a:names ⊢ T] in
         let [g,a:names ⊢ H]:[g,a:names ⊢ key _ K[]] = [g,a:names ⊢ H] in
         let [g ⊢ N] = no_key_in_std [⊢ K] [g ⊢ D] in [g ⊢ st_s* (so (fwo (fo_parl F (\a.H) N)))]
       | [g ⊢ sc (bwc B)]:[g ⊢ step _ (gp T) _] ⇒ let [g ⊢ D] = d in
         let [g ⊢ ex_kn _ H N] = no_key_of_prlab_in_std [g ⊢ T] [g ⊢ D] in [g ⊢ st_s* (sc (bwc (bc_parl B H N)))]
       | [g ⊢ so (bwo B)]:[g ⊢ step _ (go (open \a.T)) _] ⇒ let [g ⊢ D] = d in
         let [g,a:names ⊢ ex_k H] = existence_of_key [g,a:names ⊢ T] in
         let [g,a:names ⊢ H]:[g,a:names ⊢ key _ K[]] = [g,a:names ⊢ H] in
         let [g ⊢ N] = no_key_in_std [⊢ K] [g ⊢ D] in [g ⊢ st_s* (so (bwo (bo_parl B (\a.H) N)))])
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ S1*'] = step*_parleft_std [g ⊢ S1*] d in
    let [g ⊢ S2*'] = step*_parleft_std [g ⊢ S2*] d in [g ⊢ tr_s* S1*' S2*']
;

% Given a transition between X and X' and a standard process Y, there is a transition between Y|X and Y|X'
rec step*_parright_std: (g:ctx) [g ⊢ step* X X'] → [g ⊢ std Y] → [g ⊢ step* (par Y X) (par Y X')] =
/ total s (step*_parright_std _ _ _ _ s _) /
fn s,d ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)]:[g ⊢ step _ (gp T) _] ⇒ let [g ⊢ D] = d in
         let [g ⊢ ex_kn _ H N] = no_key_of_prlab_in_std [g ⊢ T] [g ⊢ D] in [g ⊢ st_s* (sc (fwc (fc_parr F H N)))]
       | [g ⊢ so (fwo F)]:[g ⊢ step _ (go (open \a.T)) _] ⇒ let [g ⊢ D] = d in
         let [g,a:names ⊢ ex_k H] = existence_of_key [g,a:names ⊢ T] in
         let [g,a:names ⊢ H]:[g,a:names ⊢ key _ K[]] = [g,a:names ⊢ H] in
         let [g ⊢ N] = no_key_in_std [⊢ K] [g ⊢ D] in [g ⊢ st_s* (so (fwo (fo_parr F (\a.H) N)))]
       | [g ⊢ sc (bwc B)]:[g ⊢ step _ (gp T) _] ⇒ let [g ⊢ D] = d in
         let [g ⊢ ex_kn _ H N] = no_key_of_prlab_in_std [g ⊢ T] [g ⊢ D] in [g ⊢ st_s* (sc (bwc (bc_parr B H N)))]
       | [g ⊢ so (bwo B)]:[g ⊢ step _ (go (open \a.T)) _] ⇒ let [g ⊢ D] = d in
         let [g,a:names ⊢ ex_k H] = existence_of_key [g,a:names ⊢ T] in
         let [g,a:names ⊢ H]:[g,a:names ⊢ key _ K[]] = [g,a:names ⊢ H] in
         let [g ⊢ N] = no_key_in_std [⊢ K] [g ⊢ D] in [g ⊢ st_s* (so (bwo (bo_parr B (\a.H) N)))])
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ S1*'] = step*_parright_std [g ⊢ S1*] d in
    let [g ⊢ S2*'] = step*_parright_std [g ⊢ S2*] d in [g ⊢ tr_s* S1*' S2*']
;


% If a standard process makes a closed forward transition F indexed by the key K,
% then any key different than K does not occur in the target of F
rec lemma_fstep_closed_std: (g:ctx) [g ⊢ std X] → [g ⊢ fstep_cl X T Y] →
  [g ⊢ key T M[]] → [g ⊢ neq M[] K[]] → [g ⊢ notin K[] Y] =
/ total d (lemma_fstep_closed_std _ _ _ _ _ _ d _ _ _) /
fn d,f,h,i ⇒ let [g ⊢ I]:[g ⊢ neq _ K[]] = i in
case d of
  | [g ⊢ std_null] ⇒ impossible f
  | [g ⊢ std_pref D] ⇒ let [g ⊢ fc_pref _] = f in
    let [g ⊢ refk] = uniqueness_of_key h [g ⊢ key_base] in
    let [g ⊢ N] = no_key_in_std [⊢ K] [g ⊢ D] in
    let [g ⊢ I] = symmetric_neq i in [g ⊢ not_kpref I N]
  | [g ⊢ std_sum D1 D2] ⇒ (case f of
       | [g ⊢ fc_suml FL _] ⇒ let [g ⊢ key_suml H] = h in
         let [g ⊢ N1] = lemma_fstep_closed_std [g ⊢ D1] [g ⊢ FL] [g ⊢ H] i in
         let [g ⊢ N2] = no_key_in_std [⊢ K] [g ⊢ D2] in [g ⊢ not_sum N1 N2]
       | [g ⊢ fc_sumr FR _] ⇒ let [g ⊢ key_sumr H] = h in
         let [g ⊢ N1] = no_key_in_std [⊢ K] [g ⊢ D1] in
         let [g ⊢ N2] = lemma_fstep_closed_std [g ⊢ D2] [g ⊢ FR] [g ⊢ H] i in [g ⊢ not_sum N1 N2])
  | [g ⊢ std_par D1 D2] ⇒ (case f of
       | [g ⊢ fc_parl F1 _ _] ⇒ let [g ⊢ key_parl H] = h in
         let [g ⊢ N1] = lemma_fstep_closed_std [g ⊢ D1] [g ⊢ F1] [g ⊢ H] i in
         let [g ⊢ N2] = no_key_in_std [⊢ K] [g ⊢ D2] in [g ⊢ not_par N1 N2]
       | [g ⊢ fc_parr F2 _ _] ⇒ let [g ⊢ key_parr H] = h in
         let [g ⊢ N1] = no_key_in_std [⊢ K] [g ⊢ D1] in
         let [g ⊢ N2] = lemma_fstep_closed_std [g ⊢ D2] [g ⊢ F2] [g ⊢ H] i in [g ⊢ not_par N1 N2]
       | [g ⊢ fc_synl F1 _ H1 F2 _ H2] ⇒  let [g ⊢ key_sync H] = h in
         let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H1] in
         let [g ⊢ N1] = lemma_fstep_closed_std [g ⊢ D1] [g ⊢ F1] [g ⊢ H1] i in
         let [g ⊢ N2] = lemma_fstep_closed_std [g ⊢ D2] [g ⊢ F2] [g ⊢ H2] i in [g ⊢ not_par N1 N2]
       | [g ⊢ fc_synr F1 _ H1 F2 _ H2] ⇒ let [g ⊢ key_sync H] = h in
         let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H1] in
         let [g ⊢ N1] = lemma_fstep_closed_std [g ⊢ D1] [g ⊢ F1] [g ⊢ H1] i in
         let [g ⊢ N2] = lemma_fstep_closed_std [g ⊢ D2] [g ⊢ F2] [g ⊢ H2] i in [g ⊢ not_par N1 N2])
  | [g ⊢ std_nu \a.D] ⇒ let [g ⊢ fc_nu \a.F] = f in
    let [g ⊢ H] = h in
    let [g,a:names ⊢ N] = lemma_fstep_closed_std [g,a:names ⊢ D] [g,a:names ⊢ F]
        [g,a:names ⊢ H[..]] [g,a:names ⊢ I[..]] in [g ⊢ not_nu \a.N]
;