%%% BTI: backward transitions are independent

% Auxiliary lemmas

% If a key K does not occur in a process, and such process makes a backward closed transition
% labelled by T, then K is different from key(T).
rec key_in_bstep_cl: (g:ctx) [g ⊢ notin K[] X] → [g ⊢ bstep_cl X T Y] → [g ⊢ key T M[]] → [g ⊢ neq K[] M[]] =
/ total n (key_in_bstep_cl _ _ _ _ _ _ n _ _) /
fn n,b,h ⇒ case n of
  | [g ⊢ not_null] ⇒ impossible b
  | [g ⊢ not_pref N] ⇒ impossible b
  | [g ⊢ not_kpref I N] ⇒ (case b of
       | [g ⊢ bc_pref _] ⇒ let [g ⊢ key_base] = h in [g ⊢ I]
       | [g ⊢ bc_kpref B H _] ⇒ let [g ⊢ H'] = h in
         let [g ⊢ refky] = unique_key [g ⊢ H] [g ⊢ H'] in 
         key_in_bstep_cl [g ⊢ N] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_sum N1 N2] ⇒ (case b of
       | [g ⊢ bc_suml B _] ⇒ let [g ⊢ key_suml H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_sumr B _] ⇒ let [g ⊢ key_sumr H] = h in key_in_bstep_cl [g ⊢ N2] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_par N1 N2] ⇒ (case b of
       | [g ⊢ bc_parl B _ _] ⇒ let [g ⊢ key_parl H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_parr B _ _] ⇒ let [g ⊢ key_parr H] = h in key_in_bstep_cl [g ⊢ N2] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_synl B _ _ _ _ _] ⇒ let [g ⊢ key_sync H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_synr B _ _ _ _ _] ⇒ let [g ⊢ key_sync H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_nu \a.N] ⇒ let [g ⊢ bc_nu \a.B] = b in
    let [g ⊢ H] = h in 
    let [g,a:names ⊢ I[..]] = key_in_bstep_cl [_ ⊢ N] [_ ⊢ B] [_ ⊢ H[..]] in [g ⊢ I]
;

% If a key K does not occur in a process, and such process makes a backward open transition
% labelled by T, then K is different from key(T).
rec key_in_bstep_op: (g:ctx) [g ⊢ notin K[] X] → [g ⊢ bstep_op X (open \a.T) Y] → [g,a:names ⊢ key T M[]] → [g ⊢ neq K[] M[]] =
/ total n (key_in_bstep_op _ _ _ _ _ _ n _ _) /
fn n,b,h ⇒ case n of
  | [g ⊢ not_null] ⇒ impossible b
  | [g ⊢ not_pref N] ⇒ impossible b
  | [g ⊢ not_kpref I N] ⇒ let [g ⊢ bo_kpref B (\a.H) _] = b in
    let [g,a:names ⊢ H'] = h in
    let [g,a:names ⊢ refky] = unique_key [_ ⊢ H] [_ ⊢ H'] in 
    key_in_bstep_op [g ⊢ N] [g ⊢ B] [_ ⊢ H]
  | [g ⊢ not_sum N1 N2] ⇒ (case b of
       | [g ⊢ bo_suml B _] ⇒ let [g,a:names ⊢ key_suml H] = h in key_in_bstep_op [g ⊢ N1] [g ⊢ B] [_ ⊢ H]
       | [g ⊢ bo_sumr B _] ⇒ let [g,a:names ⊢ key_sumr H] = h in key_in_bstep_op [g ⊢ N2] [g ⊢ B] [_ ⊢ H])
  | [g ⊢ not_par N1 N2] ⇒ (case b of
       | [g ⊢ bo_parl B (\_._) _] ⇒ let [g,a:names ⊢ key_parl H] = h in key_in_bstep_op [g ⊢ N1] [g ⊢ B] [_ ⊢ H]
       | [g ⊢ bo_parr B (\_._) _] ⇒ let [g,a:names ⊢ key_parr H] = h in key_in_bstep_op [g ⊢ N2] [g ⊢ B] [_ ⊢ H])
  | [g ⊢ not_nu \a.N] ⇒ let [g,a:names ⊢ H] = h in 
    (case b of
       | [g ⊢ bo_nu_cl (\_._) (\_._) (\a.B)] ⇒
         let [g,a:names ⊢ I[..]] = key_in_bstep_cl [_ ⊢ N] [_ ⊢ B] [_ ⊢ H[..]] in [g ⊢ I]
       | [g ⊢ bo_nu_op \a.B] ⇒ 
         let [g,a:names ⊢ I[..]] = key_in_bstep_op [_ ⊢ N] [_ ⊢ B] [_ ⊢ H[..]] in [g ⊢ I])
;

% Given two independent valid closed proof labels, their keys are different.
rec indep_impl_diff_keys: (g:ctx) [g ⊢ valid_cl T1] → [g ⊢ valid_cl T2]
  → [g ⊢ indep_cl T1 T2] → [g ⊢ key T1 K1[]] → [g ⊢ key T2 K2[]] → [g ⊢ neq K1[] K2[]] =
/ total i (indep_impl_diff_keys _ _ _ _ _ _ _ i _ _) /
fn v1,v2,i,h1,h2 ⇒ case i of
  | [g ⊢ i_c1l I] ⇒ let [g ⊢ v_suml V1] = v1 in
    let [g ⊢ v_suml V2] = v2 in
    let [g ⊢ key_suml H1] = h1 in
    let [g ⊢ key_suml H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_c1r I] ⇒ let [g ⊢ v_sumr V1] = v1 in
    let [g ⊢ v_sumr V2] = v2 in
    let [g ⊢ key_sumr H1] = h1 in
    let [g ⊢ key_sumr H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_p1l I] ⇒ let [g ⊢ v_parl V1] = v1 in
    let [g ⊢ v_parl V2] = v2 in
    let [g ⊢ key_parl H1] = h1 in
    let [g ⊢ key_parl H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_p1r I] ⇒ let [g ⊢ v_parr V1] = v1 in
    let [g ⊢ v_parr V2] = v2 in
    let [g ⊢ key_parr H1] = h1 in
    let [g ⊢ key_parr H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_p2l H1 H2 N] ⇒ let [g ⊢ key_parl H1'] = h1 in
    let [g ⊢ key_parr H2'] = h2 in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in [g ⊢ N]
  | [g ⊢ i_p2r H1 H2 N] ⇒ let [g ⊢ key_parr H1'] = h1 in
    let [g ⊢ key_parl H2'] = h2 in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in [g ⊢ N]
  | [g ⊢ i_s1l I] ⇒ let [g ⊢ key_parl H1] = h1 in
    let [g ⊢ key_sync H2] = h2 in
    let [g ⊢ v_parl V1] = v1 in
    (case v2 of
       | [g ⊢ v_synl V2 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
       | [g ⊢ v_synr V2 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2])
  | [g ⊢ i_s1r I] ⇒ let [g ⊢ key_parr H1] = h1 in
    let [g ⊢ key_sync H2] = h2 in
    let [g ⊢ v_parr V1] = v1 in
    (case v2 of
       | [g ⊢ v_synl _ V2 _ HL2 _ HR2] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL2] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ HR2]
       | [g ⊢ v_synr _ V2 _ HL2 _ HR2] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL2] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ HR2])
  | [g ⊢ i_s2l I] ⇒ let [g ⊢ key_sync H1] = h1 in
    let [g ⊢ key_parl H2] = h2 in
    let [g ⊢ v_parl V2] = v2 in
    (case v1 of
       | [g ⊢ v_synl V1 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
       | [g ⊢ v_synr V1 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2])
  | [g ⊢ i_s2r I] ⇒ let [g ⊢ key_sync H1] = h1 in
    let [g ⊢ key_parr H2] = h2 in
    let [g ⊢ v_parr V2] = v2 in
    (case v1 of
       | [g ⊢ v_synl _ V1 _ HL1 _ HR1] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL1] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ HR1] [g ⊢ H2]
       | [g ⊢ v_synr _ V1 _ HL1 _ HR1] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL1] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ HR1] [g ⊢ H2])
  | [g ⊢ i_s3 I1 I2] ⇒ let [g ⊢ key_sync H1] = h1 in
    let [g ⊢ key_sync H2] = h2 in 
    (case v1 of
       | [g ⊢ v_synl VL1 VR1 _ HL1 _ HR1] ⇒ (case v2 of
            | [g ⊢ v_synl VL2 VR2 _ HL2 _ HR2] ⇒
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2]
            | [g ⊢ v_synr VL2 VR2 _ HL2 _ HR2] ⇒ 
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2])
       | [g ⊢ v_synr VL1 VR1 _ HL1 _ HR1] ⇒ (case v2 of
            | [g ⊢ v_synl VL2 VR2 _ HL2 _ HR2] ⇒
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2]
            | [g ⊢ v_synr VL2 VR2 _ HL2 _ HR2] ⇒
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2]))
;

% Strengthening lemma for indep_cl 
rec str_indep: (g:ctx) [g,a:names ⊢ indep_cl T1[..] T2[..]] → [g ⊢ indep_cl T1 T2] =
/ total i (str_indep _ _ _ i) /
fn i ⇒ case i of
  | [g,a:names ⊢ i_c1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_c1l I']
  | [g,a:names ⊢ i_c1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_c1r I']
  | [g,a:names ⊢ i_p1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_p1l I']
  | [g,a:names ⊢ i_p1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_p1r I']
  | [g,a:names ⊢ i_p2l H1 H2 N[..]] ⇒ let [g ⊢ H1'] = str_key [_ ⊢ H1] in
     let [g ⊢ H2'] = str_key [_ ⊢ H2] in [g ⊢ i_p2l H1' H2' N]
  | [g,a:names ⊢ i_p2r H1 H2 N[..]] ⇒ let [g ⊢ H1'] = str_key [_ ⊢ H1] in
     let [g ⊢ H2'] = str_key [_ ⊢ H2] in [g ⊢ i_p2r H1' H2' N]
  | [g,a:names ⊢ i_s1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s1l I']
  | [g,a:names ⊢ i_s1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s1r I']
  | [g,a:names ⊢ i_s2l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s2l I']
  | [g,a:names ⊢ i_s2r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s2r I']
  | [g,a:names ⊢ i_s3 I1 I2] ⇒ let [g ⊢ I1'] = str_indep [_ ⊢ I1] in
    let [g ⊢ I2'] = str_indep [_ ⊢ I2] in [g ⊢ i_s3 I1' I2']
;



% Proof of BTI
% Since, in the encoding, backward transitions are either closed or open,
% and the statement of BTI involves two backward transitions, we first prove
% BTI for each of the four cases where the two transitions are respectively
% closed-closed, closed-open, open-closed and open-open.
% We will then prove the original version of BTI for generic backward
% transitions by applying these four subtheorems.

% Observe that, since Beluga does not present a negation operator at the LF level,
% we prove a version of BTI which is different, but equivalent, to its paper version:
% instead of proving that two different backward transitions are independent,
% we prove that two backward transitions are either identical or independent.

% Given two backward closed transitions B1 and B2, id_or_ind_cc B1 B2 holds iff
% either B1=B2, or their proof labels are independent. 
LF id_or_ind_cc: bstep_cl X T1 X1 → bstep_cl X T2 X2 → type =
  | bt_id_cc: eqbc B1 B2 → id_or_ind_cc B1 B2
  | bt_ind_cc: indep_cl T1 T2 → id_or_ind_cc (B1:bstep_cl X T1 X1) (B2:bstep_cl X T2 X2)
;

% BTI, closed-closed case:
% Given two backward closed transitions sharing the same source process,
% they are either identical or their proof labels are independent.
rec bti_cc: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {B2:[g ⊢ bstep_cl X T2 X2]}
  [g ⊢ id_or_ind_cc B1 B2] =
/ total b1 (bti_cc _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bc_pref D1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_cc refbc]
       | [g ⊢ bc_kpref B2' _ _] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_kpref B1' H1 I1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ impossible source_is_not_std_bc [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_kpref B2' H2 I2] ⇒ 
         (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let refnq [g ⊢ _] = unique_neq [g ⊢ I1] [g ⊢ I2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc I]))
  | [g ⊢ bc_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_c1l I)])
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bc_sumr B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_c1r I)]))
  | [g ⊢ bc_parl B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_p1l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ bt_ind_cc (i_p2l H1 H2 N)]
       | [g ⊢ bc_synl BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1l I)])
       | [g ⊢ bc_synr BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1l I)]))
  | [g ⊢ bc_parr B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ bt_ind_cc (i_p2r H1 H2 N)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_p1r I)])
       | [g ⊢ bc_synl BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1r I)])
       | [g ⊢ bc_synr BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1r I)]))
  | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BR1] [g ⊢ HR1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BL1] [g ⊢ HL1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LL1] [g ⊢ LL2] in
              let [g ⊢ refky] = unique_key [g ⊢ HL1] [g ⊢ HL2] in
              (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   [g ⊢ bt_id_cc refbc]
                 | [g ⊢ bt_ind_cc I2] ⇒ let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BR1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BR2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I2] [g ⊢ HR1] [g ⊢ HR2] in
                   impossible irreflexive_neq [g ⊢ N])
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BL1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BL2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I1] [g ⊢ HL1] [g ⊢ HL2] in
                   impossible irreflexive_neq [g ⊢ N]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)]))
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LL1] [g ⊢ LL2]
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LR1] [g ⊢ LR2]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)])))
  | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BR1] [g ⊢ HR1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BL1] [g ⊢ HL1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LL1] [g ⊢ LL2]
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LR1] [g ⊢ LR2]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)]))
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LL1] [g ⊢ LL2] in
              let [g ⊢ refky] = unique_key [g ⊢ HL1] [g ⊢ HL2] in
              (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   [g ⊢ bt_id_cc refbc]
                 | [g ⊢ bt_ind_cc I2] ⇒ let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BR1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BR2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I2] [g ⊢ HR1] [g ⊢ HR2] in
                   impossible irreflexive_neq [g ⊢ N])
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BL1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BL2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I1] [g ⊢ HL1] [g ⊢ HL2] in
                   impossible irreflexive_neq [g ⊢ N]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)])))
  | [g ⊢ bc_nu \a.B1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in 
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ bt_id_cc refbc] ⇒ [g ⊢ bt_id_cc refbc]
            | [g,a:names ⊢ bt_ind_cc I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in
                                            [g ⊢ bt_ind_cc I'])
;



% BTI, closed-open case:
% Given a closed and an open backward transition sharing the same source process,
% their proof labels are independent.
% Observe that, unlike the closed-closed case, the two transitions cannot be identical:
% this is because closed and open transitions belong to distinct types.
rec bti_co: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {B2:[g ⊢ bstep_op X T2 X2]}
  [g ⊢ indep (p_cl T1) (p_op T2)] =
/ total b2 (bti_co _ _ _ _ _ _ _ b2) /
mlam B1,B2 ⇒ case [_ ⊢ B2] of
  | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ let [g ⊢ bc_nu \a.B1'] = [g ⊢ B1] in
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
      | [g,a:names ⊢ bt_id_cc refbc] ⇒ impossible occur_imp [_ ⊢ O2]
      | [g,a:names ⊢ bt_ind_cc I] ⇒ [g ⊢ i_co \a.I])
  | [g ⊢ bo_kpref B2' (\a.H2) I2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_pref D1] ⇒ impossible source_is_not_std_bo [_ ⊢ B2'] [_ ⊢ D1]
       | [g ⊢ bc_kpref B1' H1 I1] ⇒ bti_co [g ⊢ B1'] [g ⊢ B2'])
  | [g ⊢ bo_suml B2' D2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_suml B1' D1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_c1l I)]
       | [g ⊢ bc_sumr B1' D1] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bo_sumr B2' D2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_suml B1' D1] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bc_sumr B1' D1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_c1r I)])
  | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_parl B1' H1 N1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_p1l I)]
       | [g ⊢ bc_parr B1' H1 N1] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
         [g ⊢ i_co \a.(i_p2r H1[..] H2 N[..])]
       | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BL1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2l I)]
       | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BL1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2l I)])
  | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_parl B1' H1 N1] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
         [g ⊢ i_co \a.(i_p2l H1[..] H2 N[..])]
       | [g ⊢ bc_parr B1' H1 N1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_p1r I)]
       | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BR1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2r I)]
       | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BR1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2r I)])
  | [g ⊢ bo_nu_op \a.B2'] ⇒ let [g ⊢ bc_nu \a.B1'] = [g ⊢ B1] in 
    let [g,a:names ⊢ i_co \b.I[..,b,a]] = bti_co [_ ⊢ B1'] [_ ⊢ B2'] in
    [g ⊢ i_co \b.I[..,b]]
;



% BTI, open-closed case:
% Given an open and a closed backward transition sharing the same source process,
% their proof labels are independent.
rec bti_oc: (g:ctx) {B1:[g ⊢ bstep_op X T1 X1]} {B2:[g ⊢ bstep_cl X T2 X2]}
  [g ⊢ indep (p_op T1) (p_cl T2)] =
/ total b1 (bti_oc _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bo_nu_cl (\a.O1) (\a.L1) (\a.B1')] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
      | [g,a:names ⊢ bt_id_cc refbc] ⇒ impossible occur_imp [_ ⊢ O1]
      | [g,a:names ⊢ bt_ind_cc I] ⇒ [g ⊢ i_oc \a.I])
  | [g ⊢ bo_kpref B1' (\a.H1) I1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ impossible source_is_not_std_bo [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_kpref B2' H2 I2] ⇒ bti_oc [g ⊢ B1'] [g ⊢ B2'])
  | [g ⊢ bo_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_c1l I)]
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B1'] [g ⊢ D2])
  | [g ⊢ bo_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_sumr B2' D2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_c1r I)])
  | [g ⊢ bo_parl B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_p1l I)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
         [g ⊢ i_oc \a.(i_p2l H1 H2[..] N[..])]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BL2] in
         [g ⊢ i_oc \a.(i_s1l I)]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BL2] in
         [g ⊢ i_oc \a.(i_s1l I)])
  | [g ⊢ bo_parr B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
         [g ⊢ i_oc \a.(i_p2r H1 H2[..] N[..])]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_p1r I)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BR2] in
         [g ⊢ i_oc \a.(i_s1r I)]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BR2] in
         [g ⊢ i_oc \a.(i_s1r I)])
  | [g ⊢ bo_nu_op \a.B1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in 
    let [g,a:names ⊢ i_oc \b.I[..,b,a]] = bti_oc [_ ⊢ B1'] [_ ⊢ B2'] in 
    [g ⊢ i_oc \b.I[..,b]]
;



% Given two backward open transitions B1 and B2, id_or_ind_oo B1 B2 holds iff
% either B1=B2, or their proof labels are independent. 
LF id_or_ind_oo: bstep_op X T1 X1 → bstep_op X T2 X2 → type =
  | bt_id_oo: eqbo B1 B2 → id_or_ind_oo B1 B2
  | bt_ind_oo: indep (p_op T1) (p_op T2) → id_or_ind_oo (B1:bstep_op X T1 X1) (B2:bstep_op X T2 X2)
;

% BTI, open-open case:
% Given two backward open transitions sharing the same source process,
% they are either identical or their proof labels are independent.
rec bti_oo: (g:ctx) {B1:[g ⊢ bstep_op X T1 X1]} {B2:[g ⊢ bstep_op X T2 X2]}
  [g ⊢ id_or_ind_oo B1 B2] =
/ total b1 (bti_oo _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bo_nu_cl (\a.O1) (\a.L1) (\a.B1')] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ bt_id_cc refbc] ⇒ let [g,a:names ⊢ refoc] = unique_occ [_ ⊢ O1] [_ ⊢ O2] in
              let [g,a:names ⊢ reflb] = unique_lab [_ ⊢ L1] [_ ⊢ L2] in [g ⊢ bt_id_oo refbo]
            | [g,a:names ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_oo (i_oo \a.I)])
       | [g ⊢ bo_nu_op \a.B2'] ⇒ let [g,a:names ⊢ i_co \b.I] = bti_co [_ ⊢ B1'] [_ ⊢ B2'] in
         [g ⊢ bt_ind_oo (i_oo \b.I[..,b])])
  | [g ⊢ bo_kpref B1' (\a.H1) I1] ⇒ let [g ⊢ bo_kpref B2' (\a.H2) I2] = [g ⊢ B2] in
    (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
       | [g ⊢ bt_id_oo refbo] ⇒ let [g,a:names ⊢ refky] = unique_key [_ ⊢ H1] [_ ⊢ H2] in
         let refnq [g ⊢ _] = unique_neq [g ⊢ I1] [g ⊢ I2] in [g ⊢ bt_id_oo refbo]
       | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.I)])
  | [g ⊢ bo_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_suml B2' D2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_c1l I))])
       | [g ⊢ bo_sumr B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bo_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_suml B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bo_sumr B2' D2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_c1r I))]))
  | [g ⊢ bo_parl B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g,a:names ⊢ refky] = unique_key [_ ⊢ H1] [_ ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_p1l I))])
       | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
              [g ⊢ bt_ind_oo (i_oo \a.(i_p2l H1 H2 N[..]))])
  | [g ⊢ bo_parr B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
              [g ⊢ bt_ind_oo (i_oo \a.(i_p2r H1 H2 N[..]))]
       | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g,a:names ⊢ refky] = unique_key [_ ⊢ H1] [_ ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_p1r I))]))
  | [g ⊢ bo_nu_op \a.B1'] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ let [g,a:names ⊢ i_oc \b.I] = bti_oc [_ ⊢ B1'] [_ ⊢ B2'] in
         [g ⊢ bt_ind_oo (i_oo \b.I[..,b])]
       | [g ⊢ bo_nu_op \a.B2'] ⇒ (case bti_oo [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ bt_id_oo refbo] ⇒ [g ⊢ bt_id_oo refbo]
            | [g,a:names ⊢ bt_ind_oo (i_oo \b.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \b.I[..,b])]))
;


% Equality of derivations of bstep X' T X
LF eqb: bstep X1' T1 X1 → bstep X2' T2 X2 → type =
  | refb: eqb B B
;

% Given two backward transitions B1 and B2, id_or_ind B1 B2 holds iff
% either B1=B2, or their proof labels are independent. 
LF id_or_ind: bstep X T1 X1 → bstep X T2 X2 → type =
  | bt_id: eqb B1 B2 → id_or_ind B1 B2
  | bt_ind: indep T1 T2 → id_or_ind (B1:bstep X T1 X1) (B2:bstep X T2 X2)
;

% BTI:
% Given two backward transitions sharing the same source process,
% they are either identical or their proof labels are independent.
rec bti: (g:ctx) {B1:[g ⊢ bstep X T1 X1]} {B2:[g ⊢ bstep X T2 X2]}
  [g ⊢ id_or_ind B1 B2] =
/ total b1 (bti _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bc B1'] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc B2'] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ [g ⊢ bt_id refb]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind (i_cc I)])
       | [g ⊢ bo B2'] ⇒ let [g ⊢ I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in [g ⊢ bt_ind I])
  | [g ⊢ bo B1'] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc B2'] ⇒ let [g ⊢ I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in [g ⊢ bt_ind I]
       | [g ⊢ bo B2'] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ [g ⊢ bt_id refb]
            | [g ⊢ bt_ind_oo I] ⇒ [g ⊢ bt_ind I]))
;