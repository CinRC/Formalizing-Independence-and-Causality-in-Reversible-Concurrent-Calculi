%%% SP: square property


% If a process X makes a closed forward transition F into the process X',
% and a key K does not occur in X' (i.e., notin K X' holds), then K does
% not occur in X as well (notin K X).
rec notin_propagates_to_source_fc: (g:ctx) [g ⊢ fstep_cl X T X'] →
   [g ⊢ notin K[] X'] → [g ⊢ notin K[] X] =
/ total f (notin_propagates_to_source_fc _ _ _ _ _ f _) /
fn f,n ⇒ case f of
  | [g ⊢ fc_pref _] ⇒ let [g ⊢ not_kpref _ N] = n in [g ⊢ not_pref N]
  | [g ⊢ fc_kpref F _ _] ⇒ let [g ⊢ not_kpref I N] = n in
    let [g ⊢ N'] = notin_propagates_to_source_fc [g ⊢ F] [g ⊢ N] in [g ⊢ not_kpref I N']
  | [g ⊢ fc_suml F1 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in [g ⊢ not_sum N1' N2]
  | [g ⊢ fc_sumr F2 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_sum N1 N2']
  | [g ⊢ fc_parl F1 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in [g ⊢ not_par N1' N2]
  | [g ⊢ fc_parr F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_par N1 N2']
  | [g ⊢ fc_synl F1 _ _ F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_synr F1 _ _ F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_nu \a.F] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g,a:names ⊢ N'] = notin_propagates_to_source_fc [_ ⊢ F] [_ ⊢ N] in [g ⊢ not_nu \a.N']
;

% If a process X makes a closed forward transition F into the process X',
% and a key K does not occur in X (i.e., notin K X holds), then
% then any key different than K does not occur in X' (notin K X').
rec notin_propagates_to_target_fc: (g:ctx) [g ⊢ fstep_cl X T X'] →
  [g ⊢ key T M[]] → [g ⊢ notin K[] X] → [g ⊢ neq M[] K[]] → [g ⊢ notin K[] X'] =
/ total f (notin_propagates_to_target_fc _ _ _ _ _ _ f _ _ _) /
fn f,h,n,i ⇒ case f of
  | [g ⊢ fc_pref _] ⇒ let [g ⊢ key_base] = h in
    let [g ⊢ not_pref N] = n in
    let [g ⊢ I] = symmetric_neq i in [g ⊢ not_kpref I N]
  | [g ⊢ fc_kpref F _ _] ⇒ let [g ⊢ not_kpref I' N] = n in
    let [g ⊢ N'] = notin_propagates_to_target_fc [g ⊢ F] h [g ⊢ N] i in [g ⊢ not_kpref I' N']
  | [g ⊢ fc_suml F1 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ key_suml H1] = h in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in [g ⊢ not_sum N1' N2]
  | [g ⊢ fc_sumr F2 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ key_sumr H2] = h in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_sum N1 N2']
  | [g ⊢ fc_parl F1 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_parl H1] = h in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in [g ⊢ not_par N1' N2]
  | [g ⊢ fc_parr F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_parr H2] = h in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_par N1 N2']
  | [g ⊢ fc_synl F1 _ H1 F2 _ H2] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_sync H1'] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_synr F1 _ H1 F2 _ H2] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_sync H1'] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_nu \a.F] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g ⊢ H] = h in
    let [g ⊢ I] = i in
    let [g,a:names ⊢ N'] = notin_propagates_to_target_fc [_ ⊢ F] [_ ⊢ H[..]] [_ ⊢ N] [_ ⊢ I[..]] in [g ⊢ not_nu \a.N']
;

% Existence of transitions closing a square diagram for the 
% forward-forward, closed-closed case
LF square_ffcc: fstep_cl X T1 X1 → fstep_cl X1 T2 Y → type =
  | s_ffcc: fstep_cl X T2 X2 → fstep_cl X2 T1 Y → square_ffcc (F1:fstep_cl X T1 X1) (F2:fstep_cl X1 T2 Y)
;

% First auxiliary lemma for SP, closed-closed case:
% Given two composable forward closed transitions with independent proof labels,
% there exist two forward closed transitions closing the square diagram.
rec sp_ffcc: (g:ctx) {F1:[g ⊢ fstep_cl X T1 X1]} {F2:[g ⊢ fstep_cl X1 T2 Y]}
  [g ⊢ indep (p_cl T1) (p_cl T2)] → [g ⊢ square_ffcc F1 F2] =
/ total f1 (sp_ffcc _ _ _ _ _ _ f1 _ _) /
mlam F1,F2 ⇒ fn i ⇒ let [g ⊢ i_cc I] = i in
(case [g ⊢ F1] of
  | [g ⊢ fc_pref D1] ⇒ impossible [g ⊢ I]
  | [g ⊢ fc_kpref F1' H1 N1] ⇒ let [g ⊢ fc_kpref F2' H2 N2] = [g ⊢ F2] in 
       let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I] in
       [g ⊢ s_ffcc (fc_kpref F2'' H2 N2) (fc_kpref F1'' H1 N1)]
  | [g ⊢ fc_suml F1' D1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml F2' _] ⇒ let [g ⊢ i_c1l I'] = [g ⊢ I] in
            let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I'] in
            [g ⊢ s_ffcc (fc_suml F2'' D1) (fc_suml F1'' D1)]
       | [g ⊢ fc_sumr F2' D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fc_sumr F1' D1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml F2' D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ fc_sumr F2' _] ⇒ let [g ⊢ i_c1r I'] = [g ⊢ I] in
            let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I'] in
            [g ⊢ s_ffcc (fc_sumr F2'' D1) (fc_sumr F1'' D1)])
  | [g ⊢ fc_parl F1' H1 N1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ let [g ⊢ i_p1l I'] = [g ⊢ I] in
            let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I'] in
            [g ⊢ s_ffcc (fc_parl F2'' H2 N2) (fc_parl F1'' H1 N1)]
       | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g ⊢ i_p2l H1' H2' N] = [g ⊢ I] in
            let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
            let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
            let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
            let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
            [g ⊢ s_ffcc (fc_parr F2' H2 N2') (fc_parl F1' H1 N1')]
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s1l I'] = [g ⊢ I] in
            let [g ⊢ s_ffcc FL2' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ FL2] [g ⊢ i_cc I'] in
            ?%[g ⊢ s_ffcc (fc_synl FL2' LL2 HL2 FR2 LR2 HR2) (fc_parl F1'' H1 N1)]
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ ?)
  | [g ⊢ fc_parr F1' H1 N1] ⇒ ?
  | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ ?
       | [g ⊢ fc_parr F2' H2 N2] ⇒ ?
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ ?
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ ?)
  | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ ?
  | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
       let [g,a:names ⊢ s_ffcc F2'' F1''] = sp_ffcc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_cc I[..]] in
       [g ⊢ s_ffcc (fc_nu \a.F2'') (fc_nu \a.F1'')]
)
;