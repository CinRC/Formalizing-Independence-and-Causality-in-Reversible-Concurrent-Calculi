%%% IRE: independence respects events

% The statement of IRE requires the definition of the relation ~ of equivalence of transitions,
% that relates two transitions if they correspond to the same event.
% We define it here and show that the definition is well-posed.

% Coercion from forward transitions to combined transitions
LF forw_to_comb: fstep X T Y → step X T Y → type =
  | ftc_cl: {F:fstep_cl X T Y} forw_to_comb (fc F) (sc (fwc F))
  | ftc_op: {F:fstep_op X T Y} forw_to_comb (fo F) (so (fwo F))
;

% Totality of forw_to_comb: given a forward transition F,
% there exists at least one combined transition S such that forw_to_comb(F)=S.
LF ex_ftc: fstep X T Y → type =
  | ftc: forw_to_comb F S → ex_ftc F
;
rec total_forw_to_comb: (g:ctx) {F:[g ⊢ fstep X T Y]} [g ⊢ ex_ftc F] =
/ total f (total_forw_to_comb _ _ _ _ f) /
mlam F ⇒ case [_ ⊢ F] of
  | [g ⊢ fc F'] ⇒ [g ⊢ ftc (ftc_cl F')]
  | [g ⊢ fo F'] ⇒ [g ⊢ ftc (ftc_op F')]
;

% Functionality of forw_to_comb: given a forward transition F,
% there is at most one combined transition S such that forw_to_comb(F)=S.
rec functional_forw_to_comb: (g:ctx) (F:[g ⊢ fstep X T Y]) (S1:[g ⊢ step X T Y]) (S2:[g ⊢ step X T Y])
  [g ⊢ forw_to_comb F S1] → [g ⊢ forw_to_comb F S2] → [g ⊢ eqst S1 S2] =
/ total r1 (functional_forw_to_comb _ _ _ _ r1 _) /
fn r1,r2 ⇒ case r1 of
  | [g ⊢ ftc_cl _] ⇒ let [g ⊢ ftc_cl _] = r2 in unique_step [_ ⊢ _] [_ ⊢ _]
  | [g ⊢ ftc_op _] ⇒ let [g ⊢ ftc_op _] = r2 in unique_step [_ ⊢ _] [_ ⊢ _]
;


% Coercion from backward transitions to combined transitions
LF back_to_comb: bstep X T Y → step X T Y → type =
  | btc_cl: {B:bstep_cl X T Y} back_to_comb (bc B) (sc (bwc B))
  | btc_op: {B:bstep_op X T Y} back_to_comb (bo B) (so (bwo B))
;

% Totality of back_to_comb: given a backward transition B,
% there exists at least one combined transition S such that back_to_comb(B)=S.
LF ex_btc: bstep X T Y → type =
  | btc: back_to_comb B S → ex_btc B
;
rec total_back_to_comb: (g:ctx) {B:[g ⊢ bstep X T Y]} [g ⊢ ex_btc B] =
/ total b (total_back_to_comb _ _ _ _ b) /
mlam B ⇒ case [_ ⊢ B] of
  | [g ⊢ bc B'] ⇒ [g ⊢ btc (btc_cl B')]
  | [g ⊢ bo B'] ⇒ [g ⊢ btc (btc_op B')]
;

% Functionality of back_to_comb: given a backward transition B,
% there is at most one combined transition S such that back_to_comb(B)=S.
rec functional_back_to_comb: (g:ctx) (B:[g ⊢ bstep X T Y]) (S1:[g ⊢ step X T Y]) (S2:[g ⊢ step X T Y])
  [g ⊢ back_to_comb B S1] → [g ⊢ back_to_comb B S2] → [g ⊢ eqst S1 S2] =
/ total r1 (functional_back_to_comb _ _ _ _ r1 _) /
fn r1,r2 ⇒ case r1 of
  | [g ⊢ btc_cl _] ⇒ let [g ⊢ btc_cl _] = r2 in unique_step [_ ⊢ _] [_ ⊢ _]
  | [g ⊢ btc_op _] ⇒ let [g ⊢ btc_op _] = r2 in unique_step [_ ⊢ _] [_ ⊢ _]
;


% Base case of the definition of equivalence of transitions:
% Two combined transitions are equivalent if they appear at opposite sides
% of a non-degenerate square in which each adjacent pair of transitions are independent.
inductive equiv_tr_base: (g:ctx) [g ⊢ step P A Q] → [g ⊢ step R A S] → ctype =
  | et_ff: {T:[g ⊢ fstep P A Q]} {U:[g ⊢ fstep P B R]} {U':[g ⊢ fstep Q B S]} {T':[g ⊢ fstep R A S]}
           (ST:[g ⊢ step P A Q]) (ST':[g ⊢ step R A S]) (RT:[g ⊢ step Q A P]) (RU:[g ⊢ step R B P])
           (RU':[g ⊢ step S B Q]) (RT':[g ⊢ step S A R])
           [g ⊢ forw_to_comb T ST] → [g ⊢ forw_to_comb U SU] → [g ⊢ forw_to_comb U' SU'] → [g ⊢ forw_to_comb T' ST'] →
           [g ⊢ inv_tr ST RT] → [g ⊢ inv_tr SU RU] → [g ⊢ inv_tr SU' RU'] → [g ⊢ inv_tr ST' RT'] →
           [g ⊢ indep_tr ST SU] → [g ⊢ indep_tr RU ST'] → [g ⊢ indep_tr RT' RU'] → [g ⊢ indep_tr SU' RT] →
           ([g ⊢ eqp Q R] → [g ⊢ false])
           → equiv_tr_base [g ⊢ ST] [g ⊢ ST']
  | et_fb: {T:[g ⊢ fstep P A Q]} {U:[g ⊢ bstep P B R]} {U':[g ⊢ bstep Q B S]} {T':[g ⊢ fstep R A S]}
           (ST:[g ⊢ step P A Q]) (ST':[g ⊢ step R A S]) (RT:[g ⊢ step Q A P]) (RU:[g ⊢ step R B P])
           (RU':[g ⊢ step S B Q]) (RT':[g ⊢ step S A R])
           [g ⊢ forw_to_comb T ST] → [g ⊢ back_to_comb U SU] → [g ⊢ back_to_comb U' SU'] → [g ⊢ forw_to_comb T' ST'] →
           [g ⊢ inv_tr ST RT] → [g ⊢ inv_tr SU RU] → [g ⊢ inv_tr SU' RU'] → [g ⊢ inv_tr ST' RT'] →
           [g ⊢ indep_tr ST SU] → [g ⊢ indep_tr RU ST'] → [g ⊢ indep_tr RT' RU'] → [g ⊢ indep_tr SU' RT] →
           ([g ⊢ eqp P S] → [g ⊢ false])
           → equiv_tr_base [g ⊢ ST] [g ⊢ ST']
  | et_bf: {T:[g ⊢ bstep P A Q]} {U:[g ⊢ fstep P B R]} {U':[g ⊢ fstep Q B S]} {T':[g ⊢ bstep R A S]}
           (ST:[g ⊢ step P A Q]) (ST':[g ⊢ step R A S]) (RT:[g ⊢ step Q A P]) (RU:[g ⊢ step R B P])
           (RU':[g ⊢ step S B Q]) (RT':[g ⊢ step S A R])
           [g ⊢ back_to_comb T ST] → [g ⊢ forw_to_comb U SU] → [g ⊢ forw_to_comb U' SU'] → [g ⊢ back_to_comb T' ST'] →
           [g ⊢ inv_tr ST RT] → [g ⊢ inv_tr SU RU] → [g ⊢ inv_tr SU' RU'] → [g ⊢ inv_tr ST' RT'] →
           [g ⊢ indep_tr ST SU] → [g ⊢ indep_tr RU ST'] → [g ⊢ indep_tr RT' RU'] → [g ⊢ indep_tr SU' RT] →
           ([g ⊢ eqp P S] → [g ⊢ false])
           → equiv_tr_base [g ⊢ ST] [g ⊢ ST']
  | et_bb: {T:[g ⊢ bstep P A Q]} {U:[g ⊢ bstep P B R]} {U':[g ⊢ bstep Q B S]} {T':[g ⊢ bstep R A S]}
           (ST:[g ⊢ step P A Q]) (ST':[g ⊢ step R A S]) (RT:[g ⊢ step Q A P]) (RU:[g ⊢ step R B P])
           (RU':[g ⊢ step S B Q]) (RT':[g ⊢ step S A R])
           [g ⊢ back_to_comb T ST] → [g ⊢ back_to_comb U SU] → [g ⊢ back_to_comb U' SU'] → [g ⊢ back_to_comb T' ST'] →
           [g ⊢ inv_tr ST RT] → [g ⊢ inv_tr SU RU] → [g ⊢ inv_tr SU' RU'] → [g ⊢ inv_tr ST' RT'] →
           [g ⊢ indep_tr ST SU] → [g ⊢ indep_tr RU ST'] → [g ⊢ indep_tr RT' RU'] → [g ⊢ indep_tr SU' RT] →
           ([g ⊢ eqp Q R] → [g ⊢ false])
           → equiv_tr_base [g ⊢ ST] [g ⊢ ST']
;


% Example of equivalence of transitions:
% P = a | b,  Q = a[k1] | b,  R = a | b[k0],  S = a[k1] | b[k0],
% with transitions executing a and b in either order.
rec example1: {S1:[a:names,b:names ⊢ step (par (pref (inp a) null) (pref (out b) null)) 
                                          (p_cl (pr_parl (pr_base (inp a) (s z))))
                                          (par (kpref (inp a) (s z) null) (pref (out b) null))]}
              {S2:[a:names,b:names ⊢ step (par (pref (inp a) null) (kpref (out b) (z) null))
                                          (p_cl (pr_parl (pr_base (inp a) (s z)))) 
                                          (par (kpref (inp a) (s z) null) (kpref (out b) (z) null))]}
              equiv_tr_base [a:names,b:names ⊢ S1] [a:names,b:names ⊢ S2] = 
/ total s1 (example1 s1 _) /
mlam S1,S2 ⇒ case [a:names,b:names ⊢ S1] of
  | [a:names,b:names ⊢ sc (fwc F)] ⇒ (case [a:names,b:names ⊢ S2] of
       | [a:names,b:names ⊢ sc (fwc F')] ⇒ 
         let [a:names,b:names ⊢ ftc (ftc_cl F1)] = total_forw_to_comb [a:names,b:names ⊢ fc F] in
         let [a:names,b:names ⊢ reffc] = unique_fstep_cl [a:names,b:names ⊢ F] [a:names,b:names ⊢ F1] in
         let [a:names,b:names ⊢ ftc (ftc_cl F4)] = total_forw_to_comb [a:names,b:names ⊢ fc F'] in
         let [a:names,b:names ⊢ reffc] = unique_fstep_cl [a:names,b:names ⊢ F'] [a:names,b:names ⊢ F4] in
         let [a:names,b:names ⊢ ex_iv (it _ RT)] = total_inv [a:names,b:names ⊢ sc (fwc F)] in
         let [a:names,b:names ⊢ ex_iv (it _ RT')] = total_inv [a:names,b:names ⊢ sc (fwc F')] in
         et_ff [_ ⊢ fc F] [_ ⊢ fc (fc_parr (fc_pref std_null) key_base (not_pref not_null))]
         [_ ⊢ fc (fc_parr (fc_pref std_null) key_base (not_kpref (nless (lzero z)) not_null))] [_ ⊢ fc F']
         [_ ⊢ ftc_cl F] [_ ⊢ ftc_cl _] [_ ⊢ ftc_cl _] [_ ⊢ ftc_cl F']
         [_ ⊢ it _ RT] [_ ⊢ it _ (sc (bwc (bc_parr (bc_pref std_null) key_base (not_pref not_null))))]
         [_ ⊢ it _ (sc (bwc (bc_parr (bc_pref std_null) key_base (not_kpref (nless (lzero z)) not_null))))] [_ ⊢ it _ RT']
         [_ ⊢ ind_tr (i_cc (i_p2l key_base key_base (ngreat (lzero z))))] [_ ⊢ ind_tr (i_cc (i_p2r key_base key_base (nless (lzero z))))]
         [_ ⊢ ind_tr (i_cc (i_p2l key_base key_base (ngreat (lzero z))))] [_ ⊢ ind_tr (i_cc (i_p2r key_base key_base (nless (lzero z))))]
         (fn e ⇒ impossible e)
       | [a:names,b:names ⊢ sc (bwc (bc_parl B' _ _))] ⇒ impossible [a:names,b:names ⊢ B'])
  | [a:names,b:names ⊢ sc (bwc (bc_parl B _ _))] ⇒ impossible [a:names,b:names ⊢ B]
;


% Equivalence of transitions ~:
% Reflexive, symmetric and transitive closure of the equiv_tr_base relation.
inductive equiv_tr: (g:ctx) [g ⊢ step P A Q] → [g ⊢ step R B S] → ctype =
  | et_base: equiv_tr_base [g ⊢ T] [g ⊢ T'] → equiv_tr [g ⊢ T] [g ⊢ T']
  | et_refl: equiv_tr [g ⊢ T] [g ⊢ T]
  | et_sym: equiv_tr [g ⊢ T'] [g ⊢ T] → equiv_tr [g ⊢ T] [g ⊢ T']
  | et_trans: equiv_tr [g ⊢ T] [g ⊢ T'] → equiv_tr [g ⊢ T'] [g ⊢ T''] → equiv_tr [g ⊢ T] [g ⊢ T'']
;

% Equality of proof labels
LF eqpl: pr_lab → pr_lab → type =
  | refpl: eqpl T T
;

% Equivalent transitions share the same proof label
rec equiv_tr_have_same_label: (g:ctx) (T:[g ⊢ step P A Q]) (T':[g ⊢ step R B S]) 
  equiv_tr [g ⊢ T] [g ⊢ T'] → [g ⊢ eqpl A B] =
/ total e (equiv_tr_have_same_label _ _ _ _ _ _ _ _ _ e) /
fn e ⇒ case e of
  | et_base _ ⇒ [_ ⊢ refpl]
  | et_refl ⇒ [_ ⊢ refpl]
  | et_sym e' ⇒ let [_ ⊢ refpl] = equiv_tr_have_same_label e' in [_ ⊢ refpl]
  | et_trans e1 e2 ⇒ let [_ ⊢ refpl] = equiv_tr_have_same_label e1 in
                      let [_ ⊢ refpl] = equiv_tr_have_same_label e2 in [_ ⊢ refpl]
;

% Independence respects events (IRE):
% Given three transitions t,t' and u, if t~t' (t and t' are equivalent) and t' and u are independent,
% then also t and u are independent.
rec ire: (g:ctx) (T:[g ⊢ step X1 T1 Y1]) (T':[g ⊢ step X2 T2 Y2]) (U:[g ⊢ step X3 T3 Y3]) 
  equiv_tr [g ⊢ T] [g ⊢ T'] → [g ⊢ indep_tr T' U] → [g ⊢ indep_tr T U] =
/ total e (ire _ _ _ _ _ _ _ _ _ _ _ _ _ e _) /
fn e,i ⇒ let [g ⊢ ind_tr I] = i in
let [_ ⊢ refpl] = equiv_tr_have_same_label e in [_ ⊢ ind_tr I]
;