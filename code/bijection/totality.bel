% Proof of totality of forget and enrich

% Auxiliary existential types for the totality statements

% Existential type denoting existence of a transition F2 such that fc_forget(F1)=F2.
LF ex_fc_forget: ccskp.fstep_closed X T X' → type =
  | ex_fcfg: fc_forget F1 F2 → ex_fc_forget F1
;
% Existential type denoting existence of a transition F2 such that fo_forget(F1)=F2.
LF ex_fo_forget: ccskp.fstep_open X T X' → type =
  | ex_fofg: fo_forget F1 F2 → ex_fo_forget F1
;

% Existential type denoting existence of a transition B2 such that bc_forget(B1)=B2.
LF ex_bc_forget: ccskp.bstep_closed X' T X → type =
  | ex_bcfg: bc_forget B1 B2 → ex_bc_forget B1
;
% Existential type denoting existence of a transition B2 such that bo_forget(B1)=B2.
LF ex_bo_forget: ccskp.bstep_open X' T X → type =
  | ex_bofg: bo_forget B1 B2 → ex_bo_forget B1
;

% Existential type denoting existence of a transition F2 such that fc_enrich(F1)=F2 or fo_enrich(F1)=F2.
LF ex_f_enrich: ccsk.fstep X T X' → type =
  | ex_fcen: fc_enrich F1 F2 → ex_f_enrich F1
  | ex_foen: fo_enrich F1 F2 → ex_f_enrich F1
;
% Existential type denoting existence of a transition B2 such that bc_enrich(B1)=B2 or bo_enrich(B1)=B2.
LF ex_b_enrich: ccsk.bstep X' T X → type =
  | ex_bcen: bc_enrich B1 B2 → ex_b_enrich B1
  | ex_boen: bo_enrich B1 B2 → ex_b_enrich B1
;


% Existential type denoting existence of a transition S2 such that forget(S1)=S2.
LF ex_forget: ccskp.step X T X' → type =
  | ex_fg: forget S1 S2 → ex_forget S1
;
% Existential type denoting existence of a transition S2 such that enrich(S1)=S2.
LF ex_enrich: ccsk.step X T X' → type =
  | ex_en: enrich S1 S2 → ex_enrich S1
;


% Totality of fc_forget:
% Given a CCSKP closed forward transition F1, there is at least one CCSK forward transition F2 such that fc_forget(F1)=F2.
rec total_fc_forget: (g:ctx) {F:[g ⊢ ccskp.fstep_closed X T X']} [g ⊢ ex_fc_forget F] =
/ total f (total_fc_forget _ _ _ _ f) /
mlam F ⇒ case [_ ⊢ F] of
  | [g ⊢ ccskp.fc_pref D] ⇒ [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccskp.fc_kpref F1 H I] ⇒
    let [g ⊢ ex_fcfg (fc_fg F1 F1' L H')] = total_fc_forget [g ⊢ F1] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_kpref F1' I) L H')]
  | [g ⊢ ccskp.fc_suml F1 D] ⇒
    let [g ⊢ ex_fcfg (fc_fg F1 F1' L H)] = total_fc_forget [g ⊢ F1] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_suml F1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
  | [g ⊢ ccskp.fc_sumr F1 D] ⇒
    let [g ⊢ ex_fcfg (fc_fg F1 F1' L H)] = total_fc_forget [g ⊢ F1] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_sumr F1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
  | [g ⊢ ccskp.fc_parl F1 H N] ⇒
    let [g ⊢ ex_fcfg (fc_fg F1 F1' L H')] = total_fc_forget [g ⊢ F1] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_parl F1' N) (ccskp.lab_parl L) (ccskp.key_parl H'))]
  | [g ⊢ ccskp.fc_parr F1 H N] ⇒
    let [g ⊢ ex_fcfg (fc_fg F1 F1' L H')] = total_fc_forget [g ⊢ F1] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_parr F1' N) (ccskp.lab_parr L) (ccskp.key_parr H'))]
  | [g ⊢ ccskp.fc_synl F1 L1 H1 F2 L2 H2] ⇒ 
    let [g ⊢ ex_fcfg (fc_fg F1 F1' L1' H1')] = total_fc_forget [g ⊢ F1] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_fcfg (fc_fg F2 F2' L2' H2')] = total_fc_forget [g ⊢ F2] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_synl F1' F2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.fc_synr F1 L1 H1 F2 L2 H2] ⇒ 
    let [g ⊢ ex_fcfg (fc_fg F1 F1' L1' H1')] = total_fc_forget [g ⊢ F1] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_fcfg (fc_fg F2 F2' L2' H2')] = total_fc_forget [g ⊢ F2] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_synr F1' F2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.fc_nu \a.F1] ⇒
    let [g,a:names ⊢ ex_fcfg (fc_fg F1 F1'[..,a] L[..,a] H[..,a])] = total_fc_forget [g,a:names ⊢ F1] in
    let ex_sll [g,a:names ⊢ L] [g ⊢ L'] e = str_labl [g,a:names ⊢ L] in
    let [g,a:names ⊢ refl] = e in
    let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
    [g ⊢ ex_fcfg (fc_fg F (ccsk.fs_nu \a.F1') L' H')]
;

% Totality of fo_forget:
% Given a CCSKP open forward transition F1, there is at least one CCSK forward transition F2 such that fo_forget(F1)=F2.
rec total_fo_forget: (g:ctx) {F:[g ⊢ ccskp.fstep_open X T X']} [g ⊢ ex_fo_forget F] =
/ total f (total_fo_forget _ _ _ _ f) /
mlam F ⇒ case [_ ⊢ F] of
  | [g ⊢ ccskp.fo_nu_closed (\a.O) (\a.L) (\a.F1)] ⇒
    let [g,a:names ⊢ L'] = lab_of_fstep_open [g ⊢ F] in
    let [g,a:names ⊢ refl] = uniqueness_of_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
    let [g,a:names ⊢ ex_fcfg (fc_fg F1 F1' L'' H)] = total_fc_forget [g,a:names ⊢ F1] in
    let [g,a:names ⊢ refl] = uniqueness_of_lab [g,a:names ⊢ L] [g,a:names ⊢ L''] in
    [g ⊢ ex_fofg (fo_fg F (ccsk.fs_nu (\a.F1')) \a.H)]
  | [g ⊢ ccskp.fo_kpref F1 (\a.H) I] ⇒
    let [g ⊢ ex_fofg (fo_fg F1 F1' \a.H')] = total_fo_forget [g ⊢ F1] in
    let [g,a:names ⊢ refk] = uniqueness_of_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fofg (fo_fg F (ccsk.fs_kpref F1' I) \a.H')]
  | [g ⊢ ccskp.fo_suml F1 D] ⇒
    let [g ⊢ ex_fofg (fo_fg F1 F1' \a.H)] = total_fo_forget [g ⊢ F1] in
    [g ⊢ ex_fofg (fo_fg F (ccsk.fs_suml F1' D) (\a. ccskp.key_suml H))]
  | [g ⊢ ccskp.fo_sumr F1 D] ⇒
    let [g ⊢ ex_fofg (fo_fg F1 F1' \a.H)] = total_fo_forget [g ⊢ F1] in
    [g ⊢ ex_fofg (fo_fg F (ccsk.fs_sumr F1' D) (\a.ccskp.key_sumr H))]
  | [g ⊢ ccskp.fo_parl F1 (\a.H) N] ⇒
    let [g ⊢ ex_fofg (fo_fg F1 F1' \a.H')] = total_fo_forget [g ⊢ F1] in
    let [g,a:names ⊢ refk] = uniqueness_of_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fofg (fo_fg F (ccsk.fs_parl F1' N) (\a.ccskp.key_parl H'))]
  | [g ⊢ ccskp.fo_parr F1 (\a.H) N] ⇒
    let [g ⊢ ex_fofg (fo_fg F1 F1' \a.H')] = total_fo_forget [g ⊢ F1] in
    let [g,a:names ⊢ refk] = uniqueness_of_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fofg (fo_fg F (ccsk.fs_parr F1' N) (\a.ccskp.key_parr H'))]
  | [g ⊢ ccskp.fo_nu_open \a.F1] ⇒
    let [g,a:names ⊢ ex_fofg (fo_fg F1 F1'[..,a] \b.H[..,b,a])] = total_fo_forget [g,a:names ⊢ F1] in
    [g ⊢ ex_fofg (fo_fg F (ccsk.fs_nu \a.F1') \a.H[..,a])]
;


% Totality of bc_forget:
% Given a CCSKP closed backward transition B1, there is at least one CCSK backward transition B2 such that bc_forget(B1)=B2.
rec total_bc_forget: (g:ctx) {B:[g ⊢ ccskp.bstep_closed X' T X]} [g ⊢ ex_bc_forget B] =
/ total b (total_bc_forget _ _ _ _ b) /
mlam B ⇒ case [_ ⊢ B] of
  | [g ⊢ ccskp.bc_pref D] ⇒ [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccskp.bc_kpref B1 H I] ⇒
    let [g ⊢ ex_bcfg (bc_fg B1 B1' L H')] = total_bc_forget [g ⊢ B1] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_kpref B1' I) L H')]
  | [g ⊢ ccskp.bc_suml B1 D] ⇒
    let [g ⊢ ex_bcfg (bc_fg B1 B1' L H)] = total_bc_forget [g ⊢ B1] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_suml B1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
  | [g ⊢ ccskp.bc_sumr B1 D] ⇒
    let [g ⊢ ex_bcfg (bc_fg B1 B1' L H)] = total_bc_forget [g ⊢ B1] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_sumr B1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
  | [g ⊢ ccskp.bc_parl B1 H N] ⇒
    let [g ⊢ ex_bcfg (bc_fg B1 B1' L H')] = total_bc_forget [g ⊢ B1] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_parl B1' N) (ccskp.lab_parl L) (ccskp.key_parl H'))]
  | [g ⊢ ccskp.bc_parr B1 H N] ⇒
    let [g ⊢ ex_bcfg (bc_fg B1 B1' L H')] = total_bc_forget [g ⊢ B1] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_parr B1' N) (ccskp.lab_parr L) (ccskp.key_parr H'))]
  | [g ⊢ ccskp.bc_synl B1 L1 H1 B2 L2 H2] ⇒ 
    let [g ⊢ ex_bcfg (bc_fg B1 B1' L1' H1')] = total_bc_forget [g ⊢ B1] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_bcfg (bc_fg B2 B2' L2' H2')] = total_bc_forget [g ⊢ B2] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_synl B1' B2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.bc_synr B1 L1 H1 B2 L2 H2] ⇒ 
    let [g ⊢ ex_bcfg (bc_fg B1 B1' L1' H1')] = total_bc_forget [g ⊢ B1] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_bcfg (bc_fg B2 B2' L2' H2')] = total_bc_forget [g ⊢ B2] in
    let [g ⊢ refl] = uniqueness_of_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = uniqueness_of_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_synr B1' B2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.bc_nu \a.B1] ⇒
    let [g,a:names ⊢ ex_bcfg (bc_fg B1 B1'[..,a] L[..,a] H[..,a])] = total_bc_forget [g,a:names ⊢ B1] in
    let ex_sll [g,a:names ⊢ L] [g ⊢ L'] e = str_labl [g,a:names ⊢ L] in
    let [g,a:names ⊢ refl] = e in
    let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
    [g ⊢ ex_bcfg (bc_fg B (ccsk.bs_nu \a.B1') L' H')]
;

% Totality of bo_forget:
% Given a CCSKP open backward transition B1, there is at least one CCSK backward transition B2 such that bo_forget(B1)=B2.
rec total_bo_forget: (g:ctx) {B:[g ⊢ ccskp.bstep_open X' T X]} [g ⊢ ex_bo_forget B] =
/ total b (total_bo_forget _ _ _ _ b) /
mlam B ⇒ case [_ ⊢ B] of
  | [g ⊢ ccskp.bo_nu_closed (\a.O) (\a.L) (\a.B1)] ⇒
    let [g,a:names ⊢ L'] = lab_of_bstep_open [g ⊢ B] in
    let [g,a:names ⊢ refl] = uniqueness_of_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
    let [g,a:names ⊢ ex_bcfg (bc_fg B1 B1' L'' H)] = total_bc_forget [g,a:names ⊢ B1] in
    let [g,a:names ⊢ refl] = uniqueness_of_lab [g,a:names ⊢ L] [g,a:names ⊢ L''] in
    [g ⊢ ex_bofg (bo_fg B (ccsk.bs_nu (\a.B1')) \a.H)]
  | [g ⊢ ccskp.bo_kpref B1 (\a.H) I] ⇒
    let [g ⊢ ex_bofg (bo_fg B1 B1' \a.H')] = total_bo_forget [g ⊢ B1] in
    let [g,a:names ⊢ refk] = uniqueness_of_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_bofg (bo_fg B (ccsk.bs_kpref B1' I) \a.H')]
  | [g ⊢ ccskp.bo_suml B1 D] ⇒
    let [g ⊢ ex_bofg (bo_fg B1 B1' \a.H)] = total_bo_forget [g ⊢ B1] in
    [g ⊢ ex_bofg (bo_fg B (ccsk.bs_suml B1' D) (\a. ccskp.key_suml H))]
  | [g ⊢ ccskp.bo_sumr B1 D] ⇒
    let [g ⊢ ex_bofg (bo_fg B1 B1' \a.H)] = total_bo_forget [g ⊢ B1] in
    [g ⊢ ex_bofg (bo_fg B (ccsk.bs_sumr B1' D) (\a.ccskp.key_sumr H))]
  | [g ⊢ ccskp.bo_parl B1 (\a.H) N] ⇒
    let [g ⊢ ex_bofg (bo_fg B1 B1' \a.H')] = total_bo_forget [g ⊢ B1] in
    let [g,a:names ⊢ refk] = uniqueness_of_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_bofg (bo_fg B (ccsk.bs_parl B1' N) (\a.ccskp.key_parl H'))]
  | [g ⊢ ccskp.bo_parr B1 (\a.H) N] ⇒
    let [g ⊢ ex_bofg (bo_fg B1 B1' \a.H')] = total_bo_forget [g ⊢ B1] in
    let [g,a:names ⊢ refk] = uniqueness_of_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_bofg (bo_fg B (ccsk.bs_parr B1' N) (\a.ccskp.key_parr H'))]
  | [g ⊢ ccskp.bo_nu_open \a.B1] ⇒
    let [g,a:names ⊢ ex_bofg (bo_fg B1 B1'[..,a] \b.H[..,b,a])] = total_bo_forget [g,a:names ⊢ B1] in
    [g ⊢ ex_bofg (bo_fg B (ccsk.bs_nu \a.B1') \a.H[..,a])]
;


% Totality of forget:
% Given a CCSKP combined transition S1, there is at least one CCSK combined transition S2 such that forget(S1)=S2.
rec total_forget: (g:ctx) {S:[g ⊢ ccskp.step X T X']} [g ⊢ ex_forget S] =
/ total s (total_forget s _ _ _ _) /
mlam S ⇒ case [_ ⊢ S] of
  | [g ⊢ ccskp.sc (ccskp.fwc F)] ⇒ let [g ⊢ ex_fcfg D] = total_fc_forget [g ⊢ F] in [g ⊢ ex_fg (fcfg D)]
  | [g ⊢ ccskp.so (ccskp.fwo F)] ⇒ let [g ⊢ ex_fofg D] = total_fo_forget [g ⊢ F] in [g ⊢ ex_fg (fofg D)]
  | [g ⊢ ccskp.sc (ccskp.bwc B)] ⇒ let [g ⊢ ex_bcfg D] = total_bc_forget [g ⊢ B] in [g ⊢ ex_fg (bcfg D)]
  | [g ⊢ ccskp.so (ccskp.bwo B)] ⇒ let [g ⊢ ex_bofg D] = total_bo_forget [g ⊢ B] in [g ⊢ ex_fg (bofg D)]
;



% Totality of the union of fc_enrich and fo_enrich:
% Given a CCSK forward transition F1, there is at least one CCSKP forward transition F2 such that fc_enrich(F1)=F2 or fo_enrich(F1)=F2.
rec total_f_enrich: (g:ctx) {F:[g ⊢ ccsk.fstep X T X']} [g ⊢ ex_f_enrich F] =
/ total f (total_f_enrich f _ _ _ _) /
mlam F ⇒ case [_ ⊢ F] of
  | [g ⊢ ccsk.fs_pref D] ⇒ [g ⊢ ex_fcen (fc_en F (ccskp.fc_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccsk.fs_kpref F1 I] ⇒
    (case total_f_enrich [g ⊢ F1] of
       | [g ⊢ ex_fcen (fc_en F1 F1' L H)] ⇒ [g ⊢ ex_fcen (fc_en F (ccskp.fc_kpref F1' H I) L H)]
       | [g ⊢ ex_foen (fo_en F1 F1' \a.H)] ⇒ [g ⊢ ex_foen (fo_en F (ccskp.fo_kpref F1' (\a.H) I) \a.H)])
  | [g ⊢ ccsk.fs_suml F1 D] ⇒
    (case total_f_enrich [g ⊢ F1] of
       | [g ⊢ ex_fcen (fc_en F1 F1' L H)] ⇒ [g ⊢ ex_fcen (fc_en F (ccskp.fc_suml F1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
       | [g ⊢ ex_foen (fo_en F1 F1' \a.H)] ⇒ [g ⊢ ex_foen (fo_en F (ccskp.fo_suml F1' D) \a.(ccskp.key_suml H))])
  | [g ⊢ ccsk.fs_sumr F1 D] ⇒
    (case total_f_enrich [g ⊢ F1] of
       | [g ⊢ ex_fcen (fc_en F1 F1' L H)] ⇒ [g ⊢ ex_fcen (fc_en F (ccskp.fc_sumr F1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
       | [g ⊢ ex_foen (fo_en F1 F1' \a.H)] ⇒ [g ⊢ ex_foen (fo_en F (ccskp.fo_sumr F1' D) \a.(ccskp.key_sumr H))])
  | [g ⊢ ccsk.fs_parl F1 N] ⇒
    (case total_f_enrich [g ⊢ F1] of
       | [g ⊢ ex_fcen (fc_en F1 F1' L H)] ⇒ [g ⊢ ex_fcen (fc_en F (ccskp.fc_parl F1' H N) (ccskp.lab_parl L) (ccskp.key_parl H))]
       | [g ⊢ ex_foen (fo_en F1 F1' \a.H)] ⇒ [g ⊢ ex_foen (fo_en F (ccskp.fo_parl F1' (\a.H) N) \a.(ccskp.key_parl H))])
  | [g ⊢ ccsk.fs_parr F1 N] ⇒
    (case total_f_enrich [g ⊢ F1] of
       | [g ⊢ ex_fcen (fc_en F1 F1' L H)] ⇒ [g ⊢ ex_fcen (fc_en F (ccskp.fc_parr F1' H N) (ccskp.lab_parr L) (ccskp.key_parr H))]
       | [g ⊢ ex_foen (fo_en F1 F1' \a.H)] ⇒ [g ⊢ ex_foen (fo_en F (ccskp.fo_parr F1' (\a.H) N) \a.(ccskp.key_parr H))])
  | [g ⊢ ccsk.fs_synl F1 F2] ⇒
    let [g ⊢ ex_fcen (fc_en F1 F1' L1 H1)] = total_f_enrich [g ⊢ F1] in
    let [g ⊢ ex_fcen (fc_en F2 F2' L2 H2)] = total_f_enrich [g ⊢ F2] in
    [g ⊢ ex_fcen (fc_en F (ccskp.fc_synl F1' L1 H1 F2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.fs_synr F1 F2] ⇒
    let [g ⊢ ex_fcen (fc_en F1 F1' L1 H1)] = total_f_enrich [g ⊢ F1] in
    let [g ⊢ ex_fcen (fc_en F2 F2' L2 H2)] = total_f_enrich [g ⊢ F2] in
    [g ⊢ ex_fcen (fc_en F (ccskp.fc_synr F1' L1 H1 F2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.fs_nu \a.F1] ⇒
    (case total_f_enrich [g,a:names ⊢ F1] of
       | [g,a:names ⊢ ex_fcen (fc_en F1 F1' L H)] ⇒
         let [g,a:names ⊢ V] = valid_pr_lab_in_fstep_closed [g,a:names ⊢ F1'] in
         (case occur_in_valid_pr_lab [g,a:names ⊢ V] of
            | oc [g,a:names ⊢ T] [g,a:names ⊢ O] ⇒
              let [g,a:names ⊢ L'] = occur_in_pr_lab [g,a:names ⊢ O] [g,a:names ⊢ L] in
              let [g,a:names ⊢ reflb] = unique_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
              [g ⊢ ex_foen (fo_en F (ccskp.fo_nu_closed (\a.O) (\a.L) (\a.F1')) (\a.H))]
            | noc [g,a:names ⊢ T] [g,a:names ⊢ E] ⇒
              let [g,a:names ⊢ refpl] = [g,a:names ⊢ E] in
              let [g ⊢ L'] = str_labr [g,a:names ⊢ L] in
              let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
              [g ⊢ ex_fcen (fc_en F (ccskp.fc_nu \a.F1') L' H')])
       | [g,a:names ⊢ ex_foen (fo_en F1 F1' \b.H[..,b,a])] ⇒
         let ex_sfo [g,b:names ⊢ F1'] [g,b:names ⊢ F1''] e = str_fstep_open [g,b:names ⊢ F1'] in
         let [g,a:names,b:names ⊢ refpl] = e in
         [g ⊢ ex_foen (fo_en F (ccskp.fo_nu_open \a.F1'') \a.H[..,a])])
;


% Totality of the union of bc_enrich and bo_enrich:
% Given a CCSK backward transition B1, there is at least one CCSKP backward transition B2 such that bc_enrich(B1)=B2 or bo_enrich(B1)=B2.
rec total_b_enrich: (g:ctx) {B:[g ⊢ ccsk.bstep X' T X]} [g ⊢ ex_b_enrich B] =
/ total b (total_b_enrich b _ _ _ _) /
mlam B ⇒ case [_ ⊢ B] of
  | [g ⊢ ccsk.bs_pref D] ⇒ [g ⊢ ex_bcen (bc_en B (ccskp.bc_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccsk.bs_kpref B1 I] ⇒
    (case total_b_enrich [g ⊢ B1] of
       | [g ⊢ ex_bcen (bc_en B1 B1' L H)] ⇒ [g ⊢ ex_bcen (bc_en B (ccskp.bc_kpref B1' H I) L H)]
       | [g ⊢ ex_boen (bo_en B1 B1' \a.H)] ⇒ [g ⊢ ex_boen (bo_en B (ccskp.bo_kpref B1' (\a.H) I) \a.H)])
  | [g ⊢ ccsk.bs_suml B1 D] ⇒
    (case total_b_enrich [g ⊢ B1] of
       | [g ⊢ ex_bcen (bc_en B1 B1' L H)] ⇒ [g ⊢ ex_bcen (bc_en B (ccskp.bc_suml B1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
       | [g ⊢ ex_boen (bo_en B1 B1' \a.H)] ⇒ [g ⊢ ex_boen (bo_en B (ccskp.bo_suml B1' D) \a.(ccskp.key_suml H))])
  | [g ⊢ ccsk.bs_sumr B1 D] ⇒
    (case total_b_enrich [g ⊢ B1] of
       | [g ⊢ ex_bcen (bc_en B1 B1' L H)] ⇒ [g ⊢ ex_bcen (bc_en B (ccskp.bc_sumr B1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
       | [g ⊢ ex_boen (bo_en B1 B1' \a.H)] ⇒ [g ⊢ ex_boen (bo_en B (ccskp.bo_sumr B1' D) \a.(ccskp.key_sumr H))])
  | [g ⊢ ccsk.bs_parl B1 N] ⇒
    (case total_b_enrich [g ⊢ B1] of
       | [g ⊢ ex_bcen (bc_en B1 B1' L H)] ⇒ [g ⊢ ex_bcen (bc_en B (ccskp.bc_parl B1' H N) (ccskp.lab_parl L) (ccskp.key_parl H))]
       | [g ⊢ ex_boen (bo_en B1 B1' \a.H)] ⇒ [g ⊢ ex_boen (bo_en B (ccskp.bo_parl B1' (\a.H) N) \a.(ccskp.key_parl H))])
  | [g ⊢ ccsk.bs_parr B1 N] ⇒
    (case total_b_enrich [g ⊢ B1] of
       | [g ⊢ ex_bcen (bc_en B1 B1' L H)] ⇒ [g ⊢ ex_bcen (bc_en B (ccskp.bc_parr B1' H N) (ccskp.lab_parr L) (ccskp.key_parr H))]
       | [g ⊢ ex_boen (bo_en B1 B1' \a.H)] ⇒ [g ⊢ ex_boen (bo_en B (ccskp.bo_parr B1' (\a.H) N) \a.(ccskp.key_parr H))])
  | [g ⊢ ccsk.bs_synl B1 B2] ⇒
    let [g ⊢ ex_bcen (bc_en B1 B1' L1 H1)] = total_b_enrich [g ⊢ B1] in
    let [g ⊢ ex_bcen (bc_en B2 B2' L2 H2)] = total_b_enrich [g ⊢ B2] in
    [g ⊢ ex_bcen (bc_en B (ccskp.bc_synl B1' L1 H1 B2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.bs_synr B1 B2] ⇒
    let [g ⊢ ex_bcen (bc_en B1 B1' L1 H1)] = total_b_enrich [g ⊢ B1] in
    let [g ⊢ ex_bcen (bc_en B2 B2' L2 H2)] = total_b_enrich [g ⊢ B2] in
    [g ⊢ ex_bcen (bc_en B (ccskp.bc_synr B1' L1 H1 B2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.bs_nu \a.B1] ⇒
    (case total_b_enrich [g,a:names ⊢ B1] of
       | [g,a:names ⊢ ex_bcen (bc_en B1 B1' L H)] ⇒
         let [g,a:names ⊢ V] = valid_pr_lab_in_bstep_closed [g,a:names ⊢ B1'] in
         (case occur_in_valid_pr_lab [g,a:names ⊢ V] of
            | oc [g,a:names ⊢ T] [g,a:names ⊢ O] ⇒
              let [g,a:names ⊢ L'] = occur_in_pr_lab [g,a:names ⊢ O] [g,a:names ⊢ L] in
              let [g,a:names ⊢ reflb] = unique_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
              [g ⊢ ex_boen (bo_en B (ccskp.bo_nu_closed (\a.O) (\a.L) (\a.B1')) (\a.H))]
            | noc [g,a:names ⊢ T] [g,a:names ⊢ E] ⇒
              let [g,a:names ⊢ refpl] = [g,a:names ⊢ E] in
              let [g ⊢ L'] = str_labr [g,a:names ⊢ L] in
              let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
              [g ⊢ ex_bcen (bc_en B (ccskp.bc_nu \a.B1') L' H')])
       | [g,a:names ⊢ ex_boen (bo_en B1 B1' \b.H[..,b,a])] ⇒
         let ex_sbo [g,b:names ⊢ B1'] [g,b:names ⊢ B1''] e = str_bstep_open [g,b:names ⊢ B1'] in
         let [g,a:names,b:names ⊢ refpl] = e in
         [g ⊢ ex_boen (bo_en B (ccskp.bo_nu_open \a.B1'') \a.H[..,a])])
;


% Totality of enrich:
% Given a CCSK combined transition S1, there is at least one CCSKP combined transition S2 such that enrich(S1)=S2.
rec total_enrich: (g:ctx) {S:[g ⊢ ccsk.step X T X']} [g ⊢ ex_enrich S] =
/ total s (total_enrich s _ _ _ _) /
mlam S ⇒ case [_ ⊢ S] of
  | [g ⊢ ccsk.fw F] ⇒ (case total_f_enrich [g ⊢ F] of
       | [g ⊢ ex_fcen D] ⇒ [g ⊢ ex_en (fcen D)]
       | [g ⊢ ex_foen D] ⇒ [g ⊢ ex_en (foen D)])
  | [g ⊢ ccsk.bw B] ⇒ (case total_b_enrich [g ⊢ B] of
       | [g ⊢ ex_bcen D] ⇒ [g ⊢ ex_en (bcen D)]
       | [g ⊢ ex_boen D] ⇒ [g ⊢ ex_en (boen D)])
;