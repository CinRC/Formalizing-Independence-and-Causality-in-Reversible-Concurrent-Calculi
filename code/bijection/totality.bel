%%% Totality of forget and enrich %%%

% Auxiliary existential types for the totality statements

% Existential type denoting existence of a transition F2 such that forget_fc(F1)=F2.
LF ex_forget_fc: ccskp.fstep_cl X T X' → type =
  | ex_fgfc: forget_fc F1 F2 → ex_forget_fc F1
;
% Existential type denoting existence of a transition F2 such that forget_fo(F1)=F2.
LF ex_forget_fo: ccskp.fstep_op X T X' → type =
  | ex_fgfo: forget_fo F1 F2 → ex_forget_fo F1
;

% Existential type denoting existence of a transition B2 such that forget_bc(B1)=B2.
LF ex_forget_bc: ccskp.bstep_cl X' T X → type =
  | ex_fgbc: forget_bc B1 B2 → ex_forget_bc B1
;
% Existential type denoting existence of a transition B2 such that forget_bo(B1)=B2.
LF ex_forget_bo: ccskp.bstep_op X' T X → type =
  | ex_fgbo: forget_bo B1 B2 → ex_forget_bo B1
;

% Existential type denoting existence of a transition F2 such that enrich_fc(F1)=F2 or enrich_fo(F1)=F2.
LF ex_f_enrich: ccsk.fstep X T X' → type =
  | ex_enfc: enrich_fc F1 F2 → ex_f_enrich F1
  | ex_enfo: enrich_fo F1 F2 → ex_f_enrich F1
;
% Existential type denoting existence of a transition B2 such that enrich_bc(B1)=B2 or enrich_bo(B1)=B2.
LF ex_b_enrich: ccsk.bstep X' T X → type =
  | ex_enbc: enrich_bc B1 B2 → ex_b_enrich B1
  | ex_enbo: enrich_bo B1 B2 → ex_b_enrich B1
;


% Existential type denoting existence of a transition S2 such that forget(S1)=S2.
LF ex_forget: ccskp.step X T X' → type =
  | ex_fg: forget S1 S2 → ex_forget S1
;
% Existential type denoting existence of a transition S2 such that enrich(S1)=S2.
LF ex_enrich: ccsk.step X T X' → type =
  | ex_en: enrich S1 S2 → ex_enrich S1
;


% Totality of forget_fc:
% Given a CCSKP closed forward transition F1, there is at least one CCSK forward transition F2 such that forget_fc(F1)=F2.
rec total_forget_fc: (g:ctx) {F:[g ⊢ ccskp.fstep_cl X T X']} [g ⊢ ex_forget_fc F] =
/ total f (total_forget_fc _ _ _ _ f) /
mlam F ⇒ case [_ ⊢ F] of
  | [g ⊢ ccskp.fc_pref D] ⇒ [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccskp.fc_kpref F1 H I] ⇒
    let [g ⊢ ex_fgfc (fg_fc F1 F1' L H')] = total_forget_fc [g ⊢ F1] in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_kpref F1' I) L H')]
  | [g ⊢ ccskp.fc_suml F1 D] ⇒
    let [g ⊢ ex_fgfc (fg_fc F1 F1' L H)] = total_forget_fc [g ⊢ F1] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_suml F1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
  | [g ⊢ ccskp.fc_sumr F1 D] ⇒
    let [g ⊢ ex_fgfc (fg_fc F1 F1' L H)] = total_forget_fc [g ⊢ F1] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_sumr F1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
  | [g ⊢ ccskp.fc_parl F1 H N] ⇒
    let [g ⊢ ex_fgfc (fg_fc F1 F1' L H')] = total_forget_fc [g ⊢ F1] in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_parl F1' N) (ccskp.lab_parl L) (ccskp.key_parl H'))]
  | [g ⊢ ccskp.fc_parr F1 H N] ⇒
    let [g ⊢ ex_fgfc (fg_fc F1 F1' L H')] = total_forget_fc [g ⊢ F1] in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_parr F1' N) (ccskp.lab_parr L) (ccskp.key_parr H'))]
  | [g ⊢ ccskp.fc_synl F1 L1 H1 F2 L2 H2] ⇒ 
    let [g ⊢ ex_fgfc (fg_fc F1 F1' L1' H1')] = total_forget_fc [g ⊢ F1] in
    let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_fgfc (fg_fc F2 F2' L2' H2')] = total_forget_fc [g ⊢ F2] in
    let [g ⊢ refl] = functional_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_synl F1' F2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.fc_synr F1 L1 H1 F2 L2 H2] ⇒ 
    let [g ⊢ ex_fgfc (fg_fc F1 F1' L1' H1')] = total_forget_fc [g ⊢ F1] in
    let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_fgfc (fg_fc F2 F2' L2' H2')] = total_forget_fc [g ⊢ F2] in
    let [g ⊢ refl] = functional_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_synr F1' F2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.fc_nu \a.F1] ⇒
    let [g,a:names ⊢ ex_fgfc (fg_fc F1 F1'[..,a] L[..,a] H[..,a])] = total_forget_fc [g,a:names ⊢ F1] in
    let ex_sll [g,a:names ⊢ L] [g ⊢ L'] e = str_labl [g,a:names ⊢ L] in
    let [g,a:names ⊢ refl] = e in
    let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
    [g ⊢ ex_fgfc (fg_fc F (ccsk.fs_nu \a.F1') L' H')]
;

% Totality of forget_fo:
% Given a CCSKP open forward transition F1, there is at least one CCSK forward transition F2 such that forget_fo(F1)=F2.
rec total_forget_fo: (g:ctx) {F:[g ⊢ ccskp.fstep_op X T X']} [g ⊢ ex_forget_fo F] =
/ total f (total_forget_fo _ _ _ _ f) /
mlam F ⇒ case [_ ⊢ F] of
  | [g ⊢ ccskp.fo_nu_cl (\a.O) (\a.L) (\a.F1)] ⇒
    let [g,a:names ⊢ L'] = fstep_op_impl_tau [g ⊢ F] in
    let [g,a:names ⊢ refl] = functional_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
    let [g,a:names ⊢ ex_fgfc (fg_fc F1 F1' L'' H)] = total_forget_fc [g,a:names ⊢ F1] in
    let [g,a:names ⊢ refl] = functional_lab [g,a:names ⊢ L] [g,a:names ⊢ L''] in
    [g ⊢ ex_fgfo (fg_fo F (ccsk.fs_nu (\a.F1')) \a.H)]
  | [g ⊢ ccskp.fo_kpref F1 (\a.H) I] ⇒
    let [g ⊢ ex_fgfo (fg_fo F1 F1' \a.H')] = total_forget_fo [g ⊢ F1] in
    let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fgfo (fg_fo F (ccsk.fs_kpref F1' I) \a.H')]
  | [g ⊢ ccskp.fo_suml F1 D] ⇒
    let [g ⊢ ex_fgfo (fg_fo F1 F1' \a.H)] = total_forget_fo [g ⊢ F1] in
    [g ⊢ ex_fgfo (fg_fo F (ccsk.fs_suml F1' D) (\a. ccskp.key_suml H))]
  | [g ⊢ ccskp.fo_sumr F1 D] ⇒
    let [g ⊢ ex_fgfo (fg_fo F1 F1' \a.H)] = total_forget_fo [g ⊢ F1] in
    [g ⊢ ex_fgfo (fg_fo F (ccsk.fs_sumr F1' D) (\a.ccskp.key_sumr H))]
  | [g ⊢ ccskp.fo_parl F1 (\a.H) N] ⇒
    let [g ⊢ ex_fgfo (fg_fo F1 F1' \a.H')] = total_forget_fo [g ⊢ F1] in
    let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fgfo (fg_fo F (ccsk.fs_parl F1' N) (\a.ccskp.key_parl H'))]
  | [g ⊢ ccskp.fo_parr F1 (\a.H) N] ⇒
    let [g ⊢ ex_fgfo (fg_fo F1 F1' \a.H')] = total_forget_fo [g ⊢ F1] in
    let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fgfo (fg_fo F (ccsk.fs_parr F1' N) (\a.ccskp.key_parr H'))]
  | [g ⊢ ccskp.fo_nu_op \a.F1] ⇒
    let [g,a:names ⊢ ex_fgfo (fg_fo F1 F1'[..,a] \b.H[..,b,a])] = total_forget_fo [g,a:names ⊢ F1] in
    [g ⊢ ex_fgfo (fg_fo F (ccsk.fs_nu \a.F1') \a.H[..,a])]
;


% Totality of forget_bc:
% Given a CCSKP closed backward transition B1, there is at least one CCSK backward transition B2 such that forget_bc(B1)=B2.
rec total_forget_bc: (g:ctx) {B:[g ⊢ ccskp.bstep_cl X' T X]} [g ⊢ ex_forget_bc B] =
/ total b (total_forget_bc _ _ _ _ b) /
mlam B ⇒ case [_ ⊢ B] of
  | [g ⊢ ccskp.bc_pref D] ⇒ [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccskp.bc_kpref B1 H I] ⇒
    let [g ⊢ ex_fgbc (fg_bc B1 B1' L H')] = total_forget_bc [g ⊢ B1] in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_kpref B1' I) L H')]
  | [g ⊢ ccskp.bc_suml B1 D] ⇒
    let [g ⊢ ex_fgbc (fg_bc B1 B1' L H)] = total_forget_bc [g ⊢ B1] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_suml B1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
  | [g ⊢ ccskp.bc_sumr B1 D] ⇒
    let [g ⊢ ex_fgbc (fg_bc B1 B1' L H)] = total_forget_bc [g ⊢ B1] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_sumr B1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
  | [g ⊢ ccskp.bc_parl B1 H N] ⇒
    let [g ⊢ ex_fgbc (fg_bc B1 B1' L H')] = total_forget_bc [g ⊢ B1] in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_parl B1' N) (ccskp.lab_parl L) (ccskp.key_parl H'))]
  | [g ⊢ ccskp.bc_parr B1 H N] ⇒
    let [g ⊢ ex_fgbc (fg_bc B1 B1' L H')] = total_forget_bc [g ⊢ B1] in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H'] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_parr B1' N) (ccskp.lab_parr L) (ccskp.key_parr H'))]
  | [g ⊢ ccskp.bc_synl B1 L1 H1 B2 L2 H2] ⇒ 
    let [g ⊢ ex_fgbc (fg_bc B1 B1' L1' H1')] = total_forget_bc [g ⊢ B1] in
    let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_fgbc (fg_bc B2 B2' L2' H2')] = total_forget_bc [g ⊢ B2] in
    let [g ⊢ refl] = functional_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_synl B1' B2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.bc_synr B1 L1 H1 B2 L2 H2] ⇒ 
    let [g ⊢ ex_fgbc (fg_bc B1 B1' L1' H1')] = total_forget_bc [g ⊢ B1] in
    let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ ex_fgbc (fg_bc B2 B2' L2' H2')] = total_forget_bc [g ⊢ B2] in
    let [g ⊢ refl] = functional_lab [g ⊢ L2] [g ⊢ L2'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_synr B1' B2') (ccskp.lab_sync) (ccskp.key_sync H1'))]
  | [g ⊢ ccskp.bc_nu \a.B1] ⇒
    let [g,a:names ⊢ ex_fgbc (fg_bc B1 B1'[..,a] L[..,a] H[..,a])] = total_forget_bc [g,a:names ⊢ B1] in
    let ex_sll [g,a:names ⊢ L] [g ⊢ L'] e = str_labl [g,a:names ⊢ L] in
    let [g,a:names ⊢ refl] = e in
    let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
    [g ⊢ ex_fgbc (fg_bc B (ccsk.bs_nu \a.B1') L' H')]
;

% Totality of forget_bo:
% Given a CCSKP open backward transition B1, there is at least one CCSK backward transition B2 such that forget_bo(B1)=B2.
rec total_forget_bo: (g:ctx) {B:[g ⊢ ccskp.bstep_op X' T X]} [g ⊢ ex_forget_bo B] =
/ total b (total_forget_bo _ _ _ _ b) /
mlam B ⇒ case [_ ⊢ B] of
  | [g ⊢ ccskp.bo_nu_cl (\a.O) (\a.L) (\a.B1)] ⇒
    let [g,a:names ⊢ L'] = bstep_op_impl_tau [g ⊢ B] in
    let [g,a:names ⊢ refl] = functional_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
    let [g,a:names ⊢ ex_fgbc (fg_bc B1 B1' L'' H)] = total_forget_bc [g,a:names ⊢ B1] in
    let [g,a:names ⊢ refl] = functional_lab [g,a:names ⊢ L] [g,a:names ⊢ L''] in
    [g ⊢ ex_fgbo (fg_bo B (ccsk.bs_nu (\a.B1')) \a.H)]
  | [g ⊢ ccskp.bo_kpref B1 (\a.H) I] ⇒
    let [g ⊢ ex_fgbo (fg_bo B1 B1' \a.H')] = total_forget_bo [g ⊢ B1] in
    let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fgbo (fg_bo B (ccsk.bs_kpref B1' I) \a.H')]
  | [g ⊢ ccskp.bo_suml B1 D] ⇒
    let [g ⊢ ex_fgbo (fg_bo B1 B1' \a.H)] = total_forget_bo [g ⊢ B1] in
    [g ⊢ ex_fgbo (fg_bo B (ccsk.bs_suml B1' D) (\a. ccskp.key_suml H))]
  | [g ⊢ ccskp.bo_sumr B1 D] ⇒
    let [g ⊢ ex_fgbo (fg_bo B1 B1' \a.H)] = total_forget_bo [g ⊢ B1] in
    [g ⊢ ex_fgbo (fg_bo B (ccsk.bs_sumr B1' D) (\a.ccskp.key_sumr H))]
  | [g ⊢ ccskp.bo_parl B1 (\a.H) N] ⇒
    let [g ⊢ ex_fgbo (fg_bo B1 B1' \a.H')] = total_forget_bo [g ⊢ B1] in
    let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fgbo (fg_bo B (ccsk.bs_parl B1' N) (\a.ccskp.key_parl H'))]
  | [g ⊢ ccskp.bo_parr B1 (\a.H) N] ⇒
    let [g ⊢ ex_fgbo (fg_bo B1 B1' \a.H')] = total_forget_bo [g ⊢ B1] in
    let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H] [g,a:names ⊢ H'] in
    [g ⊢ ex_fgbo (fg_bo B (ccsk.bs_parr B1' N) (\a.ccskp.key_parr H'))]
  | [g ⊢ ccskp.bo_nu_op \a.B1] ⇒
    let [g,a:names ⊢ ex_fgbo (fg_bo B1 B1'[..,a] \b.H[..,b,a])] = total_forget_bo [g,a:names ⊢ B1] in
    [g ⊢ ex_fgbo (fg_bo B (ccsk.bs_nu \a.B1') \a.H[..,a])]
;


% Totality of forget:
% Given a CCSKP combined transition S1, there is at least one CCSK combined transition S2 such that forget(S1)=S2.
rec total_forget: (g:ctx) {S:[g ⊢ ccskp.step X T X']} [g ⊢ ex_forget S] =
/ total s (total_forget s _ _ _ _) /
mlam S ⇒ case [_ ⊢ S] of
  | [g ⊢ ccskp.sc (ccskp.fwc F)] ⇒ let [g ⊢ ex_fgfc D] = total_forget_fc [g ⊢ F] in [g ⊢ ex_fg (fgfc D)]
  | [g ⊢ ccskp.so (ccskp.fwo F)] ⇒ let [g ⊢ ex_fgfo D] = total_forget_fo [g ⊢ F] in [g ⊢ ex_fg (fgfo D)]
  | [g ⊢ ccskp.sc (ccskp.bwc B)] ⇒ let [g ⊢ ex_fgbc D] = total_forget_bc [g ⊢ B] in [g ⊢ ex_fg (fgbc D)]
  | [g ⊢ ccskp.so (ccskp.bwo B)] ⇒ let [g ⊢ ex_fgbo D] = total_forget_bo [g ⊢ B] in [g ⊢ ex_fg (fgbo D)]
;



% Totality of the union of enrich_fc and enrich_fo:
% Given a CCSK forward transition F1, there is at least one CCSKP forward transition F2 such that enrich_fc(F1)=F2 or enrich_fo(F1)=F2.
rec total_enrich_f: (g:ctx) {F:[g ⊢ ccsk.fstep X T X']} [g ⊢ ex_f_enrich F] =
/ total f (total_enrich_f f _ _ _ _) /
mlam F ⇒ case [_ ⊢ F] of
  | [g ⊢ ccsk.fs_pref D] ⇒ [g ⊢ ex_enfc (en_fc F (ccskp.fc_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccsk.fs_kpref F1 I] ⇒
    (case total_enrich_f [g ⊢ F1] of
       | [g ⊢ ex_enfc (en_fc F1 F1' L H)] ⇒ [g ⊢ ex_enfc (en_fc F (ccskp.fc_kpref F1' H I) L H)]
       | [g ⊢ ex_enfo (en_fo F1 F1' \a.H)] ⇒ [g ⊢ ex_enfo (en_fo F (ccskp.fo_kpref F1' (\a.H) I) \a.H)])
  | [g ⊢ ccsk.fs_suml F1 D] ⇒
    (case total_enrich_f [g ⊢ F1] of
       | [g ⊢ ex_enfc (en_fc F1 F1' L H)] ⇒ [g ⊢ ex_enfc (en_fc F (ccskp.fc_suml F1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
       | [g ⊢ ex_enfo (en_fo F1 F1' \a.H)] ⇒ [g ⊢ ex_enfo (en_fo F (ccskp.fo_suml F1' D) \a.(ccskp.key_suml H))])
  | [g ⊢ ccsk.fs_sumr F1 D] ⇒
    (case total_enrich_f [g ⊢ F1] of
       | [g ⊢ ex_enfc (en_fc F1 F1' L H)] ⇒ [g ⊢ ex_enfc (en_fc F (ccskp.fc_sumr F1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
       | [g ⊢ ex_enfo (en_fo F1 F1' \a.H)] ⇒ [g ⊢ ex_enfo (en_fo F (ccskp.fo_sumr F1' D) \a.(ccskp.key_sumr H))])
  | [g ⊢ ccsk.fs_parl F1 N] ⇒
    (case total_enrich_f [g ⊢ F1] of
       | [g ⊢ ex_enfc (en_fc F1 F1' L H)] ⇒ [g ⊢ ex_enfc (en_fc F (ccskp.fc_parl F1' H N) (ccskp.lab_parl L) (ccskp.key_parl H))]
       | [g ⊢ ex_enfo (en_fo F1 F1' \a.H)] ⇒ [g ⊢ ex_enfo (en_fo F (ccskp.fo_parl F1' (\a.H) N) \a.(ccskp.key_parl H))])
  | [g ⊢ ccsk.fs_parr F1 N] ⇒
    (case total_enrich_f [g ⊢ F1] of
       | [g ⊢ ex_enfc (en_fc F1 F1' L H)] ⇒ [g ⊢ ex_enfc (en_fc F (ccskp.fc_parr F1' H N) (ccskp.lab_parr L) (ccskp.key_parr H))]
       | [g ⊢ ex_enfo (en_fo F1 F1' \a.H)] ⇒ [g ⊢ ex_enfo (en_fo F (ccskp.fo_parr F1' (\a.H) N) \a.(ccskp.key_parr H))])
  | [g ⊢ ccsk.fs_synl F1 F2] ⇒
    let [g ⊢ ex_enfc (en_fc F1 F1' L1 H1)] = total_enrich_f [g ⊢ F1] in
    let [g ⊢ ex_enfc (en_fc F2 F2' L2 H2)] = total_enrich_f [g ⊢ F2] in
    [g ⊢ ex_enfc (en_fc F (ccskp.fc_synl F1' L1 H1 F2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.fs_synr F1 F2] ⇒
    let [g ⊢ ex_enfc (en_fc F1 F1' L1 H1)] = total_enrich_f [g ⊢ F1] in
    let [g ⊢ ex_enfc (en_fc F2 F2' L2 H2)] = total_enrich_f [g ⊢ F2] in
    [g ⊢ ex_enfc (en_fc F (ccskp.fc_synr F1' L1 H1 F2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.fs_nu \a.F1] ⇒
    (case total_enrich_f [g,a:names ⊢ F1] of
       | [g,a:names ⊢ ex_enfc (en_fc F1 F1' L H)] ⇒
         let [g,a:names ⊢ V] = valid_in_fstep_cl [g,a:names ⊢ F1'] in
         (case dec_occurs [g,a:names ⊢ V] of
            | occ [g,a:names ⊢ T] [g,a:names ⊢ O] ⇒
              let [g,a:names ⊢ L'] = occurs_impl_tau [g,a:names ⊢ O] [g,a:names ⊢ L] in
              let [g,a:names ⊢ reflb] = unique_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
              [g ⊢ ex_enfo (en_fo F (ccskp.fo_nu_cl (\a.O) (\a.L) (\a.F1')) (\a.H))]
            | noc [g,a:names ⊢ T] [g,a:names ⊢ E] ⇒
              let [g,a:names ⊢ refpl] = [g,a:names ⊢ E] in
              let [g ⊢ L'] = str_labr [g,a:names ⊢ L] in
              let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
              [g ⊢ ex_enfc (en_fc F (ccskp.fc_nu \a.F1') L' H')])
       | [g,a:names ⊢ ex_enfo (en_fo F1 F1' \b.H[..,b,a])] ⇒
         let ex_sfo [g,b:names ⊢ F1'] [g,b:names ⊢ F1''] e = str_fstep_op [g,b:names ⊢ F1'] in
         let [g,a:names,b:names ⊢ refpl] = e in
         [g ⊢ ex_enfo (en_fo F (ccskp.fo_nu_op \a.F1'') \a.H[..,a])])
;


% Totality of the union of enrich_bc and enrich_bo:
% Given a CCSK backward transition B1, there is at least one CCSKP backward transition B2 such that enrich_bc(B1)=B2 or enrich_bo(B1)=B2.
rec total_enrich_b: (g:ctx) {B:[g ⊢ ccsk.bstep X' T X]} [g ⊢ ex_b_enrich B] =
/ total b (total_enrich_b b _ _ _ _) /
mlam B ⇒ case [_ ⊢ B] of
  | [g ⊢ ccsk.bs_pref D] ⇒ [g ⊢ ex_enbc (en_bc B (ccskp.bc_pref D) ccskp.lab_base ccskp.key_base)]
  | [g ⊢ ccsk.bs_kpref B1 I] ⇒
    (case total_enrich_b [g ⊢ B1] of
       | [g ⊢ ex_enbc (en_bc B1 B1' L H)] ⇒ [g ⊢ ex_enbc (en_bc B (ccskp.bc_kpref B1' H I) L H)]
       | [g ⊢ ex_enbo (en_bo B1 B1' \a.H)] ⇒ [g ⊢ ex_enbo (en_bo B (ccskp.bo_kpref B1' (\a.H) I) \a.H)])
  | [g ⊢ ccsk.bs_suml B1 D] ⇒
    (case total_enrich_b [g ⊢ B1] of
       | [g ⊢ ex_enbc (en_bc B1 B1' L H)] ⇒ [g ⊢ ex_enbc (en_bc B (ccskp.bc_suml B1' D) (ccskp.lab_suml L) (ccskp.key_suml H))]
       | [g ⊢ ex_enbo (en_bo B1 B1' \a.H)] ⇒ [g ⊢ ex_enbo (en_bo B (ccskp.bo_suml B1' D) \a.(ccskp.key_suml H))])
  | [g ⊢ ccsk.bs_sumr B1 D] ⇒
    (case total_enrich_b [g ⊢ B1] of
       | [g ⊢ ex_enbc (en_bc B1 B1' L H)] ⇒ [g ⊢ ex_enbc (en_bc B (ccskp.bc_sumr B1' D) (ccskp.lab_sumr L) (ccskp.key_sumr H))]
       | [g ⊢ ex_enbo (en_bo B1 B1' \a.H)] ⇒ [g ⊢ ex_enbo (en_bo B (ccskp.bo_sumr B1' D) \a.(ccskp.key_sumr H))])
  | [g ⊢ ccsk.bs_parl B1 N] ⇒
    (case total_enrich_b [g ⊢ B1] of
       | [g ⊢ ex_enbc (en_bc B1 B1' L H)] ⇒ [g ⊢ ex_enbc (en_bc B (ccskp.bc_parl B1' H N) (ccskp.lab_parl L) (ccskp.key_parl H))]
       | [g ⊢ ex_enbo (en_bo B1 B1' \a.H)] ⇒ [g ⊢ ex_enbo (en_bo B (ccskp.bo_parl B1' (\a.H) N) \a.(ccskp.key_parl H))])
  | [g ⊢ ccsk.bs_parr B1 N] ⇒
    (case total_enrich_b [g ⊢ B1] of
       | [g ⊢ ex_enbc (en_bc B1 B1' L H)] ⇒ [g ⊢ ex_enbc (en_bc B (ccskp.bc_parr B1' H N) (ccskp.lab_parr L) (ccskp.key_parr H))]
       | [g ⊢ ex_enbo (en_bo B1 B1' \a.H)] ⇒ [g ⊢ ex_enbo (en_bo B (ccskp.bo_parr B1' (\a.H) N) \a.(ccskp.key_parr H))])
  | [g ⊢ ccsk.bs_synl B1 B2] ⇒
    let [g ⊢ ex_enbc (en_bc B1 B1' L1 H1)] = total_enrich_b [g ⊢ B1] in
    let [g ⊢ ex_enbc (en_bc B2 B2' L2 H2)] = total_enrich_b [g ⊢ B2] in
    [g ⊢ ex_enbc (en_bc B (ccskp.bc_synl B1' L1 H1 B2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.bs_synr B1 B2] ⇒
    let [g ⊢ ex_enbc (en_bc B1 B1' L1 H1)] = total_enrich_b [g ⊢ B1] in
    let [g ⊢ ex_enbc (en_bc B2 B2' L2 H2)] = total_enrich_b [g ⊢ B2] in
    [g ⊢ ex_enbc (en_bc B (ccskp.bc_synr B1' L1 H1 B2' L2 H2) (ccskp.lab_sync) (ccskp.key_sync H1))]
  | [g ⊢ ccsk.bs_nu \a.B1] ⇒
    (case total_enrich_b [g,a:names ⊢ B1] of
       | [g,a:names ⊢ ex_enbc (en_bc B1 B1' L H)] ⇒
         let [g,a:names ⊢ V] = valid_in_bstep_cl [g,a:names ⊢ B1'] in
         (case dec_occurs [g,a:names ⊢ V] of
            | occ [g,a:names ⊢ T] [g,a:names ⊢ O] ⇒
              let [g,a:names ⊢ L'] = occurs_impl_tau [g,a:names ⊢ O] [g,a:names ⊢ L] in
              let [g,a:names ⊢ reflb] = unique_lab [g,a:names ⊢ L] [g,a:names ⊢ L'] in
              [g ⊢ ex_enbo (en_bo B (ccskp.bo_nu_cl (\a.O) (\a.L) (\a.B1')) (\a.H))]
            | noc [g,a:names ⊢ T] [g,a:names ⊢ E] ⇒
              let [g,a:names ⊢ refpl] = [g,a:names ⊢ E] in
              let [g ⊢ L'] = str_labr [g,a:names ⊢ L] in
              let [g ⊢ H'] = str_key [g,a:names ⊢ H] in
              [g ⊢ ex_enbc (en_bc B (ccskp.bc_nu \a.B1') L' H')])
       | [g,a:names ⊢ ex_enbo (en_bo B1 B1' \b.H[..,b,a])] ⇒
         let ex_sbo [g,b:names ⊢ B1'] [g,b:names ⊢ B1''] e = str_bstep_open [g,b:names ⊢ B1'] in
         let [g,a:names,b:names ⊢ refpl] = e in
         [g ⊢ ex_enbo (en_bo B (ccskp.bo_nu_op \a.B1'') \a.H[..,a])])
;


% Totality of enrich:
% Given a CCSK combined transition S1, there is at least one CCSKP combined transition S2 such that enrich(S1)=S2.
rec total_enrich: (g:ctx) {S:[g ⊢ ccsk.step X T X']} [g ⊢ ex_enrich S] =
/ total s (total_enrich s _ _ _ _) /
mlam S ⇒ case [_ ⊢ S] of
  | [g ⊢ ccsk.fw F] ⇒ (case total_enrich_f [g ⊢ F] of
       | [g ⊢ ex_enfc D] ⇒ [g ⊢ ex_en (enfc D)]
       | [g ⊢ ex_enfo D] ⇒ [g ⊢ ex_en (enfo D)])
  | [g ⊢ ccsk.bw B] ⇒ (case total_enrich_b [g ⊢ B] of
       | [g ⊢ ex_enbc D] ⇒ [g ⊢ ex_en (enbc D)]
       | [g ⊢ ex_enbo D] ⇒ [g ⊢ ex_en (enbo D)])
;