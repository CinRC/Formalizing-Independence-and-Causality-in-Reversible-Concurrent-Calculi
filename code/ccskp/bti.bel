%%% BTI: backward transitions are independent

% Since, in the encoding, backward transitions are either closed or open,
% and the statement of BTI involves two backward transitions, we first prove
% BTI for each of the four cases where the two transitions are respectively
% closed-closed, closed-open, open-closed and open-open.
% We will then prove the original version of BTI for generic backward
% transitions by applying these four subtheorems.

% Observe that, since Beluga does not present a negation operator at the LF level,
% we prove a version of BTI which is different, but equivalent, to its paper version:
% instead of proving that two different backward transitions are independent,
% we prove that two backward transitions are either identical or independent.

% Given two backward closed transitions B1 and B2, id_or_ind_cc B1 B2 holds iff
% either B1=B2, or their proof labels are independent. 
LF id_or_ind_cc: bstep_cl X T1 X1 → bstep_cl X T2 X2 → type =
  | bt_id_cc: eqbc B1 B2 → id_or_ind_cc B1 B2
  | bt_ind_cc: indep_cl T1 T2 → id_or_ind_cc (B1:bstep_cl X T1 X1) (B2:bstep_cl X T2 X2)
;

% BTI, closed-closed case:
% Given two backward closed transitions sharing the same source process,
% they are either identical or their proof labels are independent.
rec bti_cc: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {B2:[g ⊢ bstep_cl X T2 X2]}
  [g ⊢ id_or_ind_cc B1 B2] =
/ total b1 (bti_cc _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bc_pref D1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_cc refbc]
       | [g ⊢ bc_kpref B2' _ _] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_kpref B1' H1 I1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ impossible source_is_not_std_bc [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_kpref B2' H2 I2] ⇒ 
         (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let refnq [g ⊢ _] = unique_neq [g ⊢ I1] [g ⊢ I2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc I]))
  | [g ⊢ bc_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_c1l I)])
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bc_sumr B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_c1r I)]))
  | [g ⊢ bc_parl B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_p1l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ bt_ind_cc (i_p2l H1 H2 N)]
       | [g ⊢ bc_synl BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1l I)])
       | [g ⊢ bc_synr BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1l I)]))
  | [g ⊢ bc_parr B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ bt_ind_cc (i_p2r H1 H2 N)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_cc refbc]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_p1r I)])
       | [g ⊢ bc_synl BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1r I)])
       | [g ⊢ bc_synr BL2 _ HL2 BR2 _ HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s1r I)]))
  | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BR1] [g ⊢ HR1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BL1] [g ⊢ HL1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LL1] [g ⊢ LL2] in
              let [g ⊢ refky] = unique_key [g ⊢ HL1] [g ⊢ HL2] in
              (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   [g ⊢ bt_id_cc refbc]
                 | [g ⊢ bt_ind_cc I2] ⇒ let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BR1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BR2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I2] [g ⊢ HR1] [g ⊢ HR2] in
                   impossible irreflexive_neq [g ⊢ N])
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BL1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BL2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I1] [g ⊢ HL1] [g ⊢ HL2] in
                   impossible irreflexive_neq [g ⊢ N]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)]))
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LL1] [g ⊢ LL2]
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LR1] [g ⊢ LR2]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)])))
  | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BR1] [g ⊢ HR1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BL1] [g ⊢ HL1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_cc (i_s2r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LL1] [g ⊢ LL2]
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ impossible unique_lab [g ⊢ LR1] [g ⊢ LR2]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)]))
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LL1] [g ⊢ LL2] in
              let [g ⊢ refky] = unique_key [g ⊢ HL1] [g ⊢ HL2] in
              (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   [g ⊢ bt_id_cc refbc]
                 | [g ⊢ bt_ind_cc I2] ⇒ let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BR1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BR2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I2] [g ⊢ HR1] [g ⊢ HR2] in
                   impossible irreflexive_neq [g ⊢ N])
            | [g ⊢ bt_ind_cc I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ bt_id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BL1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BL2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I1] [g ⊢ HL1] [g ⊢ HL2] in
                   impossible irreflexive_neq [g ⊢ N]
                 | [g ⊢ bt_ind_cc I2] ⇒ [g ⊢ bt_ind_cc (i_s3 I1 I2)])))
  | [g ⊢ bc_nu \a.B1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in 
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ bt_id_cc refbc] ⇒ [g ⊢ bt_id_cc refbc]
            | [g,a:names ⊢ bt_ind_cc I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in
                                            [g ⊢ bt_ind_cc I'])
;



% BTI, closed-open case:
% Given a closed and an open backward transition sharing the same source process,
% their proof labels are independent.
% Observe that, unlike the closed-closed case, the two transitions cannot be identical:
% this is because closed and open transitions belong to distinct types.
rec bti_co: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {B2:[g ⊢ bstep_op X T2 X2]}
  [g ⊢ indep (p_cl T1) (p_op T2)] =
/ total b2 (bti_co _ _ _ _ _ _ _ b2) /
mlam B1,B2 ⇒ case [_ ⊢ B2] of
  | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ let [g ⊢ bc_nu \a.B1'] = [g ⊢ B1] in
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
      | [g,a:names ⊢ bt_id_cc refbc] ⇒ impossible occur_imp [_ ⊢ O2]
      | [g,a:names ⊢ bt_ind_cc I] ⇒ [g ⊢ i_co \a.I])
  | [g ⊢ bo_kpref B2' (\a.H2) I2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_pref D1] ⇒ impossible source_is_not_std_bo [_ ⊢ B2'] [_ ⊢ D1]
       | [g ⊢ bc_kpref B1' H1 I1] ⇒ bti_co [g ⊢ B1'] [g ⊢ B2'])
  | [g ⊢ bo_suml B2' D2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_suml B1' D1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_c1l I)]
       | [g ⊢ bc_sumr B1' D1] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bo_sumr B2' D2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_suml B1' D1] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bc_sumr B1' D1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_c1r I)])
  | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_parl B1' H1 N1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_p1l I)]
       | [g ⊢ bc_parr B1' H1 N1] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
         [g ⊢ i_co \a.(i_p2r H1[..] H2 N[..])]
       | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BL1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2l I)]
       | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BL1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2l I)])
  | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ (case [g ⊢ B1] of
       | [g ⊢ bc_parl B1' H1 N1] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
         [g ⊢ i_co \a.(i_p2l H1[..] H2 N[..])]
       | [g ⊢ bc_parr B1' H1 N1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_p1r I)]
       | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BR1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2r I)]
       | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ let [g ⊢ i_co \a.I] = bti_co [g ⊢ BR1] [g ⊢ B2'] in
         [g ⊢ i_co \a.(i_s2r I)])
  | [g ⊢ bo_nu_op \a.B2'] ⇒ let [g ⊢ bc_nu \a.B1'] = [g ⊢ B1] in 
    let [g,a:names ⊢ i_co \b.I[..,b,a]] = bti_co [_ ⊢ B1'] [_ ⊢ B2'] in
    [g ⊢ i_co \b.I[..,b]]
;



% BTI, open-closed case:
% Given an open and a closed backward transition sharing the same source process,
% their proof labels are independent.
rec bti_oc: (g:ctx) {B1:[g ⊢ bstep_op X T1 X1]} {B2:[g ⊢ bstep_cl X T2 X2]}
  [g ⊢ indep (p_op T1) (p_cl T2)] =
/ total b1 (bti_oc _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bo_nu_cl (\a.O1) (\a.L1) (\a.B1')] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
      | [g,a:names ⊢ bt_id_cc refbc] ⇒ impossible occur_imp [_ ⊢ O1]
      | [g,a:names ⊢ bt_ind_cc I] ⇒ [g ⊢ i_oc \a.I])
  | [g ⊢ bo_kpref B1' (\a.H1) I1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ impossible source_is_not_std_bo [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_kpref B2' H2 I2] ⇒ bti_oc [g ⊢ B1'] [g ⊢ B2'])
  | [g ⊢ bo_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_c1l I)]
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B1'] [g ⊢ D2])
  | [g ⊢ bo_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_sumr B2' D2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_c1r I)])
  | [g ⊢ bo_parl B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_p1l I)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
         [g ⊢ i_oc \a.(i_p2l H1 H2[..] N[..])]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BL2] in
         [g ⊢ i_oc \a.(i_s1l I)]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BL2] in
         [g ⊢ i_oc \a.(i_s1l I)])
  | [g ⊢ bo_parr B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
         [g ⊢ i_oc \a.(i_p2r H1 H2[..] N[..])]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in
         [g ⊢ i_oc \a.(i_p1r I)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BR2] in
         [g ⊢ i_oc \a.(i_s1r I)]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_oc \a.I] = bti_oc [g ⊢ B1'] [g ⊢ BR2] in
         [g ⊢ i_oc \a.(i_s1r I)])
  | [g ⊢ bo_nu_op \a.B1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in 
    let [g,a:names ⊢ i_oc \b.I[..,b,a]] = bti_oc [_ ⊢ B1'] [_ ⊢ B2'] in 
    [g ⊢ i_oc \b.I[..,b]]
;



% Given two backward open transitions B1 and B2, id_or_ind_oo B1 B2 holds iff
% either B1=B2, or their proof labels are independent. 
LF id_or_ind_oo: bstep_op X T1 X1 → bstep_op X T2 X2 → type =
  | bt_id_oo: eqbo B1 B2 → id_or_ind_oo B1 B2
  | bt_ind_oo: indep (p_op T1) (p_op T2) → id_or_ind_oo (B1:bstep_op X T1 X1) (B2:bstep_op X T2 X2)
;

% BTI, open-open case:
% Given two backward open transitions sharing the same source process,
% they are either identical or their proof labels are independent.
rec bti_oo: (g:ctx) {B1:[g ⊢ bstep_op X T1 X1]} {B2:[g ⊢ bstep_op X T2 X2]}
  [g ⊢ id_or_ind_oo B1 B2] =
/ total b1 (bti_oo _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bo_nu_cl (\a.O1) (\a.L1) (\a.B1')] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ bt_id_cc refbc] ⇒ let [g,a:names ⊢ refoc] = unique_occ [_ ⊢ O1] [_ ⊢ O2] in
              let [g,a:names ⊢ reflb] = unique_lab [_ ⊢ L1] [_ ⊢ L2] in [g ⊢ bt_id_oo refbo]
            | [g,a:names ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind_oo (i_oo \a.I)])
       | [g ⊢ bo_nu_op \a.B2'] ⇒ let [g,a:names ⊢ i_co \b.I] = bti_co [_ ⊢ B1'] [_ ⊢ B2'] in
         [g ⊢ bt_ind_oo (i_oo \b.I[..,b])])
  | [g ⊢ bo_kpref B1' (\a.H1) I1] ⇒ let [g ⊢ bo_kpref B2' (\a.H2) I2] = [g ⊢ B2] in
    (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
       | [g ⊢ bt_id_oo refbo] ⇒ let [g,a:names ⊢ refky] = unique_key [_ ⊢ H1] [_ ⊢ H2] in
         let refnq [g ⊢ _] = unique_neq [g ⊢ I1] [g ⊢ I2] in [g ⊢ bt_id_oo refbo]
       | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.I)])
  | [g ⊢ bo_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_suml B2' D2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_c1l I))])
       | [g ⊢ bo_sumr B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bo_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_suml B2' D2] ⇒ impossible source_is_not_std_bo [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bo_sumr B2' D2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_c1r I))]))
  | [g ⊢ bo_parl B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g,a:names ⊢ refky] = unique_key [_ ⊢ H1] [_ ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_p1l I))])
       | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
              [g ⊢ bt_ind_oo (i_oo \a.(i_p2l H1 H2 N[..]))])
  | [g ⊢ bo_parr B1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ let [g ⊢ N] = key_in_bstep_op [g ⊢ N1] [g ⊢ B2'] [_ ⊢ H2] in
              [g ⊢ bt_ind_oo (i_oo \a.(i_p2r H1 H2 N[..]))]
       | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ let [g,a:names ⊢ refky] = unique_key [_ ⊢ H1] [_ ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ bt_id_oo refbo]
            | [g ⊢ bt_ind_oo (i_oo \a.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \a.(i_p1r I))]))
  | [g ⊢ bo_nu_op \a.B1'] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ let [g,a:names ⊢ i_oc \b.I] = bti_oc [_ ⊢ B1'] [_ ⊢ B2'] in
         [g ⊢ bt_ind_oo (i_oo \b.I[..,b])]
       | [g ⊢ bo_nu_op \a.B2'] ⇒ (case bti_oo [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ bt_id_oo refbo] ⇒ [g ⊢ bt_id_oo refbo]
            | [g,a:names ⊢ bt_ind_oo (i_oo \b.I)] ⇒ [g ⊢ bt_ind_oo (i_oo \b.I[..,b])]))
;


% Equality of derivations of bstep X' T X
LF eqb: bstep X1' T1 X1 → bstep X2' T2 X2 → type =
  | refb: eqb B B
;

% Given two backward transitions B1 and B2, id_or_ind B1 B2 holds iff
% either B1=B2, or B1 and B2 are independent.
LF id_or_ind: bstep X T1 X1 → bstep X T2 X2 → type =
  | bt_id: eqb B1 B2 → id_or_ind B1 B2
  | bt_ind: back_to_comb B1 S1 → back_to_comb B2 S2 → indep_tr S1 S2 → id_or_ind B1 B2
;

% BTI:
% Given two backward transitions sharing the same source process,
% they are either identical or their proof labels are independent.
rec bti: (g:ctx) {B1:[g ⊢ bstep X T1 X1]} {B2:[g ⊢ bstep X T2 X2]}
  [g ⊢ id_or_ind B1 B2] =
/ total b1 (bti _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒  let [g ⊢ btc C1] = total_back_to_comb [_ ⊢ B1] in
let [g ⊢ btc C2] = total_back_to_comb [g ⊢ B2] in
case [g ⊢ B1] of
  | [g ⊢ bc B1'] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc B2'] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_cc refbc] ⇒ [g ⊢ bt_id refb]
            | [g ⊢ bt_ind_cc I] ⇒ [g ⊢ bt_ind C1 C2 (ind_tr (i_cc I) (ct _ _ (st_s* (sc (bwc B2')))))])
       | [g ⊢ bo B2'] ⇒ let [g ⊢ I] = bti_co [g ⊢ B1'] [g ⊢ B2'] in [g ⊢ bt_ind C1 C2 (ind_tr I (ct _ _ (st_s* (so (bwo B2')))))])
  | [g ⊢ bo B1'] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc B2'] ⇒ let [g ⊢ I] = bti_oc [g ⊢ B1'] [g ⊢ B2'] in [g ⊢ bt_ind C1 C2 (ind_tr I (ct _ _ (st_s* (sc (bwc B2')))))]
       | [g ⊢ bo B2'] ⇒ (case bti_oo [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ bt_id_oo refbo] ⇒ [g ⊢ bt_id refb]
            | [g ⊢ bt_ind_oo I] ⇒ [g ⊢ bt_ind C1 C2 (ind_tr I (ct _ _ (st_s* (so (bwo B2')))))]))
;