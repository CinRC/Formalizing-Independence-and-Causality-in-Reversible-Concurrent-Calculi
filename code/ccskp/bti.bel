
% If a key K does not occur in a process, and such process makes a backward closed transition
% labelled by T, then K is different from key(T).
rec key_in_bstep_cl: (g:ctx) [g ⊢ notin K[] X] → [g ⊢ bstep_cl X T Y] → [g ⊢ key T M[]] → [g ⊢ neq K[] M[]] =
/ total n (key_in_bstep_cl _ _ _ _ _ _ n _ _) /
fn n,b,h ⇒ case n of
  | [g ⊢ not_null] ⇒ impossible b
  | [g ⊢ not_pref N] ⇒ impossible b
  | [g ⊢ not_kpref I N] ⇒ (case b of
       | [g ⊢ bc_pref _] ⇒ let [g ⊢ key_base] = h in [g ⊢ I]
       | [g ⊢ bc_kpref B H _] ⇒ let [g ⊢ H'] = h in
         let [g ⊢ refky] = unique_key [g ⊢ H] [g ⊢ H'] in 
         key_in_bstep_cl [g ⊢ N] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_sum N1 N2] ⇒ (case b of
       | [g ⊢ bc_suml B _] ⇒ let [g ⊢ key_suml H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_sumr B _] ⇒ let [g ⊢ key_sumr H] = h in key_in_bstep_cl [g ⊢ N2] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_par N1 N2] ⇒ (case b of
       | [g ⊢ bc_parl B _ _] ⇒ let [g ⊢ key_parl H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_parr B _ _] ⇒ let [g ⊢ key_parr H] = h in key_in_bstep_cl [g ⊢ N2] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_synl B _ _ _ _ _] ⇒ let [g ⊢ key_sync H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_synr B _ _ _ _ _] ⇒ let [g ⊢ key_sync H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_nu \a.N] ⇒ let [g ⊢ bc_nu \a.B] = b in
    let [g ⊢ H] = h in 
    let [g,a:names ⊢ I[..]] = key_in_bstep_cl [_ ⊢ N] [_ ⊢ B] [_ ⊢ H[..]] in [g ⊢ I]
;

rec indep_impl_diff_keys: (g:ctx) [g ⊢ indep_cl T1 T2] → [g ⊢ key T1 K1[]] → [g ⊢ key T2 K2[]] → [g ⊢ neq K1[] K2[]] =
?
;

% Strengthening lemma for indep_cl 
rec str_indep: (g:ctx) [g,a:names ⊢ indep_cl T1[..] T2[..]] → [g ⊢ indep_cl T1 T2] =
/ total i (str_indep _ _ _ i) /
fn i ⇒ case i of
  | [g,a:names ⊢ i_c1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_c1l I']
  | [g,a:names ⊢ i_c1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_c1r I']
  | [g,a:names ⊢ i_p1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_p1l I']
  | [g,a:names ⊢ i_p1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_p1r I']
  | [g,a:names ⊢ i_p2l H1 H2 N[..]] ⇒ let [g ⊢ H1'] = str_key [_ ⊢ H1] in
     let [g ⊢ H2'] = str_key [_ ⊢ H2] in [g ⊢ i_p2l H1' H2' N]
  | [g,a:names ⊢ i_p2r H1 H2 N[..]] ⇒ let [g ⊢ H1'] = str_key [_ ⊢ H1] in
     let [g ⊢ H2'] = str_key [_ ⊢ H2] in [g ⊢ i_p2r H1' H2' N]
  | [g,a:names ⊢ i_s1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s1l I']
  | [g,a:names ⊢ i_s1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s1r I']
  | [g,a:names ⊢ i_s2l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s2l I']
  | [g,a:names ⊢ i_s2r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s2r I']
  | [g,a:names ⊢ i_s3 I1 I2] ⇒ let [g ⊢ I1'] = str_indep [_ ⊢ I1] in
    let [g ⊢ I2'] = str_indep [_ ⊢ I2] in [g ⊢ i_s3 I1' I2']
;


% Given two backward closed transitions B1 and B2, id_or_bti B1 B2 holds iff
% either B1=B2, or their proof labels are independent. 
LF id_or_bti_cc: bstep_cl X T1 X1 → bstep_cl X T2 X2 → type =
  | id_cc: eqbc B1 B2 → id_or_bti_cc B1 B2
  | ind_cc: {B1:bstep_cl X T1 X1}{B2: bstep_cl X T2 X2} indep_cl T1 T2 
          → id_or_bti_cc B1 B2
;

% BTI for backward closed transitions:
% Given two backward closed transitions sharing the same source process,
% they are either equal or their proof labels are independent.
rec bti_cc: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {B2:[g ⊢ bstep_cl X T2 X2]}
  [g ⊢ id_or_bti_cc B1 B2] =
/ total b1 (bti_cc _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bc_pref D1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ id_cc refbc]
       | [g ⊢ bc_kpref B2' _ _] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_kpref B1' H1 I1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ impossible source_is_not_std_bc [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_kpref B2' H2 I2] ⇒ 
         (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let refnq [g ⊢ _] = unique_neq [g ⊢ I1] [g ⊢ I2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ I]))
  | [g ⊢ bc_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_c1l I)])
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bc_sumr B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_c1r I)]))
  | [g ⊢ bc_parl B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_p1l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ ind_cc _ _ (i_p2l H1 H2 N)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1l I)])
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1l I)]))
  | [g ⊢ bc_parr B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ ind_cc _ _ (i_p2r H1 H2 N)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_p1r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1r I)])
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1r I)]))
  | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BR1] [g ⊢ HR1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s2l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BL1] [g ⊢ HL1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s2r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LL1] [g ⊢ LL2] in
              let [g ⊢ refky] = unique_key [g ⊢ HL1] [g ⊢ HL2] in
              (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   [g ⊢ id_cc refbc]
                 | [g ⊢ ind_cc _ _ I2] ⇒ let [g ⊢ N] = indep_impl_diff_keys [g ⊢ I2] [g ⊢ HR1] [g ⊢ HR2] in
                   impossible irreflexive_neq [g ⊢ N])
            | [g ⊢ ind_cc _ _ I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ I1] [g ⊢ HL1] [g ⊢ HL2] in
                   impossible irreflexive_neq [g ⊢ N]
                 | [g ⊢ ind_cc _ _ I2] ⇒ [g ⊢ ind_cc _ _ (i_s3 I1 I2)]))
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ impossible unique_lab [g ⊢ LL1] [g ⊢ LL2]
            | [g ⊢ ind_cc _ _ I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ impossible unique_lab [g ⊢ LR1] [g ⊢ LR2]
                 | [g ⊢ ind_cc _ _ I2] ⇒ [g ⊢ ind_cc _ _ (i_s3 I1 I2)])))
  | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ ?
  | [g ⊢ bc_nu \a.B1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in 
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ id_cc refbc] ⇒ [g ⊢ id_cc refbc]
            | [g,a:names ⊢ ind_cc _ _ I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in
                                            [g ⊢ ind_cc _ _ I'])
;






%{

%%% Auxiliary lemmas for Proposition 4.4 (1) %%%

% The following lemmas state that, given a path whose source is a
% known process, we can infer information about the target process.

% A path starting from 0 ends in 0
rec step*_from_null: (g:ctx) [g ⊢ step* null X] → [g ⊢ eqp null X] =
/ total s (step*_from_null _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ refp]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ so (fwo F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ sc (bwc B)] ⇒ impossible [g ⊢ B]
       | [g ⊢ so (bwo B)] ⇒ impossible [g ⊢ B])
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ refp] = step*_from_null [g ⊢ S1*] in
       let [g ⊢ refp] = step*_from_null [g ⊢ S2*] in [g ⊢ refp]
;

% Type family encoding prefixes and keyed prefixes
LF is_pref_or_kpref: labels → proc → type =
  | or_pref: is_pref_or_kpref A (pref A X)
  | or_kpref: is_pref_or_kpref A (kpref A K X)
;

% A path starting from a prefix ends in a prefix or keyed prefix
rec step*_from_pref: (g:ctx) [g ⊢ step* (pref A X) Y] → [g ⊢ is_pref_or_kpref A Y] =
/ total s (step*_from_pref _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ or_pref]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ let [g ⊢ fc_pref _] = [g ⊢ F] in [g ⊢ or_kpref]
       | [g ⊢ so (fwo F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ sc (bwc B)] ⇒ impossible [g ⊢ B]
       | [g ⊢ so (bwo B)] ⇒ impossible [g ⊢ B])
  | [g ⊢ tr_s* S1* S2*] ⇒ (case step*_from_pref [g ⊢ S1*] of
       | [g ⊢ or_pref] ⇒ step*_from_pref [g ⊢ S2*]
       | [g ⊢ or_kpref] ⇒ step*_from_kpref [g ⊢ S2*])

% A path starting from a keyed prefix ends in a prefix or keyed prefix
and rec step*_from_kpref: (g:ctx) [g ⊢ step* (kpref A K[] X) Y] → [g ⊢ is_pref_or_kpref A Y] =
/ total s (step*_from_kpref _ _ _ _ _ s) /
fn s ⇒ case s of 
  | [g ⊢ id_s*] ⇒ [g ⊢ or_kpref]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ let [g ⊢ fc_kpref _ _ _] = [g ⊢ F] in [g ⊢ or_kpref]
       | [g ⊢ so (fwo F)] ⇒ let [g ⊢ fo_kpref _ (\_._) _] = [g ⊢ F] in [g ⊢ or_kpref]
       | [g ⊢ sc (bwc B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bc_pref _] ⇒ [g ⊢ or_pref]
            | [g ⊢ bc_kpref _ _ _] ⇒ [g ⊢ or_kpref])
       | [g ⊢ so (bwo B)] ⇒ let [g ⊢ bo_kpref _ (\_._) _] = [g ⊢ B] in [g ⊢ or_kpref])
  | [g ⊢ tr_s* S1* S2*] ⇒ (case step*_from_kpref [g ⊢ S1*] of
       | [g ⊢ or_pref] ⇒ step*_from_pref [g ⊢ S2*]
       | [g ⊢ or_kpref] ⇒ step*_from_kpref [g ⊢ S2*])
;

% Type family encoding sum processes
LF is_sum: proc → type =
  | sm: is_sum (sum X Y)
;

% A path starting from a sum process ends in a sum process
rec step*_from_sum: (g:ctx) [g ⊢ step* (sum X Y) Z] → [g ⊢ is_sum Z] =
/ total s (step*_from_sum _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ sm]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fc_suml _ _] ⇒ [g ⊢ sm]
            | [g ⊢ fc_sumr _ _] ⇒ [g ⊢ sm])
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_suml _ _] ⇒ [g ⊢ sm]
            | [g ⊢ fo_sumr _ _] ⇒ [g ⊢ sm])
       | [g ⊢ sc (bwc B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bc_suml _ _] ⇒ [g ⊢ sm]
            | [g ⊢ bc_sumr _ _] ⇒ [g ⊢ sm])
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_suml _ _] ⇒ [g ⊢ sm]
            | [g ⊢ bo_sumr _ _] ⇒ [g ⊢ sm]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ sm] = step*_from_sum [g ⊢ S1*] in step*_from_sum [g ⊢ S2*]
;

% Type family encoding parallel compositions
LF is_par: proc → type =
  | pr: is_par (par X Y)
;

% A path starting from a parallel composition ends in a parallel composition
rec step*_from_par: (g:ctx) [g ⊢ step* (par X Y) Z] → [g ⊢ is_par Z] =
/ total s (step*_from_par _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ pr]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fc_parl _ _ _] ⇒ [g ⊢ pr]
            | [g ⊢ fc_parr _ _ _] ⇒ [g ⊢ pr]
            | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ [g ⊢ pr]
            | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ [g ⊢ pr])
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_parl _ (\_._) _] ⇒ [g ⊢ pr]
            | [g ⊢ fo_parr _ (\_._) _] ⇒ [g ⊢ pr])
       | [g ⊢ sc (bwc B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bc_parl _ _ _] ⇒ [g ⊢ pr]
            | [g ⊢ bc_parr _ _ _] ⇒ [g ⊢ pr]
            | [g ⊢ bc_synl _ _ _ _ _ _] ⇒ [g ⊢ pr]
            | [g ⊢ bc_synr _ _ _ _ _ _] ⇒ [g ⊢ pr])
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_parl _ (\_._) _] ⇒ [g ⊢ pr]
            | [g ⊢ bo_parr _ (\_._) _] ⇒ [g ⊢ pr]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ pr] = step*_from_par [g ⊢ S1*] in step*_from_par [g ⊢ S2*]
;

% Type family encoding restrictions
LF is_res: proc → type =
  | rs: is_res (nu X)
;

% A path starting from a restriction ends in a restriction
rec step*_from_nu: (g:ctx) [g ⊢ step* (nu \a.X) Y] → [g ⊢ is_res Y] =
/ total s (step*_from_nu _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ rs]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc (fc_nu \_._))] ⇒ [g ⊢ rs]
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_nu_cl (\_._) (\_._) (\_._)] ⇒ [g ⊢ rs]
            | [g ⊢ fo_nu_op \_._] ⇒ [g ⊢ rs])
       | [g ⊢ sc (bwc (bc_nu \_._))] ⇒ [g ⊢ rs]
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_nu_cl (\_._) (\_._) (\_._)] ⇒ [g ⊢ rs]
            | [g ⊢ bo_nu_op \_._] ⇒ [g ⊢ rs]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ rs] = step*_from_nu [g ⊢ S1*] in step*_from_nu [g ⊢ S2*]
;


% The following lemmas show that, given a path between two processes,
% it is possible to build a path between their subprocesses.

% Given a path between prefixes, there is a path between their subprocesses
rec step*_betw_prefs: (g:ctx) [g ⊢ step* (pref A X) (pref A Y)] → [g ⊢ step* X Y] =
/ total s (step*_betw_prefs _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ so (fwo F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ sc (bwc B)] ⇒ impossible [g ⊢ B]
       | [g ⊢ so (bwo B)] ⇒ impossible [g ⊢ B])
  | [g ⊢ tr_s* S1* S2*] ⇒ (case step*_from_pref [g ⊢ S1*] of
       | [g ⊢ or_pref] ⇒ let [g ⊢ S1*'] = step*_betw_prefs [g ⊢ S1*] in  
            let [g ⊢ S2*'] = step*_betw_prefs [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
       | [g ⊢ or_kpref] ⇒ let [g ⊢ S1*'] = step*_betw_pref_and_kpref [g ⊢ S1*] in
            let [g ⊢ S2*'] = step*_betw_kpref_and_pref [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*'])

% Given a path between a prefix and a keyed prefix, there is a path between their subprocesses
and rec step*_betw_pref_and_kpref: (g:ctx) [g ⊢ step* (pref A X) (kpref A K[] Y)] → [g ⊢ step* X Y] =
/ total s (step*_betw_pref_and_kpref _ _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc (fc_pref _))] ⇒ [g ⊢ id_s*]
       | [g ⊢ so (fwo F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ sc (bwc B)] ⇒ impossible [g ⊢ B]
       | [g ⊢ so (bwo B)] ⇒ impossible [g ⊢ B])
  | [g ⊢ tr_s* S1* S2*] ⇒ (case step*_from_pref [g ⊢ S1*] of
       | [g ⊢ or_pref] ⇒ let [g ⊢ S1*'] = step*_betw_prefs [g ⊢ S1*] in  
            let [g ⊢ S2*'] = step*_betw_pref_and_kpref [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
       | [g ⊢ or_kpref] ⇒ let [g ⊢ S1*'] = step*_betw_pref_and_kpref [g ⊢ S1*] in
            let [g ⊢ S2*'] = step*_betw_kprefs [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*'])

% Given a path between a keyed prefix and a prefix, there is a path between their subprocesses
and rec step*_betw_kpref_and_pref: (g:ctx) [g ⊢ step* (kpref A K[] X) (pref A Y)] → [g ⊢ step* X Y] =
/ total s (step*_betw_kpref_and_pref _ _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ so (fwo F)] ⇒ impossible [g ⊢ F]
       | [g ⊢ sc (bwc (bc_pref _))] ⇒ [g ⊢ id_s*]
       | [g ⊢ so (bwo B)] ⇒ impossible [g ⊢ B])
  | [g ⊢ tr_s* S1* S2*] ⇒ (case step*_from_kpref [g ⊢ S1*] of
       | [g ⊢ or_pref] ⇒ let [g ⊢ S1*'] = step*_betw_kpref_and_pref [g ⊢ S1*] in  
            let [g ⊢ S2*'] = step*_betw_prefs [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
       | [g ⊢ or_kpref] ⇒ let [g ⊢ S1*'] = step*_betw_kprefs [g ⊢ S1*] in
            let [g ⊢ S2*'] = step*_betw_kpref_and_pref [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*'])

% Given a path between keyed prefixes, there is a path between their subprocesses
and rec step*_betw_kprefs: (g:ctx) [g ⊢ step* (kpref A K[] X) (kpref A M[] Y)] → [g ⊢ step* X Y] =
/ total s (step*_betw_kprefs _ _ _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc (fc_kpref F _ _))] ⇒ [g ⊢ st_s* (sc (fwc F))]
       | [g ⊢ so (fwo (fo_kpref F (\_._) _))] ⇒ [g ⊢ st_s* (so (fwo F))]
       | [g ⊢ sc (bwc (bc_kpref B _ _))] ⇒ [g ⊢ st_s* (sc (bwc B))]
       | [g ⊢ so (bwo (bo_kpref B (\_._) _))] ⇒ [g ⊢ st_s* (so (bwo B))])
  | [g ⊢ tr_s* S1* S2*] ⇒ (case step*_from_kpref [g ⊢ S1*] of
       | [g ⊢ or_pref] ⇒ let [g ⊢ S1*'] = step*_betw_kpref_and_pref [g ⊢ S1*] in 
            let [g ⊢ S2*'] = step*_betw_pref_and_kpref [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
       | [g ⊢ or_kpref] ⇒ let [g ⊢ S1*'] = step*_betw_kprefs [g ⊢ S1*] in
            let [g ⊢ S2*'] = step*_betw_kprefs [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*'])
;

% Given a path between sum processes, there is a path between their left addends
rec step*_betw_sums_left: (g:ctx) [g ⊢ step* (sum X1 X2) (sum Y1 Y2)] → [g ⊢ step* X1 Y1] =
/ total s (step*_betw_sums_left _ _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fc_suml F' _] ⇒ [g ⊢ st_s* (sc (fwc F'))]
            | [g ⊢ fc_sumr _ _] ⇒ [g ⊢ id_s*])
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_suml F' _] ⇒ [g ⊢ st_s* (so (fwo F'))]
            | [g ⊢ fo_sumr _ _] ⇒ [g ⊢ id_s*])
       | [g ⊢ sc (bwc B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bc_suml B' _] ⇒ [g ⊢ st_s* (sc (bwc B'))]
            | [g ⊢ bc_sumr _ _] ⇒ [g ⊢ id_s*])
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_suml B' _] ⇒ [g ⊢ st_s* (so (bwo B'))]
            | [g ⊢ bo_sumr _ _] ⇒ [g ⊢ id_s*]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ sm] = step*_from_sum [g ⊢ S1*] in
       let [g ⊢ S1*'] = step*_betw_sums_left [g ⊢ S1*] in
       let [g ⊢ S2*'] = step*_betw_sums_left [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
;

% Given a path between sum processes, there is a path between their right addends
rec step*_betw_sums_right: (g:ctx) [g ⊢ step* (sum X1 X2) (sum Y1 Y2)] → [g ⊢ step* X2 Y2] =
/ total s (step*_betw_sums_right _ _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fc_suml _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ fc_sumr F' _] ⇒ [g ⊢ st_s* (sc (fwc F'))])
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_suml _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ fo_sumr F' _] ⇒ [g ⊢ st_s* (so (fwo F'))])
       | [g ⊢ sc (bwc B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bc_suml _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ bc_sumr B' _] ⇒ [g ⊢ st_s* (sc (bwc B'))])
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_suml _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ bo_sumr B' _] ⇒ [g ⊢ st_s* (so (bwo B'))]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ sm] = step*_from_sum [g ⊢ S1*] in
       let [g ⊢ S1*'] = step*_betw_sums_right [g ⊢ S1*] in
       let [g ⊢ S2*'] = step*_betw_sums_right [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
;

% Given a path between parallel compositions, there is a path between their left threads
rec step*_betw_pars_left: (g:ctx) [g ⊢ step* (par X1 X2) (par Y1 Y2)] → [g ⊢ step* X1 Y1] =
/ total s (step*_betw_pars_left _ _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fc_parl F' _ _] ⇒ [g ⊢ st_s* (sc (fwc F'))]
            | [g ⊢ fc_parr _ _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ fc_synl F' _ _ _ _ _] ⇒ [g ⊢ st_s* (sc (fwc F'))]
            | [g ⊢ fc_synr F' _ _ _ _ _] ⇒ [g ⊢ st_s* (sc (fwc F'))])
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_parl F' (\_._) _] ⇒ [g ⊢ st_s* (so (fwo F'))]
            | [g ⊢ fo_parr _ (\_._) _] ⇒ [g ⊢ id_s*])
       | [g ⊢ sc (bwc B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bc_parl B' _ _] ⇒ [g ⊢ st_s* (sc (bwc B'))]
            | [g ⊢ bc_parr _ _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ bc_synl B' _ _ _ _ _] ⇒ [g ⊢ st_s* (sc (bwc B'))]
            | [g ⊢ bc_synr B' _ _ _ _ _] ⇒ [g ⊢ st_s* (sc (bwc B'))])
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_parl B' (\_._) _] ⇒ [g ⊢ st_s* (so (bwo B'))]
            | [g ⊢ bo_parr _ (\_._) _] ⇒ [g ⊢ id_s*]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ pr] = step*_from_par [g ⊢ S1*] in
       let [g ⊢ S1*'] = step*_betw_pars_left [g ⊢ S1*] in
       let [g ⊢ S2*'] = step*_betw_pars_left [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
;

% Given a path between parallel compositions, there is a path between their right threads
rec step*_betw_pars_right: (g:ctx) [g ⊢ step* (par X1 X2) (par Y1 Y2)] → [g ⊢ step* X2 Y2] =
/ total s (step*_betw_pars_right _ _ _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fc_parl _ _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ fc_parr F' _ _] ⇒ [g ⊢ st_s* (sc (fwc F'))]
            | [g ⊢ fc_synl _ _ _ F' _ _] ⇒ [g ⊢ st_s* (sc (fwc F'))]
            | [g ⊢ fc_synr _ _ _ F' _ _] ⇒ [g ⊢ st_s* (sc (fwc F'))])
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_parl _ (\_._) _] ⇒ [g ⊢ id_s*]
            | [g ⊢ fo_parr F' (\_._) _] ⇒ [g ⊢ st_s* (so (fwo F'))])
       | [g ⊢ sc (bwc B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bc_parl _ _ _] ⇒ [g ⊢ id_s*]
            | [g ⊢ bc_parr B' _ _] ⇒ [g ⊢ st_s* (sc (bwc B'))]
            | [g ⊢ bc_synl _ _ _ B' _ _] ⇒ [g ⊢ st_s* (sc (bwc B'))]
            | [g ⊢ bc_synr _ _ _ B' _ _] ⇒ [g ⊢ st_s* (sc (bwc B'))])
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_parl _ (\_._) _] ⇒ [g ⊢ id_s*]
            | [g ⊢ bo_parr B' (\_._) _] ⇒ [g ⊢ st_s* (so (bwo B'))]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ pr] = step*_from_par [g ⊢ S1*] in
       let [g ⊢ S1*'] = step*_betw_pars_right [g ⊢ S1*] in
       let [g ⊢ S2*'] = step*_betw_pars_right [g ⊢ S2*] in [g ⊢ tr_s* S1*' S2*']
;

% Given a path between restrictions, there is a path between their subprocesses
rec step*_betw_nus: (g:ctx) [g ⊢ step* (nu \a.X) (nu \a.Y)] → [g,a:names ⊢ step* X Y] =
/ total s (step*_betw_nus _ _ _ s) /
fn s ⇒ case s of
  | [g ⊢ id_s*] ⇒ [g,a:names ⊢ id_s*]
  | [g ⊢ st_s* S] ⇒ (case [g ⊢ S] of
       | [g ⊢ sc (fwc (fc_nu \a.F))] ⇒ [g,a:names ⊢ st_s* (sc (fwc F))]
       | [g ⊢ so (fwo F)] ⇒ (case [g ⊢ F] of
            | [g ⊢ fo_nu_cl (\_._) (\_._) (\a.F')] ⇒ [g,a:names ⊢ st_s* (sc (fwc F'))]
            | [g ⊢ fo_nu_op \a.F'] ⇒ [g,a:names ⊢ st_s* (so (fwo F'))])
       | [g ⊢ sc (bwc (bc_nu \a.B))] ⇒ [g,a:names ⊢ st_s* (sc (bwc B))]
       | [g ⊢ so (bwo B)] ⇒ (case [g ⊢ B] of
            | [g ⊢ bo_nu_cl (\_._) (\_._) (\a.B')] ⇒ [g,a:names ⊢ st_s* (sc (bwc B'))]
            | [g ⊢ bo_nu_op \a.B'] ⇒ [g,a:names ⊢ st_s* (so (bwo B'))]))
  | [g ⊢ tr_s* S1* S2*] ⇒ let [g ⊢ rs] = step*_from_nu [g ⊢ S1*] in
       let [g,a:names ⊢ S1*'] = step*_betw_nus [g ⊢ S1*] in
       let [g,a:names ⊢ S2*'] = step*_betw_nus [g ⊢ S2*] in [g,a:names ⊢ tr_s* S1*' S2*']
;


% In a subcase of Thm. 2.1(i) there are derivations of connectivity "conn_cl T1 T2" in a context
% context [g,a:names], without T1 and T2 depending on a: in such cases we need a technical lemma
% (strengthening lemma) to get rid of the spurious dependence on the name a.
rec str_conn: (g:ctx) [g,a:names ⊢ conn_cl T1[..] T2[..]] → [g ⊢ conn_cl T1 T2] =
/ total c (str_conn _ _ _ c) /
fn c ⇒ case c of
  | [g,a:names ⊢ c_a1] ⇒ [g ⊢ c_a1]
  | [g,a:names ⊢ c_a2] ⇒ [g ⊢ c_a2]
  | [g,a:names ⊢ c_c1l C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_c1l C']
  | [g,a:names ⊢ c_c1r C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_c1r C']
  | [g,a:names ⊢ c_c2l] ⇒ [g ⊢ c_c2l]
  | [g,a:names ⊢ c_c2r] ⇒ [g ⊢ c_c2r]
  | [g,a:names ⊢ c_p1l C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_p1l C']
  | [g,a:names ⊢ c_p1r C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_p1r C']
  | [g,a:names ⊢ c_p2l] ⇒ [g ⊢ c_p2l]
  | [g,a:names ⊢ c_p2r] ⇒ [g ⊢ c_p2r]
  | [g,a:names ⊢ c_s1l C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_s1l C']
  | [g,a:names ⊢ c_s1r C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_s1r C']
  | [g,a:names ⊢ c_s2l C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_s2l C']
  | [g,a:names ⊢ c_s2r C] ⇒ let [g ⊢ C'] = str_conn [_ ⊢ C] in [g ⊢ c_s2r C']
  | [g,a:names ⊢ c_s3 C1 C2] ⇒ let [g ⊢ C1'] = str_conn [_ ⊢ C1] in
    let [g ⊢ C2'] = str_conn [_ ⊢ C2] in [g ⊢ c_s3 C1' C2']
;

}%