% Definitions needed to state the axioms from "An Axiomatic Approach to Reversible Computation" for CCSK

% Independence of CCSK transitions:
% Two CCSK transitions s1 and s2 are independent if they are connected and the proof labels
% of their corresponding CCSKP transitions enrich(s1) and enrich(s2) are independent.
LF ccsk_indep_tr: ccsk.step X T1 X' → ccsk.step Y T2 Y' → type =
  | ccsk_ind_tr: enrich (S1:ccsk.step X T1 X') (S1+:ccskp.step X T1+ X') →
    enrich (S2:ccsk.step Y T2 Y') (S2+:ccskp.step Y T2+ Y') →
    indep T1+ T2+ → ccsk.conn_tr S1 S2 → ccsk_indep_tr S1 S2
;

% Type family relating two combined CCSK transitions having the same direction
LF ccsk_same_direction: ccsk.step X1 T1 Y1 → ccsk.step X2 T2 Y2 → type =
  | ccsk_sdf: ccsk_same_direction (fw F1) (fw F2)
  | ccsk_sdb: ccsk_same_direction (bw B1) (bw B2)
;

% Existence of combined transitions closing a square diagram in CCSK
LF ccsk_square: ccsk.step X T1 X1 → ccsk.step X T2 X2 → type =
  | ccsk_sq: {S2':ccsk.step X1 T2 Y} {S1':ccsk.step X2 T1 Y} ccsk_same_direction (S1:ccsk.step X T1 X1) S1' → 
    ccsk_same_direction (S2:ccsk.step X T2 X2) S2' → ccsk_square (S1:ccsk.step X T1 X1) (S2:ccsk.step X T2 X2)
;



% Auxiliary lemmas for SP

% [[ Currently unused ]]
% Given a CCSK path between two processes, there exists a CCSKP path between the same processes.
rec path_ccsk_to_ccskp: (g:ctx) [g ⊢ ccsk.step* X X'] → [g ⊢ ccskp.step* X X'] =
/ total s* (path_ccsk_to_ccskp _ _ _ s*) /
fn s* ⇒ case s* of
  | [g ⊢ ccsk.id_s*] ⇒ [g ⊢ ccskp.id_s*]
  | [g ⊢ ccsk.st_s* S] ⇒ let {EN:[g ⊢ enrich _ S+]}[g ⊢ ex_en EN] = total_enrich [g ⊢ S] in [g ⊢ ccskp.st_s* S+]
  | [g ⊢ ccsk.tr_s* S1* S2*] ⇒ let [g ⊢ S1*+] = path_ccsk_to_ccskp [g ⊢ S1*] in
                                let [g ⊢ S2*+] = path_ccsk_to_ccskp [g ⊢ S2*] in [g ⊢ ccskp.tr_s* S1*+ S2*+]
;

% Equality of keyed labels
LF eqkl: key_lab → key_lab → type =
  | refkl: eqkl T T
;

% If two CCSKP transitions s1 and s2 have the same proof label, then their corresponding
% CCSK transitions forget(s1) and forget(s2) have the same keyed label.
rec injective_forget_on_labels: (g:ctx) (S1+:[g ⊢ ccskp.step X1 T+ Y1]) (S2+:[g ⊢ ccskp.step X2 T+ Y2])
  (S1:[g ⊢ ccsk.step X1 T1 Y1]) (S2:[g ⊢ ccsk.step X2 T2 Y2]) [g ⊢ forget S1+ S1] → [g ⊢ forget S2+ S2] →
  [g ⊢ eqkl T1 T2] =
/ total (injective_forget_on_labels) /
fn fg1,fg2 ⇒ case fg1 of
  | [g ⊢ fgfc (fg_fc _ _ L1 H1)] ⇒ (case fg2 of
       | [g ⊢ fgfc (fg_fc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbc (fg_bc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl])
  | [g ⊢ fgfo (fg_fo _ _ \a.H1)] ⇒ (case fg2 of
       | [g ⊢ fgfo (fg_fo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbo (fg_bo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl])
  | [g ⊢ fgbc (fg_bc _ _ L1 H1)] ⇒ (case fg2 of
       | [g ⊢ fgfc (fg_fc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbc (fg_bc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl])
  | [g ⊢ fgbo (fg_bo _ _ \a.H1)] ⇒ (case fg2 of
       | [g ⊢ fgfo (fg_fo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbo (fg_bo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl])
;

% If two CCSKP transitions s1 and s2 have the same direction, then their corresponding
% CCSK transitions forget(s1) and forget(s2) have the same direction.
rec sdir_ccskp_to_ccsk: (g:ctx) (S1+:[g ⊢ ccskp.step X1 T1+ Y1]) (S2+:[g ⊢ ccskp.step X2 T2+ Y2])
  (S1:[g ⊢ ccsk.step X1 T1 Y1]) (S2:[g ⊢ ccsk.step X2 T2 Y2]) [g ⊢ same_direction S1+ S2+]
  → [g ⊢ forget S1+ S1] → [g ⊢ forget S2+ S2] → [g ⊢ ccsk_same_direction S1 S2] =
/ total s (sdir_ccskp_to_ccsk _ _ _ _ _ _ _ _ _ s _ _ _ _ _ _) /
fn sd+,fg1,fg2 ⇒ case sd+ of
  | [g ⊢ sdf _ _] ⇒ (case fg1 of
    | [g ⊢ fgfc _] ⇒ (case fg2 of
         | [g ⊢ fgfc _] ⇒ [g ⊢ ccsk_sdf]
         | [g ⊢ fgfo _] ⇒ [g ⊢ ccsk_sdf])
    | [g ⊢ fgfo _] ⇒ (case fg2 of
         | [g ⊢ fgfc _] ⇒ [g ⊢ ccsk_sdf]
         | [g ⊢ fgfo _] ⇒ [g ⊢ ccsk_sdf]))
  | [g ⊢ sdb _ _] ⇒ (case fg1 of
    | [g ⊢ fgbc _] ⇒ (case fg2 of
         | [g ⊢ fgbc _] ⇒ [g ⊢ ccsk_sdb]
         | [g ⊢ fgbo _] ⇒ [g ⊢ ccsk_sdb])
    | [g ⊢ fgbo _] ⇒ (case fg2 of
         | [g ⊢ fgbc _] ⇒ [g ⊢ ccsk_sdb]
         | [g ⊢ fgbo _] ⇒ [g ⊢ ccsk_sdb]))
;



% Backward transitions are independent (BTI):
% Given two backward transitions sharing the same source process,
% if they are not equal, they are independent.
rec ccsk_bti: (g:ctx) {B1:[g ⊢ ccsk.bstep X T1 X1]} {B2:[g ⊢ ccsk.bstep X T2 X2]}
  ([g ⊢ eqbs B1 B2] → [g ⊢ false]) → [g ⊢ ccsk_indep_tr (bw B1) (bw B2)] =
/ total b1 (ccsk_bti _ _ _ _ _ _ b1 _ _) /
mlam B1,B2 ⇒ fn f ⇒
case total_enrich_b [_ ⊢ B1] of
  | {EN1:[g ⊢ enrich_bc _ B1+]}[g ⊢ ex_enbc EN1] ⇒ (case total_enrich_b [_ ⊢ B2] of
       | {EN2:[g ⊢ enrich_bc _ B2+]}[g ⊢ ex_enbc EN2] ⇒ 
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bc B1+] [g ⊢ bc B2+]
             (fn e ⇒ let [g ⊢ refb] = e in
             let [g ⊢ ex_fgbc FG] = total_forget_bc [g ⊢ B1+] in
             let [g ⊢ refbs] = inverse_bc_two [g ⊢ EN1] [g ⊢ FG] in
             let [g ⊢ refbs] = inverse_bc_two [g ⊢ EN2] [g ⊢ FG] in impossible f [g ⊢ refbs]) in
         [g ⊢ ccsk_ind_tr (enbc EN1) (enbc EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))]
       | {EN2:[g ⊢ enrich_bo _ B2+]}[g ⊢ ex_enbo EN2] ⇒
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bc B1+] [g ⊢ bo B2+] (fn e ⇒ impossible e) in
         [g ⊢ ccsk_ind_tr (enbc EN1) (enbo EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))])
  | {EN1:[g ⊢ enrich_bo _ B1+]}[g ⊢ ex_enbo EN1] ⇒ (case total_enrich_b [_ ⊢ B2] of
       | {EN2:[g ⊢ enrich_bc _ B2+]}[g ⊢ ex_enbc EN2] ⇒
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bo B1+] [g ⊢ bc B2+] (fn e ⇒ impossible e) in
         [g ⊢ ccsk_ind_tr (enbo EN1) (enbc EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))]
       | {EN2:[g ⊢ enrich_bo _ B2+]}[g ⊢ ex_enbo EN2] ⇒
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bo B1+] [g ⊢ bo B2+]
             (fn e ⇒ let [g ⊢ refb] = e in
             let [g ⊢ ex_fgbo FG] = total_forget_bo [g ⊢ B1+] in
             let [g ⊢ refbs] = inverse_bo_two [g ⊢ EN1] [g ⊢ FG] in
             let [g ⊢ refbs] = inverse_bo_two [g ⊢ EN2] [g ⊢ FG] in impossible f [g ⊢ refbs]) in
         [g ⊢ ccsk_ind_tr (enbo EN1) (enbo EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))])
;


% Square property (SP):
% Given two independent coinitial combined transitions,
% there exist two cofinal combined transition closing the square diagram.
rec ccsk_sp: (g:ctx) {S1:[g ⊢ ccsk.step X T1 X1]} {S2:[g ⊢ ccsk.step X T2 X2]}
  [g ⊢ ccsk_indep_tr S1 S2] → [g ⊢ ccsk_square S1 S2] =
/ total s1 (ccsk_sp _ _ _ _ _ _ s1 _ _) /
mlam S1,S2 ⇒ fn i ⇒ let [g ⊢ ccsk_ind_tr EN1 EN2 I+ (ctr _ _ S*)] = i in
let [g ⊢ _]:[g ⊢ enrich _ S1+] = [g ⊢ EN1] in
let [g ⊢ _]:[g ⊢ enrich _ S2+] = [g ⊢ EN2] in
let [g ⊢ sq S2'+ S1'+ SD1+ SD2+] = sp [g ⊢ S1+] [g ⊢ S2+] [g ⊢ ind_tr I+ (ct _ _ (ccskp.st_s* S2+))] in
let {FG2':[g ⊢ forget _ S2']}[g ⊢ ex_fg FG2'] = total_forget [g ⊢ S2'+] in
let {FG1':[g ⊢ forget _ S1']}[g ⊢ ex_fg FG1'] = total_forget [g ⊢ S1'+] in
let [g ⊢ ex_fg FG1] = total_forget [g ⊢ S1+] in
let [g ⊢ ex_fg FG2] = total_forget [g ⊢ S2+] in
let [g ⊢ refs] = inverse_two [g ⊢ EN1] [g ⊢ FG1] in
let [g ⊢ refs] = inverse_two [g ⊢ EN2] [g ⊢ FG2] in
let [g ⊢ SD1] = sdir_ccskp_to_ccsk [g ⊢ SD1+] [g ⊢ FG1] [g ⊢ FG1'] in
let [g ⊢ SD2] = sdir_ccskp_to_ccsk [g ⊢ SD2+] [g ⊢ FG2] [g ⊢ FG2'] in
let [g ⊢ refkl] = injective_forget_on_labels [g ⊢ FG1] [g ⊢ FG1'] in
let [g ⊢ refkl] = injective_forget_on_labels [g ⊢ FG2] [g ⊢ FG2'] in
[g ⊢ ccsk_sq S2' S1' SD1 SD2]
;



% Type family encoding accessibility of CCSK processes
inductive ccsk_acc: (g:ctx) [g ⊢ proc] → ctype =
  | ccsk_acc_intro: {g:ctx} {X':[g ⊢ proc]}
    ({X:[g ⊢ proc]} {KL:[g ⊢ key_lab]} [g ⊢ ccsk.fstep X KL X'] → ccsk_acc [g ⊢ X]) → ccsk_acc [g ⊢ X']
;

% If a process X is accessible w.r.t. the LTS of CCSKP, then it is accessible w.r.t. the LTS of CCSK. 
rec acc_ccskp_to_ccsk: (g:ctx) acc [g ⊢ X] → ccsk_acc [g ⊢ X] =
/ total a (acc_ccskp_to_ccsk _ _ a) /
fn a ⇒ let acc_intro [g] [g ⊢ X] h = a in
ccsk_acc_intro [g] [g ⊢ X] (mlam _,_ ⇒ fn f ⇒
  let [g ⊢ F] = f in
  (case total_enrich_f [g ⊢ F] of
     | {EN:[g ⊢ enrich_fc _ F+]}[g ⊢ ex_enfc EN] ⇒ acc_ccskp_to_ccsk (h _ _ [g ⊢ fc F+])
     | {EN:[g ⊢ enrich_fo _ F+]}[g ⊢ ex_enfo EN] ⇒ acc_ccskp_to_ccsk (h _ _ [g ⊢ fo F+])))
;

% Well-foundedness (WF): all processes are accessible
rec ccsk_wf: (g:ctx) {X:[g ⊢ proc]} ccsk_acc [g ⊢ X] =
/ total x (ccsk_wf _ x) /
mlam X ⇒ acc_ccskp_to_ccsk (wf [_ ⊢ X])
;