%%% BTI: backward transitions are independent

% Auxiliary lemmas

% If a key K does not occur in a process, and such process makes a backward closed transition
% labelled by T, then K is different from key(T).
rec key_in_bstep_cl: (g:ctx) [g ⊢ notin K[] X] → [g ⊢ bstep_cl X T Y] → [g ⊢ key T M[]] → [g ⊢ neq K[] M[]] =
/ total n (key_in_bstep_cl _ _ _ _ _ _ n _ _) /
fn n,b,h ⇒ case n of
  | [g ⊢ not_null] ⇒ impossible b
  | [g ⊢ not_pref N] ⇒ impossible b
  | [g ⊢ not_kpref I N] ⇒ (case b of
       | [g ⊢ bc_pref _] ⇒ let [g ⊢ key_base] = h in [g ⊢ I]
       | [g ⊢ bc_kpref B H _] ⇒ let [g ⊢ H'] = h in
         let [g ⊢ refky] = unique_key [g ⊢ H] [g ⊢ H'] in 
         key_in_bstep_cl [g ⊢ N] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_sum N1 N2] ⇒ (case b of
       | [g ⊢ bc_suml B _] ⇒ let [g ⊢ key_suml H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_sumr B _] ⇒ let [g ⊢ key_sumr H] = h in key_in_bstep_cl [g ⊢ N2] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_par N1 N2] ⇒ (case b of
       | [g ⊢ bc_parl B _ _] ⇒ let [g ⊢ key_parl H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_parr B _ _] ⇒ let [g ⊢ key_parr H] = h in key_in_bstep_cl [g ⊢ N2] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_synl B _ _ _ _ _] ⇒ let [g ⊢ key_sync H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H]
       | [g ⊢ bc_synr B _ _ _ _ _] ⇒ let [g ⊢ key_sync H] = h in key_in_bstep_cl [g ⊢ N1] [g ⊢ B] [g ⊢ H])
  | [g ⊢ not_nu \a.N] ⇒ let [g ⊢ bc_nu \a.B] = b in
    let [g ⊢ H] = h in 
    let [g,a:names ⊢ I[..]] = key_in_bstep_cl [_ ⊢ N] [_ ⊢ B] [_ ⊢ H[..]] in [g ⊢ I]
;

% Given two independent valid closed proof labels, their keys are different.
rec indep_impl_diff_keys: (g:ctx) [g ⊢ valid_cl T1] → [g ⊢ valid_cl T2]
  → [g ⊢ indep_cl T1 T2] → [g ⊢ key T1 K1[]] → [g ⊢ key T2 K2[]] → [g ⊢ neq K1[] K2[]] =
/ total i (indep_impl_diff_keys _ _ _ _ _ _ _ i _ _) /
fn v1,v2,i,h1,h2 ⇒ case i of
  | [g ⊢ i_c1l I] ⇒ let [g ⊢ v_suml V1] = v1 in
    let [g ⊢ v_suml V2] = v2 in
    let [g ⊢ key_suml H1] = h1 in
    let [g ⊢ key_suml H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_c1r I] ⇒ let [g ⊢ v_sumr V1] = v1 in
    let [g ⊢ v_sumr V2] = v2 in
    let [g ⊢ key_sumr H1] = h1 in
    let [g ⊢ key_sumr H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_p1l I] ⇒ let [g ⊢ v_parl V1] = v1 in
    let [g ⊢ v_parl V2] = v2 in
    let [g ⊢ key_parl H1] = h1 in
    let [g ⊢ key_parl H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_p1r I] ⇒ let [g ⊢ v_parr V1] = v1 in
    let [g ⊢ v_parr V2] = v2 in
    let [g ⊢ key_parr H1] = h1 in
    let [g ⊢ key_parr H2] = h2 in indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ i_p2l H1 H2 N] ⇒ let [g ⊢ key_parl H1'] = h1 in
    let [g ⊢ key_parr H2'] = h2 in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in [g ⊢ N]
  | [g ⊢ i_p2r H1 H2 N] ⇒ let [g ⊢ key_parr H1'] = h1 in
    let [g ⊢ key_parl H2'] = h2 in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in [g ⊢ N]
  | [g ⊢ i_s1l I] ⇒ let [g ⊢ key_parl H1] = h1 in
    let [g ⊢ key_sync H2] = h2 in
    let [g ⊢ v_parl V1] = v1 in
    (case v2 of
       | [g ⊢ v_synl V2 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
       | [g ⊢ v_synr V2 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2])
  | [g ⊢ i_s1r I] ⇒ let [g ⊢ key_parr H1] = h1 in
    let [g ⊢ key_sync H2] = h2 in
    let [g ⊢ v_parr V1] = v1 in
    (case v2 of
       | [g ⊢ v_synl _ V2 _ HL2 _ HR2] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL2] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ HR2]
       | [g ⊢ v_synr _ V2 _ HL2 _ HR2] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL2] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ HR2])
  | [g ⊢ i_s2l I] ⇒ let [g ⊢ key_sync H1] = h1 in
    let [g ⊢ key_parl H2] = h2 in
    let [g ⊢ v_parl V2] = v2 in
    (case v1 of
       | [g ⊢ v_synl V1 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2]
       | [g ⊢ v_synr V1 _ _ _ _ _] ⇒ indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ H1] [g ⊢ H2])
  | [g ⊢ i_s2r I] ⇒ let [g ⊢ key_sync H1] = h1 in
    let [g ⊢ key_parr H2] = h2 in
    let [g ⊢ v_parr V2] = v2 in
    (case v1 of
       | [g ⊢ v_synl _ V1 _ HL1 _ HR1] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL1] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ HR1] [g ⊢ H2]
       | [g ⊢ v_synr _ V1 _ HL1 _ HR1] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL1] in
         indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I] [g ⊢ HR1] [g ⊢ H2])
  | [g ⊢ i_s3 I1 I2] ⇒ let [g ⊢ key_sync H1] = h1 in
    let [g ⊢ key_sync H2] = h2 in 
    (case v1 of
       | [g ⊢ v_synl VL1 VR1 _ HL1 _ HR1] ⇒ (case v2 of
            | [g ⊢ v_synl VL2 VR2 _ HL2 _ HR2] ⇒
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2]
            | [g ⊢ v_synr VL2 VR2 _ HL2 _ HR2] ⇒ 
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2])
       | [g ⊢ v_synr VL1 VR1 _ HL1 _ HR1] ⇒ (case v2 of
            | [g ⊢ v_synl VL2 VR2 _ HL2 _ HR2] ⇒
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2]
            | [g ⊢ v_synr VL2 VR2 _ HL2 _ HR2] ⇒
              indep_impl_diff_keys [g ⊢ VL1] [g ⊢ VL2] [g ⊢ I1] [g ⊢ H1] [g ⊢ H2]))
;

% Strengthening lemma for indep_cl 
rec str_indep: (g:ctx) [g,a:names ⊢ indep_cl T1[..] T2[..]] → [g ⊢ indep_cl T1 T2] =
/ total i (str_indep _ _ _ i) /
fn i ⇒ case i of
  | [g,a:names ⊢ i_c1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_c1l I']
  | [g,a:names ⊢ i_c1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_c1r I']
  | [g,a:names ⊢ i_p1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_p1l I']
  | [g,a:names ⊢ i_p1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_p1r I']
  | [g,a:names ⊢ i_p2l H1 H2 N[..]] ⇒ let [g ⊢ H1'] = str_key [_ ⊢ H1] in
     let [g ⊢ H2'] = str_key [_ ⊢ H2] in [g ⊢ i_p2l H1' H2' N]
  | [g,a:names ⊢ i_p2r H1 H2 N[..]] ⇒ let [g ⊢ H1'] = str_key [_ ⊢ H1] in
     let [g ⊢ H2'] = str_key [_ ⊢ H2] in [g ⊢ i_p2r H1' H2' N]
  | [g,a:names ⊢ i_s1l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s1l I']
  | [g,a:names ⊢ i_s1r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s1r I']
  | [g,a:names ⊢ i_s2l I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s2l I']
  | [g,a:names ⊢ i_s2r I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in [g ⊢ i_s2r I']
  | [g,a:names ⊢ i_s3 I1 I2] ⇒ let [g ⊢ I1'] = str_indep [_ ⊢ I1] in
    let [g ⊢ I2'] = str_indep [_ ⊢ I2] in [g ⊢ i_s3 I1' I2']
;



% Given two backward closed transitions B1 and B2, id_or_bti B1 B2 holds iff
% either B1=B2, or their proof labels are independent. 
LF id_or_bti_cc: bstep_cl X T1 X1 → bstep_cl X T2 X2 → type =
  | id_cc: eqbc B1 B2 → id_or_bti_cc B1 B2
  | ind_cc: {B1:bstep_cl X T1 X1}{B2: bstep_cl X T2 X2} indep_cl T1 T2 
          → id_or_bti_cc B1 B2
;

% BTI for backward closed transitions:
% Given two backward closed transitions sharing the same source process,
% they are either equal or their proof labels are independent.
rec bti_cc: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {B2:[g ⊢ bstep_cl X T2 X2]}
  [g ⊢ id_or_bti_cc B1 B2] =
/ total b1 (bti_cc _ _ _ _ _ _ b1 _) /
mlam B1,B2 ⇒ case [_ ⊢ B1] of
  | [g ⊢ bc_pref D1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ id_cc refbc]
       | [g ⊢ bc_kpref B2' _ _] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_kpref B1' H1 I1] ⇒
    (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ impossible source_is_not_std_bc [g ⊢ B1'] [g ⊢ D2]
       | [g ⊢ bc_kpref B2' H2 I2] ⇒ 
         (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let refnq [g ⊢ _] = unique_neq [g ⊢ I1] [g ⊢ I2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ I]))
  | [g ⊢ bc_suml B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_c1l I)])
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1])
  | [g ⊢ bc_sumr B1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible source_is_not_std_bc [g ⊢ B2'] [g ⊢ D1]
       | [g ⊢ bc_sumr B2' D2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refsd] = unique_std [g ⊢ D1] [g ⊢ D2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_c1r I)]))
  | [g ⊢ bc_parl B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_p1l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ ind_cc _ _ (i_p2l H1 H2 N)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1l I)])
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BR2] [g ⊢ HR2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HL2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1l I)]))
  | [g ⊢ bc_parr B1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ B2'] [g ⊢ H2] in
              [g ⊢ ind_cc _ _ (i_p2r H1 H2 N)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ refky] = unique_key [g ⊢ H1] [g ⊢ H2] in
              let [g ⊢ refn] = unique_notin [g ⊢ N1] [g ⊢ N2] in [g ⊢ id_cc refbc]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_p1r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1r I)])
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ B1'] [g ⊢ BR2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N1] [g ⊢ BL2] [g ⊢ HL2] in
              let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ HR2] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s1r I)]))
  | [g ⊢ bc_synl BL1 LL1 HL1 BR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BR1] [g ⊢ HR1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s2l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BL1] [g ⊢ HL1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s2r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LL1] [g ⊢ LL2] in
              let [g ⊢ refky] = unique_key [g ⊢ HL1] [g ⊢ HL2] in
              (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   [g ⊢ id_cc refbc]
                 | [g ⊢ ind_cc _ _ I2] ⇒ let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BR1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BR2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I2] [g ⊢ HR1] [g ⊢ HR2] in
                   impossible irreflexive_neq [g ⊢ N])
            | [g ⊢ ind_cc _ _ I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BL1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BL2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I1] [g ⊢ HL1] [g ⊢ HL2] in
                   impossible irreflexive_neq [g ⊢ N]
                 | [g ⊢ ind_cc _ _ I2] ⇒ [g ⊢ ind_cc _ _ (i_s3 I1 I2)]))
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ impossible unique_lab [g ⊢ LL1] [g ⊢ LL2]
            | [g ⊢ ind_cc _ _ I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ impossible unique_lab [g ⊢ LR1] [g ⊢ LR2]
                 | [g ⊢ ind_cc _ _ I2] ⇒ [g ⊢ ind_cc _ _ (i_s3 I1 I2)])))
  | [g ⊢ bc_synr BL1 LL1 HL1 BR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BR1] [g ⊢ HR1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s2l I)])
       | [g ⊢ bc_parr B2' H2 N2] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ B2'] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ N] = key_in_bstep_cl [g ⊢ N2] [g ⊢ BL1] [g ⊢ HL1] in
              let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR1] in impossible irreflexive_neq [g ⊢ N]
            | [g ⊢ ind_cc _ _ I] ⇒ [g ⊢ ind_cc _ _ (i_s2r I)])
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ impossible unique_lab [g ⊢ LL1] [g ⊢ LL2]
            | [g ⊢ ind_cc _ _ I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ impossible unique_lab [g ⊢ LR1] [g ⊢ LR2]
                 | [g ⊢ ind_cc _ _ I2] ⇒ [g ⊢ ind_cc _ _ (i_s3 I1 I2)]))
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ (case bti_cc [g ⊢ BL1] [g ⊢ BL2] of
            | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LL1] [g ⊢ LL2] in
              let [g ⊢ refky] = unique_key [g ⊢ HL1] [g ⊢ HL2] in
              (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   [g ⊢ id_cc refbc]
                 | [g ⊢ ind_cc _ _ I2] ⇒ let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BR1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BR2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I2] [g ⊢ HR1] [g ⊢ HR2] in
                   impossible irreflexive_neq [g ⊢ N])
            | [g ⊢ ind_cc _ _ I1] ⇒ (case bti_cc [g ⊢ BR1] [g ⊢ BR2] of
                 | [g ⊢ id_cc refbc] ⇒ let [g ⊢ reflb] = unique_lab [g ⊢ LR1] [g ⊢ LR2] in
                   let [g ⊢ refky] = unique_key [g ⊢ HR1] [g ⊢ HR2] in
                   let [g ⊢ V1] = valid_in_bstep_cl [g ⊢ BL1] in 
                   let [g ⊢ V2] = valid_in_bstep_cl [g ⊢ BL2] in
                   let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I1] [g ⊢ HL1] [g ⊢ HL2] in
                   impossible irreflexive_neq [g ⊢ N]
                 | [g ⊢ ind_cc _ _ I2] ⇒ [g ⊢ ind_cc _ _ (i_s3 I1 I2)])))
  | [g ⊢ bc_nu \a.B1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in 
    (case bti_cc [_ ⊢ B1'] [_ ⊢ B2'] of
            | [g,a:names ⊢ id_cc refbc] ⇒ [g ⊢ id_cc refbc]
            | [g,a:names ⊢ ind_cc _ _ I] ⇒ let [g ⊢ I'] = str_indep [_ ⊢ I] in
                                            [g ⊢ ind_cc _ _ I'])
;

