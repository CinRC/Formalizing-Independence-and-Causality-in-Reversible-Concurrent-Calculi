%%% Uniqueness results for CCSKP %%%

--open ccskp.

% Existential type denoting existence of a label in a proof keyed label
LF ex_lab: pr_lab → type =
  | ex_l: lab T A → ex_lab T
;

% Proof of existence of a label in a proof keyed label
rec existence_of_lab: (g:ctx) {T:[g ⊢ pr_lab]} [g ⊢ ex_lab T] =
/ total t (existence_of_lab _ t) /
mlam T ⇒ case [_ ⊢ T] of
  | [g ⊢ pr_base _ _] ⇒ [g ⊢ ex_l lab_base]
  | [g ⊢ pr_suml T'] ⇒ let [g ⊢ ex_l L] = existence_of_lab [g ⊢ T'] in [g ⊢ ex_l (lab_suml L)]
  | [g ⊢ pr_sumr T'] ⇒ let [g ⊢ ex_l L] = existence_of_lab [g ⊢ T'] in [g ⊢ ex_l (lab_sumr L)]
  | [g ⊢ pr_parl T'] ⇒ let [g ⊢ ex_l L] = existence_of_lab [g ⊢ T'] in [g ⊢ ex_l (lab_parl L)]
  | [g ⊢ pr_parr T'] ⇒ let [g ⊢ ex_l L] = existence_of_lab [g ⊢ T'] in [g ⊢ ex_l (lab_parr L)]
  | [g ⊢ pr_sync _ _] ⇒ [g ⊢ ex_l lab_sync]
;

% Proof of uniqueness of a label in a proof keyed label
rec uniqueness_of_lab: (g:ctx) [g ⊢ lab T A] → [g ⊢ lab T B] → [g ⊢ eql A B] =
/ total l1 (uniqueness_of_lab _ _ _ _ l1 _) /
fn l1,l2 ⇒ case l1 of
  | [g ⊢ lab_base] ⇒ let [g ⊢ lab_base] = l2 in [g ⊢ refl]
  | [g ⊢ lab_suml L1] ⇒ let [g ⊢ lab_suml L2] = l2 in uniqueness_of_lab [g ⊢ L1] [g ⊢ L2]
  | [g ⊢ lab_sumr L1] ⇒ let [g ⊢ lab_sumr L2] = l2 in uniqueness_of_lab [g ⊢ L1] [g ⊢ L2]
  | [g ⊢ lab_parl L1] ⇒ let [g ⊢ lab_parl L2] = l2 in uniqueness_of_lab [g ⊢ L1] [g ⊢ L2]
  | [g ⊢ lab_parr L1] ⇒ let [g ⊢ lab_parr L2] = l2 in uniqueness_of_lab [g ⊢ L1] [g ⊢ L2]
  | [g ⊢ lab_sync] ⇒ let [g ⊢ lab_sync] = l2 in [g ⊢ refl]
;

% Existential type denoting existence of a key in a proof keyed label
LF ex_key: pr_lab → type =
  | ex_k: key T K → ex_key T
;

% Proof of existence of a key in a proof keyed label
rec existence_of_key: (g:ctx) {T:[g ⊢ pr_lab]} [g ⊢ ex_key T] =
/ total t (existence_of_key _ t) /
mlam T ⇒ case [_ ⊢ T] of
  | [g ⊢ pr_base _ _] ⇒ [g ⊢ ex_k key_base]
  | [g ⊢ pr_suml T'] ⇒ let [g ⊢ ex_k H] = existence_of_key [g ⊢ T'] in [g ⊢ ex_k (key_suml H)]
  | [g ⊢ pr_sumr T'] ⇒ let [g ⊢ ex_k H] = existence_of_key [g ⊢ T'] in [g ⊢ ex_k (key_sumr H)]
  | [g ⊢ pr_parl T'] ⇒ let [g ⊢ ex_k H] = existence_of_key [g ⊢ T'] in [g ⊢ ex_k (key_parl H)]
  | [g ⊢ pr_parr T'] ⇒ let [g ⊢ ex_k H] = existence_of_key [g ⊢ T'] in [g ⊢ ex_k (key_parr H)]
  | [g ⊢ pr_sync T' _] ⇒ let [g ⊢ ex_k H] = existence_of_key [g ⊢ T'] in [g ⊢ ex_k (key_sync H)]
;

% Proof of uniqueness of a key in a proof keyed label
rec uniqueness_of_key: (g:ctx) [g ⊢ key T K[]] → [g ⊢ key T M[]] → [g ⊢ eqk K[] M[]] =
/ total h1 (uniqueness_of_key _ _ _ _ h1 _) /
fn h1,h2 ⇒ case h1 of
  | [g ⊢ key_base] ⇒ let [g ⊢ key_base] = h2 in [g ⊢ refk]
  | [g ⊢ key_suml H1] ⇒ let [g ⊢ key_suml H2] = h2 in uniqueness_of_key [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ key_sumr H1] ⇒ let [g ⊢ key_sumr H2] = h2 in uniqueness_of_key [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ key_parl H1] ⇒ let [g ⊢ key_parl H2] = h2 in uniqueness_of_key [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ key_parr H1] ⇒ let [g ⊢ key_parr H2] = h2 in uniqueness_of_key [g ⊢ H1] [g ⊢ H2]
  | [g ⊢ key_sync H1] ⇒ let [g ⊢ key_sync H2] = h2 in uniqueness_of_key [g ⊢ H1] [g ⊢ H2]
;

% Equality of derivations of lab T A
LF eqlb: lab T1 A1 → lab T2 A2 → type =
  | reflb: eqlb L L
;

% Uniqueness of the derivation of std X
rec unique_lab: (g:ctx) {L1:[g ⊢ lab T A1]} {L2:[g ⊢ lab T A2]} [g ⊢ eqlb L1 L2] =
/ total l1 (unique_lab _ _ _ _ l1 _) /
mlam L1 L2 ⇒ case [_ ⊢ L1] of
  | [g ⊢ lab_base] ⇒ let [g ⊢ lab_base] = [g ⊢ L2] in [g ⊢ reflb]
  | [g ⊢ lab_suml L1'] ⇒ let [g ⊢ lab_suml L2'] = [g ⊢ L2] in
    let [g ⊢ reflb] = unique_lab [g ⊢ L1'] [g ⊢ L2'] in [g ⊢ reflb]
  | [g ⊢ lab_sumr L1'] ⇒ let [g ⊢ lab_sumr L2'] = [g ⊢ L2] in
    let [g ⊢ reflb] = unique_lab [g ⊢ L1'] [g ⊢ L2'] in [g ⊢ reflb]
  | [g ⊢ lab_parl L1'] ⇒ let [g ⊢ lab_parl L2'] = [g ⊢ L2] in
    let [g ⊢ reflb] = unique_lab [g ⊢ L1'] [g ⊢ L2'] in [g ⊢ reflb]
  | [g ⊢ lab_parr L1'] ⇒ let [g ⊢ lab_parr L2'] = [g ⊢ L2] in
    let [g ⊢ reflb] = unique_lab [g ⊢ L1'] [g ⊢ L2'] in [g ⊢ reflb]
  | [g ⊢ lab_sync] ⇒ let [g ⊢ lab_sync] = [g ⊢ L2] in [g ⊢ reflb]
;

% Equality of derivations of key T K
LF eqky: key T1 K1 → key T2 K2 → type =
  | refky: eqky H H
;

% Uniqueness of the derivation of key T K
rec unique_key: (g:ctx) {H1:[g ⊢ key T K1[]]} {H2:[g ⊢ key T K2[]]} [g ⊢ eqky H1 H2] =
/ total h1 (unique_key _ _ _ _ h1 _) /
mlam H1 H2 ⇒ case [_ ⊢ H1] of
  | [g ⊢ key_base] ⇒ let [g ⊢ key_base] = [g ⊢ H2] in [g ⊢ refky]
  | [g ⊢ key_suml H1'] ⇒ let [g ⊢ key_suml H2'] = [g ⊢ H2] in
    let [g ⊢ refky] = unique_key [g ⊢ H1'] [g ⊢ H2'] in [g ⊢ refky]
  | [g ⊢ key_sumr H1'] ⇒ let [g ⊢ key_sumr H2'] = [g ⊢ H2] in
    let [g ⊢ refky] = unique_key [g ⊢ H1'] [g ⊢ H2'] in [g ⊢ refky]
  | [g ⊢ key_parl H1'] ⇒ let [g ⊢ key_parl H2'] = [g ⊢ H2] in
    let [g ⊢ refky] = unique_key [g ⊢ H1'] [g ⊢ H2'] in [g ⊢ refky]
  | [g ⊢ key_parr H1'] ⇒ let [g ⊢ key_parr H2'] = [g ⊢ H2] in
    let [g ⊢ refky] = unique_key [g ⊢ H1'] [g ⊢ H2'] in [g ⊢ refky]
  | [g ⊢ key_sync H1'] ⇒ let [g ⊢ key_sync H2'] = [g ⊢ H2] in
    let [g ⊢ refky] = unique_key [g ⊢ H1'] [g ⊢ H2'] in [g ⊢ refky]
;

% Equality of derivations of occurs A T
LF eqoc: occurs A1 T1 → occurs A2 T2 → type =
  | refoc: eqoc O O
;

% Uniqueness of the derivation of occurs A T
rec unique_occ: (g:ctx) {O1:[g ⊢ occurs A1 T]} {O2:[g ⊢ occurs A2 T]} [g ⊢ eqoc O1 O2] =
/ total o1 (unique_occ _ _ _ _ o1 _) /
mlam O1 O2 ⇒ case [_ ⊢ O1] of
  | [g ⊢ occ_basel] ⇒ let [g ⊢ occ_basel] = [g ⊢ O2] in [g ⊢ refoc]
  | [g ⊢ occ_baser] ⇒ let [g ⊢ occ_baser] = [g ⊢ O2] in [g ⊢ refoc]
  | [g ⊢ occ_suml O1'] ⇒ let [g ⊢ occ_suml O2'] = [g ⊢ O2] in
    let [g ⊢ refoc] = unique_occ [g ⊢ O1'] [g ⊢ O2'] in [g ⊢ refoc]
  | [g ⊢ occ_sumr O1'] ⇒ let [g ⊢ occ_sumr O2'] = [g ⊢ O2] in
    let [g ⊢ refoc] = unique_occ [g ⊢ O1'] [g ⊢ O2'] in [g ⊢ refoc]
  | [g ⊢ occ_parl O1'] ⇒ let [g ⊢ occ_parl O2'] = [g ⊢ O2] in
    let [g ⊢ refoc] = unique_occ [g ⊢ O1'] [g ⊢ O2'] in [g ⊢ refoc]
  | [g ⊢ occ_parr O1'] ⇒ let [g ⊢ occ_parr O2'] = [g ⊢ O2] in
    let [g ⊢ refoc] = unique_occ [g ⊢ O1'] [g ⊢ O2'] in [g ⊢ refoc]
  | [g ⊢ occ_sync O1'] ⇒ let [g ⊢ occ_sync O2'] = [g ⊢ O2] in 
    let [g ⊢ refoc] = unique_occ [g ⊢ O1'] [g ⊢ O2'] in [g ⊢ refoc]
;