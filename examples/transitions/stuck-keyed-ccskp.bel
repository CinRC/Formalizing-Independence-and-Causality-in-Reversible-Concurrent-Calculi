%%% Proof that stuck processes containing keys do not make any transition %%%

--open ccskp.

% Auxiliary lemmas
rec irreflexive_less: (g:ctx) [g ⊢ less K[] K[]] → [⊢ false] =
/ total 1 /
fn l ⇒ let [g ⊢ lsucc L] = l in irreflexive_less [g ⊢ L]
;

rec irreflexive_neq: (g:ctx) [g ⊢ neq K[] K[]] → [⊢ false] =
/ total 1 /
fn i ⇒ case i of
  | [g ⊢ nless L] ⇒ irreflexive_less [g ⊢ L]
  | [g ⊢ ngreat L] ⇒ irreflexive_less [g ⊢ L]
;


% For the first process a[k] | b[k], we prove that it is stuck w.r.t. both forward and backward, both closed and open transition.
% For the following processes, we will omit the proof for the trivial types of transitions.

% a[k] | b[k] does not make any forward closed transition.
rec stuck_p1_fclosed: (g:ctx) [g ⊢ fstep_closed (par (kpref (inp a) k null) (kpref (inp b) k null)) T X'] → [⊢ false] =
/ total 1 /
fn f ⇒ case f of
  | [g ⊢ fc_parl F _ _] ⇒ let [g ⊢ fc_kpref F1 _ _] = [g ⊢ F] in impossible [g ⊢ F1]
  | [g ⊢ fc_parr F _ _] ⇒ let [g ⊢ fc_kpref F1 _ _] = [g ⊢ F] in impossible [g ⊢ F1]
  | [g ⊢ fc_synl F _ _ _ _ _] ⇒ let [g ⊢ fc_kpref F1 _ _] = [g ⊢ F] in impossible [g ⊢ F1]
  | [g ⊢ fc_synr F _ _ _ _ _] ⇒ let [g ⊢ fc_kpref F1 _ _] = [g ⊢ F] in impossible [g ⊢ F1]
;

% a[k] | b[k] does not make any forward open transition.
rec stuck_p1_fopen: (g:ctx) [g ⊢ fstep_open (par (kpref (inp a) k null) (kpref (inp b) k null)) T X'] → [⊢ false] =
/ total 1 /
fn f ⇒ case f of
  | [g ⊢ fo_parl F (\_._) _] ⇒ let [g ⊢ fo_kpref F1 (\_._) _] = [g ⊢ F] in impossible [g ⊢ F1]
  | [g ⊢ fo_parr F (\_._) _] ⇒ let [g ⊢ fo_kpref F1 (\_._) _] = [g ⊢ F] in impossible [g ⊢ F1]
;

% a[k] | b[k] does not make any backward closed transition.
rec stuck_p1_bclosed: (g:ctx) [g ⊢ bstep_closed (par (kpref (inp a) k null) (kpref (inp b) k null)) T X'] → [⊢ false] =
/ total 1 /
fn b ⇒ case b of
  | [g ⊢ bc_parl B H N] ⇒ let [g ⊢ bc_pref D] = [g ⊢ B] in
                           let [g ⊢ key_base] = [g ⊢ H] in
						   let [g ⊢ not_kpref I N1] = [g ⊢ N] in impossible irreflexive_neq [g ⊢ I]
  | [g ⊢ bc_parr B H N] ⇒ let [g ⊢ bc_pref D] = [g ⊢ B] in
                           let [g ⊢ key_base] = [g ⊢ H] in
						   let [g ⊢ not_kpref I N1] = [g ⊢ N] in impossible irreflexive_neq [g ⊢ I]
  | [g ⊢ bc_synl _ _ _ BR LR _] ⇒ let [g ⊢ bc_pref _] = [g ⊢ BR] in impossible [g ⊢ LR]
  | [g ⊢ bc_synr BL LL _ _ _ _] ⇒ let [g ⊢ bc_pref _] = [g ⊢ BL] in impossible [g ⊢ LL]
;

% a[k] | b[k] does not make any backward open transition.
rec stuck_p1_bopen: (g:ctx) [g ⊢ bstep_open (par (kpref (inp a) k null) (kpref (inp b) k null)) T X'] → [⊢ false] =
/ total 1 /
fn b ⇒ case b of
  | [g ⊢ bo_parl B (\a.H) N] ⇒ let [g ⊢ bo_kpref B1 (\_._) _] = [g ⊢ B] in impossible [g ⊢ B1]
  | [g ⊢ bo_parr B (\a.H) N] ⇒ let [g ⊢ bo_kpref B1 (\_._) _] = [g ⊢ B] in impossible [g ⊢ B1]
;


% a[k] + b[m] does not make any backward closed transition.
rec stuck_p2: (g:ctx) [g ⊢ bstep_closed (sum (kpref (inp a) k null) (kpref (inp b) m null)) T X'] → [⊢ false] =
/ total 1 /
fn b ⇒ case b of
  | [g ⊢ bc_suml _ D] ⇒ impossible [g ⊢ D]
  | [g ⊢ bc_sumr _ D] ⇒ impossible [g ⊢ D]
;


% a.b[k] does not make any forward closed transition.
rec stuck_p3_forward: (g:ctx) [g ⊢ fstep_closed (pref (inp a) (kpref (inp b) k null)) T X'] → [⊢ false] =
/ total 1 /
fn f ⇒ let [g ⊢ fc_pref D] = f in impossible [g ⊢ D]
;

% a.b[k] does not make any backward closed transition.
rec stuck_p3_backward: (g:ctx) [g ⊢ bstep_closed (pref (inp a) (kpref (inp b) k null)) T X'] → [⊢ false] =
/ total 1 /
fn b ⇒ impossible b
;


% a[k].b[m] | b'[m].a'[k] does not make any backward closed transition.
rec stuck_p4: (g:ctx) [g ⊢ neq k m] → [g ⊢ bstep_closed (par (kpref (inp a) k (kpref (inp b) m null)) (kpref (out b) m (kpref (out a) k null))) T X'] → [⊢ false] =
/ total 1 /
fn i,b ⇒ case b of
  | [g ⊢ bc_parl B H N] ⇒
    let [g ⊢ bc_kpref (bc_pref _) _ _] = [g ⊢ B] in
    let [g ⊢ key_base] = [g ⊢ H] in
    let [g ⊢ not_kpref I _] = [g ⊢ N] in impossible irreflexive_neq [g ⊢ I]
  | [g ⊢ bc_parr B H N] ⇒ 
    let [g ⊢ bc_kpref (bc_pref _) _ _] = [g ⊢ B] in
    let [g ⊢ key_base] = [g ⊢ H] in
    let [g ⊢ not_kpref I _] = [g ⊢ N] in impossible irreflexive_neq [g ⊢ I]
  | [g ⊢ bc_synl BL _ HL BR _ HR] ⇒ 
    let [g ⊢ bc_kpref (bc_pref _) _ _] = [g ⊢ BL] in
    let [g ⊢ bc_kpref (bc_pref _) _ _] = [g ⊢ BR] in
    let [g ⊢ key_base] = [g ⊢ HL] in
    let [g ⊢ key_base] = [g ⊢ HR] in impossible irreflexive_neq i
  | [g ⊢ bc_synr BL _ HL BR _ HR] ⇒ 
    let [g ⊢ bc_kpref (bc_pref _) _ _] = [g ⊢ BL] in
    let [g ⊢ bc_kpref (bc_pref _) _ _] = [g ⊢ BR] in
    let [g ⊢ key_base] = [g ⊢ HL] in
    let [g ⊢ key_base] = [g ⊢ HR] in impossible irreflexive_neq i
;


% (a[k])\a does not make any backward closed transition.
rec stuck_p5: (g:ctx) [g ⊢ bstep_closed (nu \a.(kpref (inp a) k null)) T X'] → [⊢ false] =
/ total 1 /
fn b ⇒ let [g ⊢ bc_nu \a.B] = b in
let [g,a:names ⊢ bc_kpref B1 _ _] = [g,a:names ⊢ B] in
impossible [g,a:names ⊢ B1]
;