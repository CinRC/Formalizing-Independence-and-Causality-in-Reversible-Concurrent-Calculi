%%% WF: well-foundedness

% Test: accessibility of natural numbers (keys)

% Less or equal
LF leq: keys → keys → type =
  | l_eq: leq M M
  | l_ls: less M N → leq M N
;

% Auxiliary lemma: if M < s(N), then M <= N
rec less_impl_leq: [⊢ less M (s N)] → [⊢ leq M N] =
/ total l (less_impl_leq _ _ l) /
fn l ⇒ case l of
  | [⊢ lzero N] ⇒ (case dec_eq_keys [] [⊢ z] [⊢ N] of
       | [⊢ c_eq] ⇒ [⊢ l_eq]
       | [⊢ c_neq (nless L)] ⇒ [⊢ l_ls L]
       | [⊢ c_neq (ngreat L)] ⇒ impossible [⊢ L])
  | [⊢ lsucc L]:[⊢ less (s M) (s N)] ⇒ (case [⊢ N] of
       | [⊢ z] ⇒ impossible [⊢ L]
       | [⊢ s N'] ⇒ (case less_impl_leq [⊢ L] of
            | [⊢ l_eq] ⇒ [⊢ l_eq]
            | [⊢ l_ls L'] ⇒ [⊢ l_ls (lsucc L')]))
;

% Accessibility of natural numbers
inductive acc_nat: [⊢ keys] → ctype =
  | acc_intro_nat: {N:[⊢ keys]} ({M:[⊢ keys]} [⊢ less M N] → acc_nat [⊢ M]) → acc_nat [⊢ N]
;

% Well-foundedness of natural numbers: all numbers are accessible
rec wf_nat: {N:[⊢ keys]} acc_nat [⊢ N] =
/ total n (wf_nat n) /
mlam N ⇒ case [⊢ N] of
  | [⊢ z] ⇒ acc_intro_nat [⊢ z] (mlam M ⇒ fn l ⇒ impossible l)
  | [⊢ s N'] ⇒ acc_intro_nat [⊢ s N'] (mlam M ⇒ fn l ⇒
    (case less_impl_leq l of
       | [⊢ l_eq] ⇒ wf_nat [⊢ N']
       | [⊢ l_ls L'] ⇒ let acc_intro_nat [⊢ N'] a = wf_nat [⊢ N'] in a [⊢ M] [⊢ L']))
;


% Accessibility of CCSKP processes
inductive acc: (g:ctx) [g ⊢ proc] → ctype =
  | acc_intro: {g:ctx} {X':[g ⊢ proc]}
    ({X:[g ⊢ proc]} {T:[g ⊢ pr_lab]} [g ⊢ fstep X T X'] → acc [g ⊢ X]) → acc [g ⊢ X']
;

% If X is accessible, then A[K].X is accessible
rec wf_kpref: (g:ctx) {A:[g ⊢ labels]} {K:[⊢ keys]} acc [g ⊢ X] → acc [g ⊢ kpref A K[] X] =
/ total a (wf_kpref _ _ _ _ a) /
mlam A,K ⇒ fn a ⇒ let acc_intro [g] [g ⊢ X] h = a in
acc_intro [g] [g ⊢ kpref A K[] X] (mlam Y,T ⇒ fn f ⇒ (case f of 
       | [g ⊢ fc (fc_pref _)] ⇒ acc_intro [g] [_ ⊢ pref A X] (mlam _,_ ⇒ fn f' ⇒
         (case f' of
            | [g ⊢ fc F'] ⇒ impossible [g ⊢ F']
            | [g ⊢ fo F'] ⇒ impossible [g ⊢ F']))
       | [g ⊢ fc (fc_kpref F _ _)] ⇒ wf_kpref [_ ⊢ _] [_ ⊢ _] (h [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F])
       | [g ⊢ fo (fo_kpref F (\_._) _)] ⇒ wf_kpref [_ ⊢ _] [_ ⊢ _] (h [_ ⊢ _] [_ ⊢ _] [_ ⊢ fo F])))
;

% If X1 and X2 are accessible, then X1+X2 is accessible
rec wf_sum: (g:ctx) acc [g ⊢ X1] → acc [g ⊢ X2] → acc [g ⊢ sum X1 X2] =
/ total {a1 a2} (wf_sum _ _ _ a1 a2) /
fn a1,a2 ⇒ let acc_intro [g] [g ⊢ X1] h1 = a1 in
let acc_intro [g] [g ⊢ X2] h2 = a2 in
acc_intro [g] [g ⊢ sum X1 X2] (mlam _,_ ⇒ fn f ⇒ (case f of
       | [g ⊢ fc (fc_suml F _)] ⇒ wf_sum (h1 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F]) a2
       | [g ⊢ fc (fc_sumr F _)] ⇒ wf_sum a1 (h2 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F])
       | [g ⊢ fo (fo_suml F _)] ⇒ wf_sum (h1 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fo F]) a2
       | [g ⊢ fo (fo_sumr F _)] ⇒ wf_sum a1 (h2 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fo F])))
;

% If X1 and X2 are accessible, then X1|X2 is accessible
rec wf_par: (g:ctx) acc [g ⊢ X1] → acc [g ⊢ X2] → acc [g ⊢ par X1 X2] =
/ total {a1 a2} (wf_par _ _ _ a1 a2) /
fn a1,a2 ⇒ let acc_intro [g] [g ⊢ X1] h1 = a1 in
let acc_intro [g] [g ⊢ X2] h2 = a2 in
acc_intro [g] [g ⊢ par X1 X2] (mlam _,_ ⇒ fn f ⇒ (case f of
       | [g ⊢ fc (fc_parl F _ _)] ⇒ wf_par (h1 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F]) a2
       | [g ⊢ fc (fc_parr F _ _)] ⇒ wf_par a1 (h2 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F])
       | [g ⊢ fc (fc_synl F1 _ _ F2 _ _)] ⇒ wf_par (h1 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F1]) (h2 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F2])
       | [g ⊢ fc (fc_synr F1 _ _ F2 _ _)] ⇒ wf_par (h1 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F1]) (h2 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F2])
       | [g ⊢ fo (fo_parl F (\_._) _)] ⇒ wf_par (h1 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fo F]) a2
       | [g ⊢ fo (fo_parr F (\_._) _)] ⇒ wf_par a1 (h2 [_ ⊢ _] [_ ⊢ _] [_ ⊢ fo F])))
;

% If (X a) is accessible for all a, then nu (\a.X) is accessible
rec wf_nu: (g:ctx) acc [g,a:names ⊢ X] → acc [g ⊢ nu \a.X] =
/ total a (wf_nu _ _ a) /
fn a ⇒ let acc_intro [g,a:names] [g,a:names ⊢ X] h = a in
acc_intro [g] [g ⊢ nu \a.X] (mlam _,_ ⇒ fn f ⇒ (case f of 
       | [g ⊢ fc (fc_nu \a.F)] ⇒ wf_nu (h [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F])
       | [g ⊢ fo (fo_nu_cl (\_._) (\_._) (\a.F))] ⇒ wf_nu (h [_ ⊢ _] [_ ⊢ _] [_ ⊢ fc F])
       | [g ⊢ fo (fo_nu_op \a.F)] ⇒ wf_nu (h [_ ⊢ _] [_ ⊢ _] [_ ⊢ fo F])))
;

% Well-foundedness of processes: all processes are accessible
rec wf_proc: (g:ctx) {X:[g ⊢ proc]} acc [g ⊢ X] =
/ total x (wf_proc _ x) /
mlam X ⇒ case [_ ⊢ X] of
  | [g ⊢ null] ⇒ acc_intro [g] [_ ⊢ null] (mlam _,_ ⇒ fn f ⇒ (case f of 
       | [g ⊢ fc F] ⇒ impossible [g ⊢ F]
       | [g ⊢ fo F] ⇒ impossible [g ⊢ F]))
  | [g ⊢ pref A X1] ⇒ acc_intro [g] [_ ⊢ pref A X1] (mlam _,_ ⇒ fn f ⇒ (case f of 
       | [g ⊢ fc F] ⇒ impossible [g ⊢ F]
       | [g ⊢ fo F] ⇒ impossible [g ⊢ F]))
  | [g ⊢ kpref A K[] X1] ⇒ wf_kpref [_ ⊢ _] [_ ⊢ _] (wf_proc [g ⊢ X1])
  | [g ⊢ sum X1 X2] ⇒ wf_sum (wf_proc [g ⊢ X1]) (wf_proc [g ⊢ X2])
  | [g ⊢ par X1 X2] ⇒ wf_par (wf_proc [g ⊢ X1]) (wf_proc [g ⊢ X2])
  | [g ⊢ nu \a.X1] ⇒ wf_nu (wf_proc [_ ⊢ X1])
;



% Infinite ascending sequence of natural numbers:
% A sequence x0 < x1 < ... < xn < xn+1 < ... is given by
% a function F: keys → keys, denoting an enumeration of natural numbers,
% with the property that F(n) < F(n+1) for all n in keys.
% seq_nat_up x0 holds iff there is an infinite ascending sequence starting from x0
inductive seq_nat_up: [⊢ keys] → ctype =
  | snu_intro: {F:[⊢ keys → keys]}
    ({N:[⊢ keys]} [⊢ less (F N) (F (s N))]) → seq_nat_up [⊢ F z]
;

% Auxiliary lemma: each natural number is less than its successor
rec aux: {N:[⊢ keys]} [⊢ less N (s N)] =
/ total n (aux n) /
mlam N ⇒ case [⊢ N] of
  | [⊢ z] ⇒ [⊢ lzero _]
  | [⊢ s N'] ⇒ let [⊢ L] = aux [⊢ N'] in [⊢ lsucc L]
;

% Example of infinite ascending sequence: 0 < 1 < 2 < ...
% Encoded by using F = id on keys, which satisfies F (n) = n < n+1 = F(n+1)
let D1:seq_nat_up [⊢ z] = snu_intro [⊢ \x.x] (mlam N ⇒ aux [⊢ N]);

% Example of infinite ascending sequence: 1 < 2 < 3 < ...
% Encoded by using F = \x.(s x) on keys, which satisfies F (n) = s n < s (n+1) = F(n+1)
let D2:seq_nat_up [⊢ s z] = snu_intro [⊢ \x.(s x)] (mlam N ⇒ aux [⊢ s N]);

% Infinite descending sequence of natural numbers:
% A sequence ... < xn+1 < xn < ... < x1 < x0 is given by
% a function F: keys → keys, denoting an enumeration of natural numbers,
% with the property that F(n+1) < F(n) for all n in keys.
% seq_nat_dn x0 holds iff there is an infinite descending sequence starting from x0
inductive seq_nat_dn: [⊢ keys] → ctype =
  | snd_intro: {F:[⊢ keys → keys]}
    ({N:[⊢ keys]} [⊢ less (F (s N)) (F N)]) → seq_nat_dn [⊢ F z]
;

% If n is accessible and there is an infinite descending sequence starting from n,
% then we have a contradiction
rec acc_impl_no_seq_nat: acc_nat [⊢ N] → seq_nat_dn [⊢ N] → [⊢ false] =
/ total a (acc_impl_no_seq_nat _ a _) /
fn a,sq ⇒ let snd_intro [⊢ \x.F] h2 = sq in
let acc_intro_nat [⊢ _] h1 = a in 
acc_impl_no_seq_nat (h1 [⊢ F[s z]] (h2 [⊢ z])) (snd_intro [⊢ \x. F[s x]] (mlam N ⇒ h2 [⊢ s N]))
;

% There is no infinite descending sequence of natural numbers.
% Proved using the fact that each natural number is accessible, and
% there is no infinite descending sequence starting from an accessible number
rec no_seq_nat_dn: {N:[⊢ keys]} seq_nat_dn [⊢ N] → [⊢ false] =
/ total (no_seq_nat_dn) /
mlam N ⇒ fn sq ⇒ let a = wf_nat [⊢ N] in 
acc_impl_no_seq_nat a sq
;

% Infinite descending sequence of forward transitions:
% A sequence ... → Xn+1 → Xn → ... → X1 → X0, where "→" denotes a forward CCSKP transition,
% is given by a function F: keys → proc, denoting an enumeration of CCSKP processes,
% with the property that Xn+1=F(n+1) → F(n)=Xn for all n in keys.
% seq_dn X0 holds iff there is an infinite descending sequence starting from X0

% We need an existential type denoting the existence of a transition between two processes,
% to avoid imposing the use of a single proof label T for all transitions in a sequence
inductive ex_fstep: (g:ctx) [g ⊢ proc] → [g ⊢ proc] → ctype =
  | exf: {T:[g ⊢ pr_lab]} [g ⊢ fstep X T X'] → ex_fstep [g ⊢ X] [g ⊢ X']
;

inductive seq_dn: (g:ctx) [g ⊢ proc] → ctype =
  | seq_intro: {F:[g ⊢ keys → proc]}
    ({N:[⊢ keys]} ex_fstep [g ⊢ (F (s N[]))] [g ⊢ (F N[])]) → seq_dn [g ⊢ F z]
;


% If X is accessible and there is an infinite descending sequence starting from X,
% then we have a contradiction
rec acc_impl_no_seq: (g:ctx) acc [g ⊢ X] → seq_dn [g ⊢ X] → [⊢ false] =
/ total a (acc_impl_no_seq _ _ a _) /
fn a,sq ⇒ let seq_intro [g ⊢ \x.F] h2 = sq in
let acc_intro [_] [_ ⊢ _] h1 = a in 
let exf [g ⊢ T] [g ⊢ F'] = h2 [⊢ z] in
acc_impl_no_seq (h1 [g ⊢ F[..,(s z)]] [g ⊢ T] [g ⊢ F']) (seq_intro [g ⊢ \x. F[..,(s x)]] (mlam N ⇒ h2 [⊢ s N]))
;


% There is no infinite descending sequence of forward transitions.
% Proved using the fact that each process is accessible, and
% there is no infinite descending sequence starting from an accessible process
rec no_seq_dn: (g:ctx) {X:[g ⊢ proc]} seq_dn [g ⊢ X] → [⊢ false] =
/ total (no_seq_dn) /
mlam X ⇒ fn sq ⇒ let a = wf_proc [_ ⊢ X] in 
acc_impl_no_seq a sq
;