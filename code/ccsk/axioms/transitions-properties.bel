% Definitions and properties needed to state and prove the axioms from "An Axiomatic Approach to Reversible Computation" for CCSK

% Independence of CCSK transitions:
% Two CCSK transitions s1 and s2 are independent if they are connected and the proof labels
% of their corresponding CCSKP transitions enrich(s1) and enrich(s2) are independent.
LF ccsk_indep_tr: ccsk.step X KL1 X' → ccsk.step Y KL2 Y' → type =
  | ccsk_ind_tr: enrich (S1:ccsk.step X KL1 X') (S1+:ccskp.step X T1 X') →
    enrich (S2:ccsk.step Y KL2 Y') (S2+:ccskp.step Y T2 Y') →
    indep T1 T2 → ccsk.conn_tr S1 S2 → ccsk_indep_tr S1 S2
;


%%% Basic properties of transitions

% Loop lemma - first implication
rec ccsk_loop_lemma_one: (g:ctx) [g ⊢ ccsk.fstep X KL X'] → [g ⊢ ccsk.bstep X' KL X] =
/ total f (ccsk_loop_lemma_one _ _ _ _ f) /
fn f ⇒ case f of
  | [g ⊢ fs_pref D] ⇒ [g ⊢ bs_pref D]
  | [g ⊢ fs_kpref F I] ⇒ let [g ⊢ B] = ccsk_loop_lemma_one [g ⊢ F] in [g ⊢ bs_kpref B I]
  | [g ⊢ fs_suml F D] ⇒ let [g ⊢ B] = ccsk_loop_lemma_one [g ⊢ F] in [g ⊢ bs_suml B D]
  | [g ⊢ fs_sumr F D] ⇒ let [g ⊢ B] = ccsk_loop_lemma_one [g ⊢ F] in [g ⊢ bs_sumr B D]
  | [g ⊢ fs_parl F N] ⇒ let [g ⊢ B] = ccsk_loop_lemma_one [g ⊢ F] in [g ⊢ bs_parl B N]
  | [g ⊢ fs_parr F N] ⇒ let [g ⊢ B] = ccsk_loop_lemma_one [g ⊢ F] in [g ⊢ bs_parr B N]
  | [g ⊢ fs_synl F1 F2] ⇒ let [g ⊢ B1] = ccsk_loop_lemma_one [g ⊢ F1] in
       let [g ⊢ B2] = ccsk_loop_lemma_one [g ⊢ F2] in [g ⊢ bs_synl B1 B2]
  | [g ⊢ fs_synr F1 F2] ⇒ let [g ⊢ B1] = ccsk_loop_lemma_one [g ⊢ F1] in
       let [g ⊢ B2] = ccsk_loop_lemma_one [g ⊢ F2] in [g ⊢ bs_synr B1 B2]
  | [g ⊢ fs_nu \a.F] ⇒ let [g,a:names ⊢ B] = ccsk_loop_lemma_one [g,a:names ⊢ F] in [g ⊢ bs_nu \a.B]
;

% Loop lemma - second implication
rec ccsk_loop_lemma_two: (g:ctx) [g ⊢ ccsk.bstep X' KL X] → [g ⊢ ccsk.fstep X KL X'] =
/ total f (ccsk_loop_lemma_two _ _ _ _ f) /
fn f ⇒ case f of
  | [g ⊢ bs_pref D] ⇒ [g ⊢ fs_pref D]
  | [g ⊢ bs_kpref B I] ⇒ let [g ⊢ F] = ccsk_loop_lemma_two [g ⊢ B] in [g ⊢ fs_kpref F I]
  | [g ⊢ bs_suml B D] ⇒ let [g ⊢ F] = ccsk_loop_lemma_two [g ⊢ B] in [g ⊢ fs_suml F D]
  | [g ⊢ bs_sumr B D] ⇒ let [g ⊢ F] = ccsk_loop_lemma_two [g ⊢ B] in [g ⊢ fs_sumr F D]
  | [g ⊢ bs_parl B N] ⇒ let [g ⊢ F] = ccsk_loop_lemma_two [g ⊢ B] in [g ⊢ fs_parl F N]
  | [g ⊢ bs_parr B N] ⇒ let [g ⊢ F] = ccsk_loop_lemma_two [g ⊢ B] in [g ⊢ fs_parr F N]
  | [g ⊢ bs_synl B1 B2] ⇒ let [g ⊢ F1] = ccsk_loop_lemma_two [g ⊢ B1] in
       let [g ⊢ F2] = ccsk_loop_lemma_two [g ⊢ B2] in [g ⊢ fs_synl F1 F2]
  | [g ⊢ bs_synr B1 B2] ⇒ let [g ⊢ F1] = ccsk_loop_lemma_two [g ⊢ B1] in
       let [g ⊢ F2] = ccsk_loop_lemma_two [g ⊢ B2] in [g ⊢ fs_synr F1 F2]
  | [g ⊢ bs_nu \a.B] ⇒ let [g,a:names ⊢ F] = ccsk_loop_lemma_two [g,a:names ⊢ B] in [g ⊢ fs_nu \a.F]
;

% Two forward composable transitions cannot have the same key.
rec ccsk_no_composable_fw_tr_with_same_key: (g:ctx) [g ⊢ ccsk.fstep X (kl_base A1 K[]) Y] →
  [g ⊢ ccsk.fstep Y (kl_base A2 K[]) Z] → [g ⊢ false] =
/ total x (ccsk_no_composable_fw_tr_with_same_key _ x _ _ _ _ _ _ _) /
fn f1,f2 ⇒ let [g ⊢ F1] = f1 in
let [g ⊢ F2] = f2 in
(case total_enrich_f [g ⊢ F1] of
  | [g ⊢ ex_enfc (en_fc _ F1+ _ H1)] ⇒ (case total_enrich_f [g ⊢ F2] of
       | [g ⊢ ex_enfc (en_fc _ F2+ _ H2)] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1+] [g ⊢ fc F2+] [g ⊢ key_cl H1] [g ⊢ key_cl H2]
       | [g ⊢ ex_enfo (en_fo _ F2+ \a.H2)] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1+] [g ⊢ fo F2+] [g ⊢ key_cl H1] [g ⊢ key_op \a.H2])
  | [g ⊢ ex_enfo (en_fo _ F1+ \a.H1)] ⇒ (case total_enrich_f [g ⊢ F2] of
       | [g ⊢ ex_enfc (en_fc _ F2+ _ H2)] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fo F1+] [g ⊢ fc F2+] [g ⊢ key_op \a.H1] [g ⊢ key_cl H2]
       | [g ⊢ ex_enfo (en_fo _ F2+ \a.H2)] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fo F1+] [g ⊢ fo F2+] [g ⊢ key_op \a.H1] [g ⊢ key_op \a.H2]))
;

% Two forward composable transitions cannot have the same keyed label.
rec ccsk_no_composable_fw_tr_with_same_label: (g:ctx) [g ⊢ ccsk.fstep X KL Y] → [g ⊢ ccsk.fstep Y KL Z] → [g ⊢ false] =
/ total x (ccsk_no_composable_fw_tr_with_same_label _ x _ _ _ _ _) /
fn f1,f2 ⇒ let [g ⊢ F1]:[g ⊢ ccsk.fstep _ (kl_base _ _) _] = f1 in 
impossible ccsk_no_composable_fw_tr_with_same_key [g ⊢ F1] f2
;

% Two backward composable transitions cannot have the same keyed label.
rec ccsk_no_composable_bw_tr_with_same_label: (g:ctx) [g ⊢ ccsk.bstep Z KL Y] → [g ⊢ ccsk.bstep Y KL X] → [g ⊢ false] =
/ total x (ccsk_no_composable_bw_tr_with_same_label _ x _ _ _ _ _) /
fn b1,b2 ⇒ let [g ⊢ B1]:[g ⊢ ccsk.bstep _ (kl_base _ _) _] = b1 in 
let [g ⊢ F1] = ccsk_loop_lemma_two [g ⊢ B1] in
let [g ⊢ F2] = ccsk_loop_lemma_two b2 in
impossible ccsk_no_composable_fw_tr_with_same_key [g ⊢ F2] [g ⊢ F1]
;


%%% Inverse of a transition

% Inverse of a transition: ccsk_inv_tr S1 S2 holds iff S2 is the inverse of S1
LF ccsk_inv_tr: ccsk.step X KL1 X' → ccsk.step Y KL2 Y' → type =
  | ccsk_it: {S1:ccsk.step X KL X'} {S2:ccsk.step X' KL X} ccsk_inv_tr S1 S2
;

% We show that, thanks to the loop lemma, ccsk_inv_tr is a function and, in particular, an involution (ccsk_inv_tr ∘ ccsk_inv_tr = id).
% Additionally, we show that t and inv_tr(t) have opposite directions.

% Existential type denoting existence of an inverse transition
LF ccsk_ex_inv: ccsk.step X KL X' → type =
  | ccsk_ex_iv: ccsk_inv_tr S1 S2 → ccsk_ex_inv S1
;

% Totality of ccsk_inv_tr: given a transition S,
% there exists at least one transition S' such that ccsk_inv_tr(S)=S'.
rec ccsk_total_inv: (g:ctx) {S:[g ⊢ ccsk.step X KL X']} [g ⊢ ccsk_ex_inv S] =
/ total (ccsk_total_inv) /
mlam S ⇒ case [_ ⊢ S] of
  | [g ⊢ fw F] ⇒ let [g ⊢ B] = ccsk_loop_lemma_one [g ⊢ F] in [g ⊢ ccsk_ex_iv (ccsk_it S (bw B))]
  | [g ⊢ bw B] ⇒ let [g ⊢ F] = ccsk_loop_lemma_two [g ⊢ B] in [g ⊢ ccsk_ex_iv (ccsk_it S (fw F))]
;

% Functionality of inv_tr: given a transition S,
% there is at most one transition S' such that inv_tr(S)=S'.
rec ccsk_functional_inv: (g:ctx) (S:[g ⊢ ccsk.step X KL X']) (S1:[g ⊢ ccsk.step Y1 KL1 Y1']) (S2:[g ⊢ ccsk.step Y2 KL2 Y2'])
  [g ⊢ ccsk_inv_tr S S1] → [g ⊢ ccsk_inv_tr S S2] → [g ⊢ eqs S1 S2] =
/ total r1 (ccsk_functional_inv _ _ _ _ r1 _) /
fn r1,r2 ⇒ let [g ⊢ ccsk_it _ S1] = r1 in
let [g ⊢ ccsk_it _ S2] = r2 in ccsk_unique_step [g ⊢ S1] [g ⊢ S2]
;

% inv_tr is an involution: inv_tr ∘ inv_tr = id.
rec ccsk_involution_inv: (g:ctx) (S1:[g ⊢ ccsk.step X1 KL1 X1']) (S2:[g ⊢ ccsk.step X2 KL2 X2'])
  (S3:[g ⊢ ccsk.step X3 KL3 X3']) [g ⊢ ccsk_inv_tr S1 S2] → [g ⊢ ccsk_inv_tr S2 S3] → [g ⊢ eqs S1 S3] =
/ total s1 (ccsk_involution_inv _ _ _ _ _ _ _ _ _ _ s1 _ _ _ _) /
fn d1,d2 ⇒ let [g ⊢ ccsk_it S1 S2] = d1 in
let [g ⊢ ccsk_it S2 S3] = d2 in ccsk_unique_step [g ⊢ S1] [g ⊢ S3]
;

% Type family relating two combined CCSK transitions having the same direction
LF ccsk_same_direction: ccsk.step X1 KL1 Y1 → ccsk.step X2 KL2 Y2 → type =
  | ccsk_sdf: ccsk_same_direction (fw F1) (fw F2)
  | ccsk_sdb: ccsk_same_direction (bw B1) (bw B2)
;

% Type family relating two combined transitions having opposite directions
LF ccsk_opp_direction: ccsk.step X1 KL1 Y1 → ccsk.step X2 KL2 Y2 → type =
  | ccsk_odfb: ccsk_opp_direction (fw F1) (bw B2)
  | ccsk_odbf: ccsk_opp_direction (bw B1) (fw F2)
;

% Type family relating couples of combined transitions with same or opposite directions
LF ex_ccsk_same_or_opp_direction: ccsk.step X1 KL1 Y1 → ccsk.step X2 KL2 Y2 → type =
  | ccsk_or_sd: ccsk_same_direction S1 S2 → ex_ccsk_same_or_opp_direction S1 S2
  | ccsk_or_od: ccsk_opp_direction S1 S2 → ex_ccsk_same_or_opp_direction S1 S2
;

% Given two combined transitions, they either have the same direction or opposite directions.
rec ccsk_same_or_opp_direction: (g:ctx) {S1:[g ⊢ ccsk.step X1 KL1 X1']} {S2:[g ⊢ ccsk.step X2 KL2 X2']}
  [g ⊢ ex_ccsk_same_or_opp_direction S1 S2] =
/ total s1 (ccsk_same_or_opp_direction _ _ _ _ _ _ _ s1 _ ) /
mlam S1,S2 ⇒ case [_ ⊢ S1] of
  | [g ⊢ fw F1] ⇒ (case [g ⊢ S2] of
       | [g ⊢ fw F2] ⇒ [g ⊢ ccsk_or_sd ccsk_sdf]
       | [g ⊢ bw B2] ⇒ [g ⊢ ccsk_or_od ccsk_odfb])
  | [g ⊢ bw B1] ⇒ (case [g ⊢ S2] of
       | [g ⊢ fw F2] ⇒ [g ⊢ ccsk_or_od ccsk_odbf]
       | [g ⊢ bw B2] ⇒ [g ⊢ ccsk_or_sd ccsk_sdb])
;

% Given two combined transitions, they cannot both have the same direction and opposite directions.
rec ccsk_not_same_and_opp_direction: (g:ctx) (S1:[g ⊢ ccsk.step X1 KL1 X1']) (S2:[g ⊢ ccsk.step X2 KL2 X2'])
  [g ⊢ ccsk_same_direction S1 S2] → [g ⊢ ccsk_opp_direction S1 S2] → [g ⊢ false] =
/ total sd (ccsk_not_same_and_opp_direction _ _ _ _ _ _ _ _ _ sd _) /
fn sd,od ⇒ case sd of
  | [g ⊢ ccsk_sdf] ⇒ impossible od
  | [g ⊢ ccsk_sdb] ⇒ impossible od
;

% Given a combined transition t, t and inv_tr(t) have opposite directions.
rec ccsk_inv_tr_have_opp_direction: (g:ctx) (S1:[g ⊢ ccsk.step X1 KL1 X1']) (S2:[g ⊢ ccsk.step X2 KL2 X2'])
  [g ⊢ ccsk_inv_tr S1 S2] → [g ⊢ ccsk_opp_direction S1 S2] =
/ total hr (ccsk_inv_tr_have_opp_direction _ _ _ _ _ _ _ _ _ hr) /
fn hr ⇒ let [g ⊢ ccsk_it S1 S2] = hr in
case [_ ⊢ S1] of
  | [g ⊢ fw F1] ⇒ (case [g ⊢ S2] of
       | [g ⊢ fw F2] ⇒ impossible ccsk_no_composable_fw_tr_with_same_label [g ⊢ F1] [g ⊢ F2]
       | [g ⊢ bw B2] ⇒ [g ⊢ ccsk_odfb])
  | [g ⊢ bw B1] ⇒ (case [g ⊢ S2] of
       | [g ⊢ fw F2] ⇒ [g ⊢ ccsk_odbf]
       | [g ⊢ bw B2] ⇒ impossible ccsk_no_composable_bw_tr_with_same_label [g ⊢ B1] [g ⊢ B2])
;



% Auxiliary lemmas for SP

% [[ Currently unused ]]
% Given a CCSK path between two processes, there exists a CCSKP path between the same processes.
rec path_ccsk_to_ccskp: (g:ctx) [g ⊢ ccsk.step* X X'] → [g ⊢ ccskp.step* X X'] =
/ total s* (path_ccsk_to_ccskp _ _ _ s*) /
fn s* ⇒ case s* of
  | [g ⊢ ccsk.id_s*] ⇒ [g ⊢ ccskp.id_s*]
  | [g ⊢ ccsk.st_s* S] ⇒ let {EN:[g ⊢ enrich _ S+]}[g ⊢ ex_en EN] = total_enrich [g ⊢ S] in [g ⊢ ccskp.st_s* S+]
  | [g ⊢ ccsk.tr_s* S1* S2*] ⇒ let [g ⊢ S1*+] = path_ccsk_to_ccskp [g ⊢ S1*] in
                                let [g ⊢ S2*+] = path_ccsk_to_ccskp [g ⊢ S2*] in [g ⊢ ccskp.tr_s* S1*+ S2*+]
;

% Equality of keyed labels
LF eqkl: key_lab → key_lab → type =
  | refkl: eqkl KL KL
;

% If two CCSKP transitions s1 and s2 have the same proof label, then their corresponding
% CCSK transitions forget(s1) and forget(s2) have the same keyed label.
rec injective_forget_on_labels: (g:ctx) (S1+:[g ⊢ ccskp.step X1 T Y1]) (S2+:[g ⊢ ccskp.step X2 T Y2])
  (S1:[g ⊢ ccsk.step X1 KL1 Y1]) (S2:[g ⊢ ccsk.step X2 KL2 Y2]) [g ⊢ forget S1+ S1] → [g ⊢ forget S2+ S2] →
  [g ⊢ eqkl KL1 KL2] =
/ total (injective_forget_on_labels) /
fn fg1,fg2 ⇒ case fg1 of
  | [g ⊢ fgfc (fg_fc _ _ L1 H1)] ⇒ (case fg2 of
       | [g ⊢ fgfc (fg_fc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbc (fg_bc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl])
  | [g ⊢ fgfo (fg_fo _ _ \a.H1)] ⇒ (case fg2 of
       | [g ⊢ fgfo (fg_fo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbo (fg_bo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl])
  | [g ⊢ fgbc (fg_bc _ _ L1 H1)] ⇒ (case fg2 of
       | [g ⊢ fgfc (fg_fc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbc (fg_bc _ _ L2 H2)] ⇒ let [g ⊢ refl] = functional_lab [g ⊢ L1] [g ⊢ L2] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H2] in [g ⊢ refkl])
  | [g ⊢ fgbo (fg_bo _ _ \a.H1)] ⇒ (case fg2 of
       | [g ⊢ fgfo (fg_fo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl]
       | [g ⊢ fgbo (fg_bo _ _ \a.H2)] ⇒ let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H2] in [g ⊢ refkl])
;

% If two CCSKP transitions s1 and s2 have the same direction, then their corresponding
% CCSK transitions forget(s1) and forget(s2) have the same direction.
rec sdir_ccskp_to_ccsk: (g:ctx) (S1+:[g ⊢ ccskp.step X1 T1 Y1]) (S2+:[g ⊢ ccskp.step X2 T2+ Y2])
  (S1:[g ⊢ ccsk.step X1 KL1 Y1]) (S2:[g ⊢ ccsk.step X2 KL2 Y2]) [g ⊢ same_direction S1+ S2+]
  → [g ⊢ forget S1+ S1] → [g ⊢ forget S2+ S2] → [g ⊢ ccsk_same_direction S1 S2] =
/ total s (sdir_ccskp_to_ccsk _ _ _ _ _ _ _ _ _ s _ _ _ _ _ _) /
fn sd+,fg1,fg2 ⇒ case sd+ of
  | [g ⊢ sdf _ _] ⇒ (case fg1 of
    | [g ⊢ fgfc _] ⇒ (case fg2 of
         | [g ⊢ fgfc _] ⇒ [g ⊢ ccsk_sdf]
         | [g ⊢ fgfo _] ⇒ [g ⊢ ccsk_sdf])
    | [g ⊢ fgfo _] ⇒ (case fg2 of
         | [g ⊢ fgfc _] ⇒ [g ⊢ ccsk_sdf]
         | [g ⊢ fgfo _] ⇒ [g ⊢ ccsk_sdf]))
  | [g ⊢ sdb _ _] ⇒ (case fg1 of
    | [g ⊢ fgbc _] ⇒ (case fg2 of
         | [g ⊢ fgbc _] ⇒ [g ⊢ ccsk_sdb]
         | [g ⊢ fgbo _] ⇒ [g ⊢ ccsk_sdb])
    | [g ⊢ fgbo _] ⇒ (case fg2 of
         | [g ⊢ fgbc _] ⇒ [g ⊢ ccsk_sdb]
         | [g ⊢ fgbo _] ⇒ [g ⊢ ccsk_sdb]))
;






% Backward transitions are independent (BTI):
% Given two backward transitions sharing the same source process,
% if they are not equal, they are independent.
rec ccsk_bti: (g:ctx) {B1:[g ⊢ ccsk.bstep X KL1 X1]} {B2:[g ⊢ ccsk.bstep X KL2 X2]}
  ([g ⊢ eqbs B1 B2] → [g ⊢ false]) → [g ⊢ ccsk_indep_tr (bw B1) (bw B2)] =
/ total b1 (ccsk_bti _ _ _ _ _ _ b1 _ _) /
mlam B1,B2 ⇒ fn f ⇒
case total_enrich_b [_ ⊢ B1] of
  | {EN1:[g ⊢ enrich_bc _ B1+]}[g ⊢ ex_enbc EN1] ⇒ (case total_enrich_b [_ ⊢ B2] of
       | {EN2:[g ⊢ enrich_bc _ B2+]}[g ⊢ ex_enbc EN2] ⇒ 
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bc B1+] [g ⊢ bc B2+]
             (fn e ⇒ let [g ⊢ refb] = e in
             let [g ⊢ ex_fgbc FG] = total_forget_bc [g ⊢ B1+] in
             let [g ⊢ refbs] = inverse_bc_two [g ⊢ EN1] [g ⊢ FG] in
             let [g ⊢ refbs] = inverse_bc_two [g ⊢ EN2] [g ⊢ FG] in impossible f [g ⊢ refbs]) in
         [g ⊢ ccsk_ind_tr (enbc EN1) (enbc EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))]
       | {EN2:[g ⊢ enrich_bo _ B2+]}[g ⊢ ex_enbo EN2] ⇒
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bc B1+] [g ⊢ bo B2+] (fn e ⇒ impossible e) in
         [g ⊢ ccsk_ind_tr (enbc EN1) (enbo EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))])
  | {EN1:[g ⊢ enrich_bo _ B1+]}[g ⊢ ex_enbo EN1] ⇒ (case total_enrich_b [_ ⊢ B2] of
       | {EN2:[g ⊢ enrich_bc _ B2+]}[g ⊢ ex_enbc EN2] ⇒
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bo B1+] [g ⊢ bc B2+] (fn e ⇒ impossible e) in
         [g ⊢ ccsk_ind_tr (enbo EN1) (enbc EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))]
       | {EN2:[g ⊢ enrich_bo _ B2+]}[g ⊢ ex_enbo EN2] ⇒
         let [g ⊢ ind_bw_tr _ _ (ind_tr I+ _)] = bti [g ⊢ bo B1+] [g ⊢ bo B2+]
             (fn e ⇒ let [g ⊢ refb] = e in
             let [g ⊢ ex_fgbo FG] = total_forget_bo [g ⊢ B1+] in
             let [g ⊢ refbs] = inverse_bo_two [g ⊢ EN1] [g ⊢ FG] in
             let [g ⊢ refbs] = inverse_bo_two [g ⊢ EN2] [g ⊢ FG] in impossible f [g ⊢ refbs]) in
         [g ⊢ ccsk_ind_tr (enbo EN1) (enbo EN2) I+ (ctr _ _ (ccsk.st_s* (bw B2)))])
;



% Existence of combined transitions closing a square diagram in CCSK
LF ccsk_square: ccsk.step X KL1 X1 → ccsk.step X KL2 X2 → type =
  | ccsk_sq: {S2':ccsk.step X1 KL2 Y} {S1':ccsk.step X2 KL1 Y} ccsk_same_direction (S1:ccsk.step X KL1 X1) S1' → 
    ccsk_same_direction (S2:ccsk.step X KL2 X2) S2' → ccsk_square (S1:ccsk.step X KL1 X1) (S2:ccsk.step X KL2 X2)
;
% Square property (SP):
% Given two independent coinitial combined transitions,
% there exist two cofinal combined transition closing the square diagram.
rec ccsk_sp: (g:ctx) {S1:[g ⊢ ccsk.step X KL1 X1]} {S2:[g ⊢ ccsk.step X KL2 X2]}
  [g ⊢ ccsk_indep_tr S1 S2] → [g ⊢ ccsk_square S1 S2] =
/ total s1 (ccsk_sp _ _ _ _ _ _ s1 _ _) /
mlam S1,S2 ⇒ fn i ⇒ let [g ⊢ ccsk_ind_tr EN1 EN2 I+ (ctr _ _ S*)] = i in
let [g ⊢ _]:[g ⊢ enrich _ S1+] = [g ⊢ EN1] in
let [g ⊢ _]:[g ⊢ enrich _ S2+] = [g ⊢ EN2] in
let [g ⊢ sq S2'+ S1'+ SD1+ SD2+] = sp [g ⊢ S1+] [g ⊢ S2+] [g ⊢ ind_tr I+ (ct _ _ (ccskp.st_s* S2+))] in
let {FG2':[g ⊢ forget _ S2']}[g ⊢ ex_fg FG2'] = total_forget [g ⊢ S2'+] in
let {FG1':[g ⊢ forget _ S1']}[g ⊢ ex_fg FG1'] = total_forget [g ⊢ S1'+] in
let [g ⊢ ex_fg FG1] = total_forget [g ⊢ S1+] in
let [g ⊢ ex_fg FG2] = total_forget [g ⊢ S2+] in
let [g ⊢ refs] = inverse_two [g ⊢ EN1] [g ⊢ FG1] in
let [g ⊢ refs] = inverse_two [g ⊢ EN2] [g ⊢ FG2] in
let [g ⊢ SD1] = sdir_ccskp_to_ccsk [g ⊢ SD1+] [g ⊢ FG1] [g ⊢ FG1'] in
let [g ⊢ SD2] = sdir_ccskp_to_ccsk [g ⊢ SD2+] [g ⊢ FG2] [g ⊢ FG2'] in
let [g ⊢ refkl] = injective_forget_on_labels [g ⊢ FG1] [g ⊢ FG1'] in
let [g ⊢ refkl] = injective_forget_on_labels [g ⊢ FG2] [g ⊢ FG2'] in
[g ⊢ ccsk_sq S2' S1' SD1 SD2]
;



% Type family encoding accessibility of CCSK processes
inductive ccsk_acc: (g:ctx) [g ⊢ proc] → ctype =
  | ccsk_acc_intro: {g:ctx} {X':[g ⊢ proc]}
    ({X:[g ⊢ proc]} {KL:[g ⊢ key_lab]} [g ⊢ ccsk.fstep X KL X'] → ccsk_acc [g ⊢ X]) → ccsk_acc [g ⊢ X']
;

% If a process X is accessible w.r.t. the LTS of CCSKP, then it is accessible w.r.t. the LTS of CCSK. 
rec acc_ccskp_to_ccsk: (g:ctx) acc [g ⊢ X] → ccsk_acc [g ⊢ X] =
/ total a (acc_ccskp_to_ccsk _ _ a) /
fn a ⇒ let acc_intro [g] [g ⊢ X] h = a in
ccsk_acc_intro [g] [g ⊢ X] (mlam _,_ ⇒ fn f ⇒
  let [g ⊢ F] = f in
  (case total_enrich_f [g ⊢ F] of
     | {EN:[g ⊢ enrich_fc _ F+]}[g ⊢ ex_enfc EN] ⇒ acc_ccskp_to_ccsk (h _ _ [g ⊢ fc F+])
     | {EN:[g ⊢ enrich_fo _ F+]}[g ⊢ ex_enfo EN] ⇒ acc_ccskp_to_ccsk (h _ _ [g ⊢ fo F+])))
;

% Well-foundedness (WF): all processes are accessible
rec ccsk_wf: (g:ctx) {X:[g ⊢ proc]} ccsk_acc [g ⊢ X] =
/ total x (ccsk_wf _ x) /
mlam X ⇒ acc_ccskp_to_ccsk (wf [_ ⊢ X])
;



% If two CCSK transitions s1 and s2 have the same direction, then their corresponding
% CCSKP transitions enrich(s1) and enrich(s2) have the same direction.
rec sdir_ccsk_to_ccskp: (g:ctx) (S1:[g ⊢ ccsk.step X1 KL1 Y1]) (S2:[g ⊢ ccsk.step X2 KL2 Y2])
  (S1+:[g ⊢ ccskp.step X1 T1 Y1]) (S2+:[g ⊢ ccskp.step X2 T2+ Y2]) [g ⊢ ccsk_same_direction S1 S2]
  → [g ⊢ enrich S1 S1+] → [g ⊢ enrich S2 S2+] → [g ⊢ same_direction S1+ S2+] =
/ total s (sdir_ccsk_to_ccskp _ _ _ _ _ _ _ _ _ s _ _ _ _ _ _) /
fn sd,en1,en2 ⇒ case sd of
  | [g ⊢ ccsk_sdf] ⇒ (case en1 of
       | [g ⊢ enfc _] ⇒ (case en2 of
            | [g ⊢ enfc _] ⇒ [g ⊢ sdf (ftc_cl _) (ftc_cl _)]
            | [g ⊢ enfo _] ⇒ [g ⊢ sdf (ftc_cl _) (ftc_op _)])
       | [g ⊢ enfo _] ⇒ (case en2 of
            | [g ⊢ enfc _] ⇒ [g ⊢ sdf (ftc_op _) (ftc_cl _)]
            | [g ⊢ enfo _] ⇒ [g ⊢ sdf (ftc_op _) (ftc_op _)]))
  | [g ⊢ ccsk_sdb] ⇒ (case en1 of
       | [g ⊢ enbc _] ⇒ (case en2 of
            | [g ⊢ enbc _] ⇒ [g ⊢ sdb (btc_cl _) (btc_cl _)]
            | [g ⊢ enbo _] ⇒ [g ⊢ sdb (btc_cl _) (btc_op _)])
       | [g ⊢ enbo _] ⇒ (case en2 of
            | [g ⊢ enbc _] ⇒ [g ⊢ sdb (btc_op _) (btc_cl _)]
            | [g ⊢ enbo _] ⇒ [g ⊢ sdb (btc_op _) (btc_op _)]))
;


% Given a CCSK transition t with inverse transition ccsk_inv(t), then their corresponding
% CCSKP transitions enrich(t) and enrich(ccsk_inv(t)) are also mutual inverses.
rec inv_ccsk_to_ccskp: (g:ctx) (T:[g ⊢ ccsk.step X KL Y]) (RT:[g ⊢ ccsk.step Y KL X])
  (T+:[g ⊢ ccskp.step X T1 Y]) (RT+:[g ⊢ ccskp.step Y T2 X]) [g ⊢ ccsk_inv_tr T RT]
  → [g ⊢ enrich T T+] → [g ⊢ enrich RT RT+] → [g ⊢ inv_tr T+ RT+] =
/ total hi (inv_ccsk_to_ccskp _ _ _ _ _ _ _ _ _ _ hi _ _) /
fn hr,en1,en2 ⇒
let [g ⊢ ccsk_it T RT] = hr in
let [g ⊢ EN1]:[g ⊢ enrich T T+] = en1 in
let [g ⊢ EN2]:[g ⊢ enrich RT RT+] = en2 in
let [g ⊢ ex_iv (it T+ RT'+)] = total_inv [g ⊢ T+] in
let [g ⊢ refst] = unique_step [g ⊢ RT+] [g ⊢ RT'+] in [g ⊢ it T+ RT+]
;

%{
LF diamond_pr_lab_equality: fstep_cl X T1 Y → fstep_cl Y T2 Z → fstep_cl X T3 W → fstep_cl W T4 Z → type =
  | eq_so: eqplc T1 T3 → eqplc T2 T4 →
    diamond_pr_lab_equality (F1:fstep_cl X T1 Y) (F2:fstep_cl Y T2 Z) (F3:fstep_cl X T3 W) (F4:fstep_cl W T4 Z)
;

rec diamonds_have_same_pr_labels: (g:ctx) {F1:[g ⊢ fstep_cl X T1 Y]} {F2:[g ⊢ fstep_cl Y T2 Z]}
  {F3:[g ⊢ fstep_cl X T3 W]} {F4:[g ⊢ fstep_cl W T4 Z]} [g ⊢ indep_cl T1 T3] →
  [g ⊢ diamond_pr_lab_equality F1 F2 F3 F4] =
/ total f1 (diamonds_have_same_pr_labels _ _ _ _ _ _ _ _ _ f1 _ _ _ _) /
mlam F1,F2,F3,F4 ⇒ fn i ⇒ case [_ ⊢ F1] of
  | [g ⊢ fc_pref _] ⇒ impossible i
  | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
    let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
    let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in 
    let [g ⊢ eq_so refplc refplc] = diamonds_have_same_pr_labels [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] i in
    [g ⊢ eq_so refplc refplc]
  | [g ⊢ fc_suml F1' _] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml F2' _] ⇒ (case [g ⊢ F3] of
            | [g ⊢ fc_suml F3' _] ⇒ let [g ⊢ i_c1l I] = i in (case [g ⊢ F4] of
                 | [g ⊢ fc_suml F4' _] ⇒ let [g ⊢ eq_so refplc refplc] = diamonds_have_same_pr_labels
                   [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] [g ⊢ I] in [g ⊢ eq_so refplc refplc]
                 | [g ⊢ fc_sumr _ D4] ⇒ impossible target_is_not_std_fc [g ⊢ F3'] [g ⊢ D4])
            | [g ⊢ fc_sumr _ _] ⇒ impossible i)
       | [g ⊢ fc_sumr _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fc_sumr F1' D1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ fc_sumr F2' _] ⇒ (case [g ⊢ F3] of
            | [g ⊢ fc_suml _ _] ⇒ impossible i
            | [g ⊢ fc_sumr F3' _] ⇒ let [g ⊢ i_c1r I] = i in (case [g ⊢ F4] of
                 | [g ⊢ fc_suml _ D4] ⇒ impossible target_is_not_std_fc [g ⊢ F3'] [g ⊢ D4]
                 | [g ⊢ fc_sumr F4' _] ⇒ let [g ⊢ eq_so refplc refplc] = diamonds_have_same_pr_labels
                   [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] [g ⊢ I] in [g ⊢ eq_so refplc refplc])))
  | [g ⊢ fc_parl F1' H1 N1] ⇒ (case [g ⊢ F3] of
       | [g ⊢ fc_parl F3' H3 N3] ⇒ let [g ⊢ i_p1l I] = i in (case [g ⊢ F2] of
            | [g ⊢ fc_parl F2' H2 N2] ⇒ (case [g ⊢ F4] of
                 | [g ⊢ fc_parl F4' H4 N4] ⇒ let [g ⊢ eq_so refplc refplc] = diamonds_have_same_pr_labels
                   [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] [g ⊢ I] in [g ⊢ eq_so refplc refplc]
                 | [g ⊢ fc_parr F4' H4 N4] ⇒ impossible target_is_not_source_fc [g ⊢ F4']
                 | [g ⊢ fc_synl FL4 LL4 HL4 FR4 LR4 HR4] ⇒ impossible target_is_not_source_fc [g ⊢ FR4]
                 | [g ⊢ fc_synr FL4 LL4 HL4 FR4 LR4 HR4] ⇒ impossible target_is_not_source_fc [g ⊢ FR4])
            | [g ⊢ fc_parr F2' H2 N2] ⇒ (case [g ⊢ F4] of
                 | [g ⊢ fc_parl F4' H4 N4] ⇒ impossible target_is_not_source_fc [g ⊢ F2']
                 | [g ⊢ fc_parr F4' H4 N4] ⇒ 
                   let [g ⊢ V1] = valid_in_fstep_cl [g ⊢ F1'] in
                   let [g ⊢ V3] = valid_in_fstep_cl [g ⊢ F3'] in 
                   let [g ⊢ NQ] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V3] [g ⊢ I] [g ⊢ H1] [g ⊢ H3] in 
                   let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F1'] [g ⊢ F3'] in 
                   let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H3] in impossible irreflexive_neq [g ⊢ NQ]
                 | [g ⊢ fc_synl FL4 LL4 HL4 FR4 LR4 HR4] ⇒ 
                   let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F2'] [g ⊢ FR4] in 
                   let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR4] in
                   impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N2]
                 | [g ⊢ fc_synr FL4 LL4 HL4 FR4 LR4 HR4] ⇒
                   let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F2'] [g ⊢ FR4] in 
                   let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR4] in
                   impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N2])
            | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ ?
            | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ ?)
       | [g ⊢ fc_parr F3' H3 N3] ⇒ let [g ⊢ i_p2l H1' H3' NQ] = i in ?
       | [g ⊢ fc_synl FL3 LL3 HL3 FR3 LR3 HR3] ⇒ let [g ⊢ i_s1l I] = i in ?
       | [g ⊢ fc_synr FL3 LL3 HL3 FR3 LR3 HR3] ⇒ let [g ⊢ i_s1l I] = i in ?)
  | [g ⊢ fc_parr F1' H1 N1] ⇒ ?
  | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ ?
  | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ ?
  | [g ⊢ fc_nu \a.F1'] ⇒ ?
;
}%
%{
     (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ ?
       | [g ⊢ fc_parr F2' H2 N2] ⇒ ?
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ ?
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ ?)
}%
%{
  | [g ⊢ fw (fo_nu_cl (\a.O1) (\a.L1) (\a.F1))] ⇒ ?
  | [g ⊢ fw (fo_kpref F1 (\a.H1) I1)] ⇒ ?
  | [g ⊢ fw (fo_suml F1 D1)] ⇒ ?
  | [g ⊢ fw (fo_sumr F1 D1)] ⇒ ?
  | [g ⊢ fw (fo_parl F1 (\a.H1) N1)] ⇒ ?
  | [g ⊢ fw (fc_parr F1 (\a.H1) N1)] ⇒ ?
  | [g ⊢ fw (fo_nu_op \a.F1)] ⇒ ?}%



rec key_in_source_of_fstep_cl: (g:ctx) [g ⊢ fstep_cl X T Y] → [g ⊢ key T K[]] → [g ⊢ notin K[] X] =
/ total f (key_in_source_of_fstep_cl _ _ _ _ _ f _) /
fn f,h ⇒ case f of
  | [g ⊢ fc_pref D] ⇒ let [g ⊢ key_base]:[g ⊢ key _ K[]] = h in
    let [g ⊢ N] = no_key_in_std [⊢ K] [g ⊢ D] in [g ⊢ not_pref N]
  | [g ⊢ fc_kpref F H I] ⇒ let [g ⊢ refk] = functional_key h [g ⊢ H] in
    let [g ⊢ I'] = symmetric_neq [g ⊢ I] in
    let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F] [g ⊢ H] in [g ⊢ not_kpref I' N]
  | [g ⊢ fc_suml F D] ⇒ let [g ⊢ key_suml H]:[g ⊢ key _ K[]] = h in
    let [g ⊢ N1] = key_in_source_of_fstep_cl [g ⊢ F] [g ⊢ H] in
    let [g ⊢ N2] = no_key_in_std [⊢ K] [g ⊢ D] in [g ⊢ not_sum N1 N2]
  | [g ⊢ fc_sumr F D] ⇒ let [g ⊢ key_sumr H]:[g ⊢ key _ K[]] = h in
    let [g ⊢ N2] = key_in_source_of_fstep_cl [g ⊢ F] [g ⊢ H] in
    let [g ⊢ N1] = no_key_in_std [⊢ K] [g ⊢ D] in [g ⊢ not_sum N1 N2]
  | [g ⊢ fc_parl F1 H1 N2] ⇒ let [g ⊢ key_parl H] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H1] in
    let [g ⊢ N1] = key_in_source_of_fstep_cl [g ⊢ F1] [g ⊢ H1] in [g ⊢ not_par N1 N2]
  | [g ⊢ fc_parr F2 H2 N1] ⇒ let [g ⊢ key_parr H] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ H2] in
    let [g ⊢ N2] = key_in_source_of_fstep_cl [g ⊢ F2] [g ⊢ H2] in [g ⊢ not_par N1 N2]
  | [g ⊢ fc_synl FL _ HL FR _ HR] ⇒ let [g ⊢ key_sync H] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ HL] in
    let [g ⊢ N1] = key_in_source_of_fstep_cl [g ⊢ FL] [g ⊢ HL] in
    let [g ⊢ N2] = key_in_source_of_fstep_cl [g ⊢ FR] [g ⊢ HR] in [g ⊢ not_par N1 N2]
  | [g ⊢ fc_synr FL _ HL FR _ HR] ⇒ let [g ⊢ key_sync H] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H] [g ⊢ HL] in
    let [g ⊢ N1] = key_in_source_of_fstep_cl [g ⊢ FL] [g ⊢ HL] in
    let [g ⊢ N2] = key_in_source_of_fstep_cl [g ⊢ FR] [g ⊢ HR] in [g ⊢ not_par N1 N2]
  | [g ⊢ fc_nu \a.F] ⇒ let [g ⊢ H] = h in
    let [g,a:names ⊢ N] = key_in_source_of_fstep_cl [_ ⊢ F] [_ ⊢ H[..]] in [g ⊢ not_nu \a.N]
;



rec unique_pr_labels_in_diamonds_fcfc: (g:ctx) {F1:[g ⊢ fstep_cl X T1 Y]} {F2:[g ⊢ fstep_cl Y T2 Z]}
  {F3:[g ⊢ fstep_cl X T3 W]} {F4:[g ⊢ fstep_cl W T4 Z]} [g ⊢ key T1 K[]] →
  [g ⊢ key T4 K[]] → [g ⊢ eqplc T1 T4] =
/ total {x f1} (unique_pr_labels_in_diamonds_fcfc _ x _ _ _ _ _ _ _ _ f1 _ _ _ _ _) /
mlam F1,F2,F3,F4 ⇒ fn h1,h4 ⇒ let [g ⊢ F1]:[g ⊢ fstep_cl X T1 Y] = [_ ⊢ F1] in
let [g ⊢ F4]:[g ⊢ fstep_cl W T4 Z] = [g ⊢ F4] in
case [g ⊢ T1] of
  | [g ⊢ pr_base A M[]] ⇒ let [g ⊢ key_base] = h1 in (case [g ⊢ T4] of
       | [g ⊢ pr_base B N[]] ⇒ let [g ⊢ key_base] = h4 in
         (case [g ⊢ F1] of
           | [g ⊢ fc_pref _] ⇒ let [g ⊢ fc_kpref _ _ _] = [g ⊢ F2] in
             let [g ⊢ fc_pref _] = [g ⊢ F3] in 
             let [g ⊢ fc_kpref _ _ _] = [g ⊢ F4] in
             impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl key_base] [g ⊢ key_cl key_base]
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             let [g,a:names ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_base] [_ ⊢ key_base] in [g ⊢ refplc])
       | [g ⊢ pr_suml T4'] ⇒ let [g ⊢ key_suml H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_pref _] ⇒ let [g ⊢ fc_kpref _ _ _] = [g ⊢ F2] in
             let [g ⊢ fc_pref _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref _ _ _] = [g ⊢ F4] in
             impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl key_base] [g ⊢ key_cl (key_suml H4)]
           | [g ⊢ fc_kpref F1' H1' N1] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_base] [_ ⊢ key_suml H4[..]])
       | [g ⊢ pr_sumr T4'] ⇒ let [g ⊢ key_sumr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_pref _] ⇒ let [g ⊢ fc_kpref _ _ _] = [g ⊢ F2] in
             let [g ⊢ fc_pref _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref _ _ _] = [g ⊢ F4] in
             impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl key_base] [g ⊢ key_cl (key_sumr H4)]
           | [g ⊢ fc_kpref F1' H1' N1] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_base] [_ ⊢ key_sumr H4[..]])
       | [g ⊢ pr_parl T4'] ⇒ let [g ⊢ key_parl H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_pref _] ⇒ let [g ⊢ fc_kpref _ _ _] = [g ⊢ F2] in
             let [g ⊢ fc_pref _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref _ _ _] = [g ⊢ F4] in
             impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl key_base] [g ⊢ key_cl (key_parl H4)]
           | [g ⊢ fc_kpref F1' H1' N1] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_base] [_ ⊢ key_parl H4[..]])
       | [g ⊢ pr_parr T4'] ⇒ let [g ⊢ key_parr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_pref _] ⇒ let [g ⊢ fc_kpref _ _ _] = [g ⊢ F2] in
             let [g ⊢ fc_pref _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref _ _ _] = [g ⊢ F4] in
             impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl key_base] [g ⊢ key_cl (key_parr H4)]
           | [g ⊢ fc_kpref F1' H1' N1] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_base] [_ ⊢ key_parr H4[..]])
       | [g ⊢ pr_sync TL4 TR4] ⇒ let [g ⊢ key_sync HL4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_pref _] ⇒ let [g ⊢ fc_kpref _ _ _] = [g ⊢ F2] in
             let [g ⊢ fc_pref _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref _ _ _] = [g ⊢ F4] in
             impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl key_base] [g ⊢ key_cl (key_sync HL4)]
           | [g ⊢ fc_kpref F1' H1' N1] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_base] [_ ⊢ key_sync HL4[..]]))
  | [g ⊢ pr_suml T1'] ⇒ let [g ⊢ key_suml H1] = h1 in (case [g ⊢ T4] of
       | [g ⊢ pr_base B N[]] ⇒ let [g ⊢ key_base] = h4 in (case [g ⊢ F4] of
           | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F3]
           | [g ⊢ fc_kpref F4' _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F1]
                | [g ⊢ fc_kpref F3' _ _] ⇒ let [g ⊢ fc_kpref F1' _ _] = [g ⊢ F1] in
                  let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4)
           | [g ⊢ fc_nu \a.F4'] ⇒ let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in
             let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in 
             let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_suml H1[..]] [_ ⊢ key_base])
       | [g ⊢ pr_suml T4'] ⇒ let [g ⊢ key_suml H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_suml F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml F2' _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml F3' _] ⇒ let [g ⊢ fc_suml F4' _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]
                     | [g ⊢ fc_sumr F3' _] ⇒ let [g ⊢ fc_suml _ D4] = [g ⊢ F4] in
                       impossible target_is_not_std_fc [g ⊢ F3'] [g ⊢ D4])
                | [g ⊢ fc_sumr _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             let [g,a:names ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_suml H1[..]] [_ ⊢ key_suml H4[..]] in [g ⊢ refplc])
       | [g ⊢ pr_sumr T4'] ⇒ let [g ⊢ key_sumr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_suml F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml F2' _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml F3' _] ⇒ let [g ⊢ fc_sumr _ D4] = [g ⊢ F4] in
                       impossible target_is_not_std_fc [g ⊢ F3'] [g ⊢ D4]
                     | [g ⊢ fc_sumr _ _] ⇒ let [g ⊢ fc_sumr _ D4] = [g ⊢ F4] in
                       impossible target_is_not_std_fc [g ⊢ F2'] [g ⊢ D4])
                | [g ⊢ fc_sumr _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_suml H1[..]] [_ ⊢ key_sumr H4[..]])
       | [g ⊢ pr_parl T4'] ⇒ let [g ⊢ key_parl H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_suml F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml _ _] ⇒ impossible [g ⊢ F4]
                     | [g ⊢ fc_sumr _ _] ⇒ impossible [g ⊢ F4])
                | [g ⊢ fc_sumr _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_suml H1[..]] [_ ⊢ key_parl H4[..]])
       | [g ⊢ pr_parr T4'] ⇒ let [g ⊢ key_parr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_suml F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml _ _] ⇒ impossible [g ⊢ F4]
                     | [g ⊢ fc_sumr _ _] ⇒ impossible [g ⊢ F4])
                | [g ⊢ fc_sumr _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_suml H1[..]] [_ ⊢ key_parr H4[..]])
       | [g ⊢ pr_sync TL4 TR4] ⇒ let [g ⊢ key_sync HL4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_suml F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml _ _] ⇒ impossible [g ⊢ F4]
                     | [g ⊢ fc_sumr _ _] ⇒ impossible [g ⊢ F4])
                | [g ⊢ fc_sumr _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_suml H1[..]] [_ ⊢ key_sync HL4[..]]))
  | [g ⊢ pr_sumr T1'] ⇒ let [g ⊢ key_sumr H1] = h1 in (case [g ⊢ T4] of
       | [g ⊢ pr_base B N[]] ⇒ let [g ⊢ key_base] = h4 in (case [g ⊢ F4] of
           | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F3]
           | [g ⊢ fc_kpref F4' _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F1]
                | [g ⊢ fc_kpref F3' _ _] ⇒ let [g ⊢ fc_kpref F1' _ _] = [g ⊢ F1] in
                  let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4)
           | [g ⊢ fc_nu \a.F4'] ⇒ let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in
             let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in 
             let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sumr H1[..]] [_ ⊢ key_base])
       | [g ⊢ pr_suml T4'] ⇒ let [g ⊢ key_suml H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_sumr F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
                | [g ⊢ fc_sumr F2' _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml _ _] ⇒ let [g ⊢ fc_suml _ D4] = [g ⊢ F4] in
                       impossible target_is_not_std_fc [g ⊢ F2'] [g ⊢ D4]
                     | [g ⊢ fc_sumr F3' _] ⇒ let [g ⊢ fc_suml _ D4] = [g ⊢ F4] in
                       impossible target_is_not_std_fc [g ⊢ F3'] [g ⊢ D4]))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sumr H1[..]] [_ ⊢ key_suml H4[..]])
       | [g ⊢ pr_sumr T4'] ⇒ let [g ⊢ key_sumr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_sumr F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
                | [g ⊢ fc_sumr F2' _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml F3' _] ⇒ let [g ⊢ fc_sumr _ D4] = [g ⊢ F4] in
                       impossible target_is_not_std_fc [g ⊢ F3'] [g ⊢ D4]
                     | [g ⊢ fc_sumr F3' _] ⇒ let [g ⊢ fc_sumr F4' _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             let [g,a:names ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sumr H1[..]] [_ ⊢ key_sumr H4[..]] in [g ⊢ refplc])
       | [g ⊢ pr_parl T4'] ⇒ let [g ⊢ key_parl H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_sumr F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
                | [g ⊢ fc_sumr _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml _ _] ⇒ impossible [g ⊢ F4]
                     | [g ⊢ fc_sumr _ _] ⇒ impossible [g ⊢ F4]))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sumr H1[..]] [_ ⊢ key_parl H4[..]])
       | [g ⊢ pr_parr T4'] ⇒ let [g ⊢ key_parr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_sumr F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
                | [g ⊢ fc_sumr _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml _ _] ⇒ impossible [g ⊢ F4]
                     | [g ⊢ fc_sumr _ _] ⇒ impossible [g ⊢ F4]))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sumr H1[..]] [_ ⊢ key_parr H4[..]])
       | [g ⊢ pr_sync TL4 TR4] ⇒ let [g ⊢ key_sync HL4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_sumr F1' _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_suml _ D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
                | [g ⊢ fc_sumr _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_suml _ _] ⇒ impossible [g ⊢ F4]
                     | [g ⊢ fc_sumr _ _] ⇒ impossible [g ⊢ F4]))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sumr H1[..]] [_ ⊢ key_sync HL4[..]]))
  | [g ⊢ pr_parl T1'] ⇒ let [g ⊢ key_parl H1] = h1 in (case [g ⊢ T4] of
       | [g ⊢ pr_base B N[]] ⇒ let [g ⊢ key_base] = h4 in (case [g ⊢ F4] of
           | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F3]
           | [g ⊢ fc_kpref F4' _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F1]
                | [g ⊢ fc_kpref F3' _ _] ⇒ let [g ⊢ fc_kpref F1' _ _] = [g ⊢ F1] in
                  let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4)
           | [g ⊢ fc_nu \a.F4'] ⇒ let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in
             let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in 
             let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parl H1[..]] [_ ⊢ key_base])
       | [g ⊢ pr_suml T4'] ⇒ let [g ⊢ key_suml H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parl H1[..]] [_ ⊢ key_suml H4[..]])
       | [g ⊢ pr_sumr T4'] ⇒ let [g ⊢ key_sumr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parl H1[..]] [_ ⊢ key_sumr H4[..]])
       | [g ⊢ pr_parl T4'] ⇒ let [g ⊢ key_parl H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parl F1' H1' N1] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_parl F2' _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]
                     | [g ⊢ fc_parr F3' _ _] ⇒ let [g ⊢ fc_parl _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ F3']
                     | [g ⊢ fc_synl _ _ _ FR3 _ _] ⇒ let [g ⊢ fc_parl _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FR3]
                     | [g ⊢ fc_synr _ _ _ FR3 _ _] ⇒ let [g ⊢ fc_parl _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FR3])
                | [g ⊢ fc_parr F2' H2 N2] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ F2']
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F1'] [g ⊢ F4'] in [g ⊢ refplc]
                     | [g ⊢ fc_synl FL3 _ HL3 FR3 _ HR3] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F2'] [g ⊢ FR3] in
                       let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR3] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ F4'] [g ⊢ N2])
                     | [g ⊢ fc_synr FL3 _ HL3 FR3 _ HR3] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F2'] [g ⊢ FR3] in
                       let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HR3] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ F4'] [g ⊢ N2]))
                | [g ⊢ fc_synl FL2 _ HL2 FR2 _ HR2] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FR2]
                     | [g ⊢ fc_parr F3' H3 N3] ⇒ let [g ⊢ fc_parl F4' H4' _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FR2] [g ⊢ F3'] in
                       let [g ⊢ refk]:[g ⊢ eqk N[] N[]] = functional_key [g ⊢ HR2] [g ⊢ H3] in
                       let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1'] [g ⊢ fc FL2] [g ⊢ key_cl H1] [g ⊢ key_cl HL2]
                          | [g ⊢ c_neq I] ⇒ impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ F4'] [g ⊢ H4] [g ⊢ N3] [g ⊢ I]))
                     | [g ⊢ fc_synl FL3 _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]
                     | [g ⊢ fc_synr FL3 _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc])
                | [g ⊢ fc_synr FL2 _ HL2 FR2 _ HR2] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FR2]
                     | [g ⊢ fc_parr F3' H3 N3] ⇒ let [g ⊢ fc_parl F4' H4' _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FR2] [g ⊢ F3'] in
                       let [g ⊢ refk]:[g ⊢ eqk N[] N[]] = functional_key [g ⊢ HR2] [g ⊢ H3] in
                       let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1'] [g ⊢ fc FL2] [g ⊢ key_cl H1] [g ⊢ key_cl HL2]
                          | [g ⊢ c_neq I] ⇒ impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ F4'] [g ⊢ H4] [g ⊢ N3] [g ⊢ I]))
                     | [g ⊢ fc_synl FL3 _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]
                     | [g ⊢ fc_synr FL3 _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             let [g,a:names ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parl H1[..]] [_ ⊢ key_parl H4[..]] in [g ⊢ refplc])
       | [g ⊢ pr_parr T4'] ⇒ let [g ⊢ key_parr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parl F1' H1' N1] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ F4']
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F4'] [g ⊢ H4] [g ⊢ N1]
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F4'] [g ⊢ H4] [g ⊢ N1]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F4'] [g ⊢ H4] [g ⊢ N1])
                | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4]
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4])
                | [g ⊢ fc_synl FL2 _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4]))
                | [g ⊢ fc_synr FL2 _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parl H1[..]] [_ ⊢ key_parr H4[..]])
       | [g ⊢ pr_sync TL4 TR4] ⇒ let [g ⊢ key_sync HL4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parl F1' H1' N1] ⇒ let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ H1] [g ⊢ H1'] in
             (case [g ⊢ F2] of
                | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1]
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1])
                     | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1]
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1]
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1]
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] [g ⊢ N1]))
                | [g ⊢ fc_parr F2' H2 _] ⇒ let [g ⊢ H2]:[g ⊢ key _ N[]] = [g ⊢ H2] in
                  (case dec_eq_keys [g] [⊢ N] [⊢ K] of
                     | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_parl H1)] [g ⊢ key_cl (key_parr H2)]
                     | [g ⊢ c_neq I] ⇒ (case [g ⊢ F3] of
                          | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))))
                | [g ⊢ fc_synl _ _ HL2 FR2 _ HR2] ⇒ let [g ⊢ HR2]:[g ⊢ key _ N[]] = [g ⊢ HR2] in
                  (case dec_eq_keys [g] [⊢ N] [⊢ K] of
                     | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_parl H1)] [g ⊢ key_cl (key_sync HL2)]
                     | [g ⊢ c_neq I] ⇒ (case [g ⊢ F3] of
                          | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I]))))
                | [g ⊢ fc_synr _ _ HL2 FR2 _ HR2] ⇒ let [g ⊢ HR2]:[g ⊢ key _ N[]] = [g ⊢ HR2] in
                  (case dec_eq_keys [g] [⊢ N] [⊢ K] of
                     | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_parl H1)] [g ⊢ key_cl (key_sync HL2)]
                     | [g ⊢ c_neq I] ⇒ (case [g ⊢ F3] of
                          | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] [g ⊢ I])))))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parl H1[..]] [_ ⊢ key_sync HL4[..]]))
  | [g ⊢ pr_parr T1'] ⇒ let [g ⊢ key_parr H1] = h1 in (case [g ⊢ T4] of
       | [g ⊢ pr_base B N[]] ⇒ let [g ⊢ key_base] = h4 in (case [g ⊢ F4] of
           | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F3]
           | [g ⊢ fc_kpref F4' _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F1]
                | [g ⊢ fc_kpref F3' _ _] ⇒ let [g ⊢ fc_kpref F1' _ _] = [g ⊢ F1] in
                  let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4)
           | [g ⊢ fc_nu \a.F4'] ⇒ let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in
             let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in 
             let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parr H1[..]] [_ ⊢ key_base])
       | [g ⊢ pr_suml T4'] ⇒ let [g ⊢ key_suml H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parr H1[..]] [_ ⊢ key_suml H4[..]])
       | [g ⊢ pr_sumr T4'] ⇒ let [g ⊢ key_sumr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parr H1[..]] [_ ⊢ key_sumr H4[..]])
       | [g ⊢ pr_parl T4'] ⇒ let [g ⊢ key_parl H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parr F1' H1' N1] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4]
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] [g ⊢ N4])
                | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F4'] [g ⊢ H4] [g ⊢ N1]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ F4']
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F4'] [g ⊢ H4] [g ⊢ N1]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' _ _] = [g ⊢ F4] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F4'] [g ⊢ H4] [g ⊢ N1])
                | [g ⊢ fc_synl _ _ _ FR2 _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4]))
                | [g ⊢ fc_synr _ _ _ FR2 _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ F1'] [g ⊢ H1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parr H1[..]] [_ ⊢ key_parl H4[..]])
       | [g ⊢ pr_parr T4'] ⇒ let [g ⊢ key_parr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parr F1' H1' N1] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_parl F2' H2 N2] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F1'] [g ⊢ F4'] in [g ⊢ refplc]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ F2']
                     | [g ⊢ fc_synl FL3 _ HL3 FR3 _ HR3] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F2'] [g ⊢ FL3] in
                       let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL3] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ F4'] [g ⊢ N2])
                     | [g ⊢ fc_synr FL3 _ HL3 FR3 _ HR3] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ F2'] [g ⊢ FL3] in
                       let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ HL3] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ F4'] [g ⊢ N2]))
                | [g ⊢ fc_parr F2' _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' _ _] ⇒ let [g ⊢ fc_parr _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ F3']
                     | [g ⊢ fc_parr F3' _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]
                     | [g ⊢ fc_synl FL3 _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FL3]
                     | [g ⊢ fc_synr FL3 _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FL3])
                | [g ⊢ fc_synl FL2 _ HL2 FR2 _ HR2] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' H3 N3] ⇒ let [g ⊢ fc_parr F4' H4' _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FL2] [g ⊢ F3'] in
                       let [g ⊢ refk]:[g ⊢ eqk N[] N[]] = functional_key [g ⊢ HL2] [g ⊢ H3] in
                       let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1'] [g ⊢ fc FR2] [g ⊢ key_cl H1] [g ⊢ key_cl HR2]
                          | [g ⊢ c_neq I] ⇒ impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ F4'] [g ⊢ H4] [g ⊢ N3] [g ⊢ I]))
                     | [g ⊢ fc_parr F3' _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FL2]
                     | [g ⊢ fc_synl _ _ _ FR3 _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]
                     | [g ⊢ fc_synr _ _ _ FR3 _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc])
                | [g ⊢ fc_synr FL2 _ HL2 FR2 _ HR2] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' H3 N3] ⇒ let [g ⊢ fc_parr F4' H4' _] = [g ⊢ F4] in
                       let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FL2] [g ⊢ F3'] in
                       let [g ⊢ refk]:[g ⊢ eqk N[] N[]] = functional_key [g ⊢ HL2] [g ⊢ H3] in
                       let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1'] [g ⊢ fc FR2] [g ⊢ key_cl H1] [g ⊢ key_cl HR2]
                          | [g ⊢ c_neq I] ⇒ impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ F4'] [g ⊢ H4] [g ⊢ N3] [g ⊢ I]))
                     | [g ⊢ fc_parr F3' _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       impossible target_is_not_source_fc [g ⊢ FL2]
                     | [g ⊢ fc_synl _ _ _ FR3 _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]
                     | [g ⊢ fc_synr _ _ _ FR3 _ _] ⇒ let [g ⊢ fc_parr F4' _ _] = [g ⊢ F4] in
                       let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ F4'] [g ⊢ H1] [g ⊢ H4] in [g ⊢ refplc]))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             let [g,a:names ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parr H1[..]] [_ ⊢ key_parr H4[..]] in [g ⊢ refplc])
       | [g ⊢ pr_sync TL4 TR4] ⇒ let [g ⊢ key_sync HL4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_parr F1' H1' N1] ⇒ let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ H1] [g ⊢ H1'] in
             (case [g ⊢ F2] of
                | [g ⊢ fc_parl F2' H2 _] ⇒ let [g ⊢ H2]:[g ⊢ key _ N[]] = [g ⊢ H2] in
                  (case dec_eq_keys [g] [⊢ N] [⊢ K] of
                     | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_parr H1)] [g ⊢ key_cl (key_parl H2)]
                     | [g ⊢ c_neq I] ⇒ (case [g ⊢ F3] of
                          | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] [g ⊢ I]))))
                | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1]
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1])
                     | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1]
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1]
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1]
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] [g ⊢ N1]))
                | [g ⊢ fc_synl FL2 _ HL2 _ _ HR2] ⇒ let [g ⊢ HL2]:[g ⊢ key _ N[]] = [g ⊢ HL2] in
                  (case dec_eq_keys [g] [⊢ N] [⊢ K] of
                     | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_parr H1)] [g ⊢ key_cl (key_sync HL2)]
                     | [g ⊢ c_neq I] ⇒ (case [g ⊢ F3] of
                          | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I]))))
                | [g ⊢ fc_synr FL2 _ HL2 _ _ HR2] ⇒ let [g ⊢ HL2]:[g ⊢ key _ N[]] = [g ⊢ HL2] in
                  (case dec_eq_keys [g] [⊢ N] [⊢ K] of
                     | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_parr H1)] [g ⊢ key_cl (key_sync HL2)]
                     | [g ⊢ c_neq I] ⇒ (case [g ⊢ F3] of
                          | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I]))
                          | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] [g ⊢ I])))))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_parr H1[..]] [_ ⊢ key_sync HL4[..]]))
  | [g ⊢ pr_sync TL1 TR1] ⇒ let [g ⊢ key_sync HL1] = h1 in (case [g ⊢ T4] of
       | [g ⊢ pr_base B N[]] ⇒ let [g ⊢ key_base] = h4 in (case [g ⊢ F4] of
           | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F3]
           | [g ⊢ fc_kpref F4' _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_pref _] ⇒ impossible [g ⊢ F1]
                | [g ⊢ fc_kpref F3' _ _] ⇒ let [g ⊢ fc_kpref F1' _ _] = [g ⊢ F1] in
                  let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4)
           | [g ⊢ fc_nu \a.F4'] ⇒ let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in
             let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in 
             let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sync HL1[..]] [_ ⊢ key_base])
       | [g ⊢ pr_suml T4'] ⇒ let [g ⊢ key_suml H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sync HL1[..]] [_ ⊢ key_suml H4[..]])
       | [g ⊢ pr_sumr T4'] ⇒ let [g ⊢ key_sumr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                | [g ⊢ fc_parl _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_parr _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ impossible [g ⊢ F4]
                | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ impossible [g ⊢ F4])
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sync HL1[..]] [_ ⊢ key_sumr H4[..]])
       | [g ⊢ pr_parl T4'] ⇒ let [g ⊢ key_parl H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_synl _ _ HL1' FR1 _ HR1] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL1] [g ⊢ HL1'] in
             (case [g ⊢ F2] of
                | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4]
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4])
                | [g ⊢ fc_parr F2' _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4]))
                | [g ⊢ fc_synl _ _ _ FR2 _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4]))
                | [g ⊢ fc_synr _ _ _ FR2 _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])))
           | [g ⊢ fc_synr _ _ HL1' FR1 _ HR1] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL1] [g ⊢ HL1'] in
             (case [g ⊢ F2] of
                | [g ⊢ fc_parl _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4]
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N4])
                | [g ⊢ fc_parr F2' _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4]))
                | [g ⊢ fc_synl _ _ _ FR2 _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4]))
                | [g ⊢ fc_synr _ _ _ FR2 _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parl _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FR1] [g ⊢ HR1] (notin_propagates_to_source_fc [g ⊢ FR2] [g ⊢ N4])))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sync HL1[..]] [_ ⊢ key_parl H4[..]])
       | [g ⊢ pr_parr T4'] ⇒ let [g ⊢ key_parr H4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in impossible unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_synl FL1 _ HL1' _ _ _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_parl F2' _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4]))
                | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4]
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4])
                | [g ⊢ fc_synl FL2 _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4]))
                | [g ⊢ fc_synr FL2 _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])))
           | [g ⊢ fc_synr FL1 _ HL1' _ _ _] ⇒ (case [g ⊢ F2] of
                | [g ⊢ fc_parl F2' _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ F2'] [g ⊢ N4]))
                | [g ⊢ fc_parr _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4]
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4]
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4]
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr F4' H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N4])
                | [g ⊢ fc_synl FL2 _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4]))
                | [g ⊢ fc_synr FL2 _ _ _ _ _] ⇒ (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_parr _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synl _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])
                     | [g ⊢ fc_synr _ _ _ _ _ _] ⇒ let [g ⊢ fc_parr _ H4' N4] = [g ⊢ F4] in
                       let [g ⊢ refk] = functional_key [g ⊢ H4] [g ⊢ H4'] in
                       impossible key_in_target_of_fstep_cl [g ⊢ FL1] [g ⊢ HL1] (notin_propagates_to_source_fc [g ⊢ FL2] [g ⊢ N4])))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             impossible unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sync HL1[..]] [_ ⊢ key_parr H4[..]])
       | [g ⊢ pr_sync TL4 TR4] ⇒ let [g ⊢ key_sync HL4] = h4 in (case [g ⊢ F1] of
           | [g ⊢ fc_kpref F1' _ _] ⇒ let [g ⊢ fc_kpref F2' _ _] = [g ⊢ F2] in
             let [g ⊢ fc_kpref F3' _ _] = [g ⊢ F3] in
             let [g ⊢ fc_kpref F4' _ _] = [g ⊢ F4] in unique_pr_labels_in_diamonds_fcfc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ F3'] [g ⊢ F4'] h1 h4
           | [g ⊢ fc_synl FL1 LL1 HL1' FR1 LR1 HR1] ⇒ let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ HL1] [g ⊢ HL1'] in
             (case [g ⊢ F2] of
                | [g ⊢ fc_parl F2' H2 _] ⇒ let [g ⊢ H2]:[g ⊢ key _ N[]] = [g ⊢ H2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ _ FR4 _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FR1] [g ⊢ FR4] in [g ⊢ refplc]
                          | [g ⊢ fc_synr FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4])
                     | [g ⊢ fc_parr _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_parl H2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N]) [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N]) [g ⊢ I])))
                     | [g ⊢ fc_synl _ _ HL3 FR3 _ HR3] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I]))))
                     | [g ⊢ fc_synr _ _ HL3 FR3 _ HR3] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I])))))
                | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g ⊢ H2]:[g ⊢ key _ N[]] = [g ⊢ H2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_parr H2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N]) [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N]) [g ⊢ I])))
                     | [g ⊢ fc_parr F3' _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in
                            let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FL1] [g ⊢ FL4] in [g ⊢ refplc]
                          | [g ⊢ fc_synr _ _ HL4' FR4 LR4 HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in
                            impossible functional_lab [g ⊢ LR1] [g ⊢ LR4])
                     | [g ⊢ fc_synl FL3 _ HL3 _ _ _] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I]))))
                     | [g ⊢ fc_synr FL3 _ HL3 _ _ _] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I])))))
                | [g ⊢ fc_synl FL2 LL2 HL2 FR2 _ HR2] ⇒ let [g ⊢ HL2]:[g ⊢ key _ N[]] = [g ⊢ HL2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])))
                     | [g ⊢ fc_parr _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])))
                     | [g ⊢ fc_synl FL3 _ _ FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in [g ⊢ refplc]
                          | [g ⊢ fc_synr FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4])
                     | [g ⊢ fc_synr FL3 LL3 HL3 FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                            let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ N] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL3] [_ ⊢ FL4] [_ ⊢ FL1] [_ ⊢ FL2] [g ⊢ HL3] [g ⊢ HL2] in
                                 impossible functional_lab [g ⊢ LL2] [g ⊢ LL3]
                               | [g ⊢ c_neq I1] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                                    | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                                    | [g ⊢ c_neq I2] ⇒ let [g ⊢ NQ] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                      impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ NQ] [g ⊢ I2]) [g ⊢ I1]))))
                          | [g ⊢ fc_synr FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4]))
                | [g ⊢ fc_synr FL2 LL2 HL2 FR2 _ HR2] ⇒ let [g ⊢ HL2]:[g ⊢ key _ N[]] = [g ⊢ HL2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])))
                     | [g ⊢ fc_parr _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])))
                     | [g ⊢ fc_synl FL3 LL3 HL3 FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                            let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ N] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL3] [_ ⊢ FL4] [_ ⊢ FL1] [_ ⊢ FL2] [g ⊢ HL3] [g ⊢ HL2] in
                                 impossible functional_lab [g ⊢ LL2] [g ⊢ LL3]
                               | [g ⊢ c_neq I1] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                                    | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                                    | [g ⊢ c_neq I2] ⇒ let [g ⊢ NQ] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                      impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ NQ] [g ⊢ I2]) [g ⊢ I1]))))
                          | [g ⊢ fc_synr FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4])
                     | [g ⊢ fc_synr FL3 _ _ FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in [g ⊢ refplc]
                          | [g ⊢ fc_synr FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4])))
           | [g ⊢ fc_synr FL1 LL1 HL1' FR1 LR1 HR1] ⇒ let [g ⊢ refk]:[g ⊢ eqk K[] K[]] = functional_key [g ⊢ HL1] [g ⊢ HL1'] in
             (case [g ⊢ F2] of
                | [g ⊢ fc_parl F2' H2 _] ⇒ let [g ⊢ H2]:[g ⊢ key _ N[]] = [g ⊢ H2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl F3' _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4]
                          | [g ⊢ fc_synr FL4 _ _ FR4 _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FR1] [g ⊢ FR4] in [g ⊢ refplc])
                     | [g ⊢ fc_parr _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_parl H2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N]) [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N]) [g ⊢ I])))
                     | [g ⊢ fc_synl _ _ HL3 FR3 _ HR3] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I]))))
                     | [g ⊢ fc_synr _ _ HL3 FR3 _ HR3] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR3] [g ⊢ HR3] (notin_propagates_to_source_fc [g ⊢ FR4] (notin_propagates_to_target_fc [g ⊢ FR1] [g ⊢ HR1] [g ⊢ N] [g ⊢ I])))))
                | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g ⊢ H2]:[g ⊢ key _ N[]] = [g ⊢ H2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_parr H2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N]) [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ F2'] [g ⊢ H2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N]) [g ⊢ I])))
                     | [g ⊢ fc_parr F3' _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl _ _ HL4' FR4 LR4 HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in
                            impossible functional_lab [g ⊢ LR1] [g ⊢ LR4]
                          | [g ⊢ fc_synr FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in
                            let [g ⊢ reffc] = unique_fstep_cl [g ⊢ FL1] [g ⊢ FL4] in [g ⊢ refplc])
                     | [g ⊢ fc_synl FL3 _ HL3 _ _ _] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I]))))
                     | [g ⊢ fc_synr FL3 _ HL3 _ _ _] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                       (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I])))
                          | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                               | [g ⊢ c_neq I] ⇒ let [g ⊢ N] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ N] [g ⊢ I])))))
                | [g ⊢ fc_synl FL2 LL2 HL2 FR2 _ HR2] ⇒ let [g ⊢ HL2]:[g ⊢ key _ N[]] = [g ⊢ HL2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])))
                     | [g ⊢ fc_parr _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])))
                     | [g ⊢ fc_synl FL3 _ _ FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4]
                          | [g ⊢ fc_synr FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in [g ⊢ refplc])
                     | [g ⊢ fc_synr FL3 LL3 HL3 FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4]
                          | [g ⊢ fc_synr FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                            let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ N] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL3] [_ ⊢ FL4] [_ ⊢ FL1] [_ ⊢ FL2] [g ⊢ HL3] [g ⊢ HL2] in
                                 impossible functional_lab [g ⊢ LL2] [g ⊢ LL3]
                               | [g ⊢ c_neq I1] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                                    | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                                    | [g ⊢ c_neq I2] ⇒ let [g ⊢ NQ] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                      impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ NQ] [g ⊢ I2]) [g ⊢ I1]))))))
                | [g ⊢ fc_synr FL2 LL2 HL2 FR2 _ HR2] ⇒ let [g ⊢ HL2]:[g ⊢ key _ N[]] = [g ⊢ HL2] in
                  (case [g ⊢ F3] of
                     | [g ⊢ fc_parl _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])
                               | [g ⊢ fc_synr _ _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NR2] = key_in_source_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FR2] [g ⊢ HR2] (notin_propagates_to_target_fc [g ⊢ FR4] [g ⊢ HR4] (notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ NR2]) [g ⊢ I])))
                     | [g ⊢ fc_parr _ _ _] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ N] of
                          | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F1] [g ⊢ fc F2] [g ⊢ key_cl (key_sync HL1)] [g ⊢ key_cl (key_sync HL2)]
                          | [g ⊢ c_neq I] ⇒ (case [g ⊢ F4] of
                               | [g ⊢ fc_synl FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])
                               | [g ⊢ fc_synr FL4 _ HL4' _ _ _] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                                 let [g ⊢ NL2] = key_in_source_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] in
                                 impossible key_in_target_of_fstep_cl [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL4] [g ⊢ HL4] (notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ NL2]) [g ⊢ I])))
                     | [g ⊢ fc_synl FL3 LL3 HL3 FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4]
                          | [g ⊢ fc_synr FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ HL3]:[g ⊢ key _ M[]] = [g ⊢ HL3] in
                            let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            (case dec_eq_keys [g] [⊢ N] [⊢ M] of
                               | [g ⊢ c_eq] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL3] [_ ⊢ FL4] [_ ⊢ FL1] [_ ⊢ FL2] [g ⊢ HL3] [g ⊢ HL2] in
                                 impossible functional_lab [g ⊢ LL2] [g ⊢ LL3]
                               | [g ⊢ c_neq I1] ⇒ (case dec_eq_keys [g] [⊢ K] [⊢ M] of
                                    | [g ⊢ c_eq] ⇒ impossible no_composable_fw_tr_with_same_key [g ⊢ fc F3] [g ⊢ fc F4] [g ⊢ key_cl (key_sync HL3)] [g ⊢ key_cl (key_sync HL4)]
                                    | [g ⊢ c_neq I2] ⇒ let [g ⊢ NQ] = key_in_source_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] in
                                      impossible key_in_target_of_fstep_cl [g ⊢ FL3] [g ⊢ HL3] (notin_propagates_to_source_fc [g ⊢ FL4] (notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] (notin_propagates_to_target_fc [g ⊢ FL1] [g ⊢ HL1] [g ⊢ NQ] [g ⊢ I2]) [g ⊢ I1])))))
                     | [g ⊢ fc_synr FL3 _ _ FR3 _ _] ⇒ (case [g ⊢ F4] of
                          | [g ⊢ fc_synl FL4 LL4 _ _ _ _] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            impossible functional_lab [g ⊢ LL1] [g ⊢ LL4]
                          | [g ⊢ fc_synr FL4 _ HL4' FR4 _ HR4] ⇒ let [g ⊢ refk] = functional_key [g ⊢ HL4] [g ⊢ HL4'] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FL1] [_ ⊢ FL2] [_ ⊢ FL3] [_ ⊢ FL4] [g ⊢ HL1] [g ⊢ HL4] in
                            let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ FR1] [_ ⊢ FR2] [_ ⊢ FR3] [_ ⊢ FR4] [g ⊢ HR1] [g ⊢ HR4] in [g ⊢ refplc])))
           | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
             let [g ⊢ fc_nu \a.F3'] = [g ⊢ F3] in 
             let [g ⊢ fc_nu \a.F4'] = [g ⊢ F4] in
             let [g,a:names ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ F3'] [_ ⊢ F4'] [_ ⊢ key_sync HL1[..]] [_ ⊢ key_sync HL4[..]] in [g ⊢ refplc]))
;


rec unique_pr_labels_in_diamonds_fcfo: (g:ctx) {F1:[g ⊢ fstep_cl X T1 Y]} {F2:[g ⊢ fstep_op Y T2 Z]}
  {F3:[g ⊢ fstep_op X T3 W]} {F4:[g ⊢ fstep_cl W T4 Z]} [g ⊢ key T1 K[]] →
  [g ⊢ key T4 K[]] → [g ⊢ eqplc T1 T4] =
?
;

rec unique_pr_labels_in_diamonds_fofc: (g:ctx) {F1:[g ⊢ fstep_op X (open \a.T1) Y]} {F2:[g ⊢ fstep_cl Y T2 Z]}
  {F3:[g ⊢ fstep_cl X T3 W]} {F4:[g ⊢ fstep_op W (open \a.T4) Z]} [g,a:names ⊢ key T1 K[]] →
  [g,a:names ⊢ key T4 K[]] → [g,a:names ⊢ eqplc T1 T4] =
?
;

rec unique_pr_labels_in_diamonds_fofo: (g:ctx) {F1:[g ⊢ fstep_op X (open \a.T1) Y]} {F2:[g ⊢ fstep_op Y T2 Z]}
  {F3:[g ⊢ fstep_op X T3 W]} {F4:[g ⊢ fstep_op W (open \a.T4) Z]} [g,a:names ⊢ key T1 K[]] →
  [g,a:names ⊢ key T4 K[]] → [g,a:names ⊢ eqplc T1 T4] =
?
;

rec unique_pr_labels_in_diamonds: (g:ctx) {S1:[g ⊢ step X T1 Y]} {S2:[g ⊢ step Y T2 Z]}
  {S3:[g ⊢ step X T3 W]} {S4:[g ⊢ step W T4 Z]} [g ⊢ same_direction S1 S4] →
  [g ⊢ same_direction S3 S2] → [g ⊢ key_pl T1 K[]] → [g ⊢ key_pl T4 K[]] → [g ⊢ eqpl T1 T4] =
/ total s1 (unique_pr_labels_in_diamonds _ _ _ _ _ _ _ _ _ _ s1 _ _ _ _ _ _ _) /
mlam S1,S2,S3,S4 ⇒ fn sd1,sd2,h1,h4 ⇒ case sd1 of
  | [g ⊢ sdf (ftc_cl F1) (ftc_cl F4)] ⇒ let [g ⊢ key_cl H1] = h1 in
    let [g ⊢ key_cl H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfc [_ ⊢ F1] [_ ⊢ F2] [_ ⊢ F3] [_ ⊢ F4] [_ ⊢ H1] [_ ⊢ H4] in [_ ⊢ refpl]
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ let [g ⊢ refplc] = unique_pr_labels_in_diamonds_fcfo [_ ⊢ F1] [_ ⊢ F2] [_ ⊢ F3] [_ ⊢ F4] [_ ⊢ H1] [_ ⊢ H4] in [_ ⊢ refpl]
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
  | [g ⊢ sdf (ftc_cl F1) (ftc_op F4)] ⇒ let [g ⊢ key_cl H1] = h1 in
    let [g ⊢ key_op \a.H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
  | [g ⊢ sdf (ftc_op F1) (ftc_cl F4)] ⇒ let [g ⊢ key_op \a.H1] = h1 in
    let [g ⊢ key_cl H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
  | [g ⊢ sdf (ftc_op F1) (ftc_op F4)] ⇒ let [g ⊢ key_op \a.H1] = h1 in
    let [g ⊢ key_op \a.H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
  | [g ⊢ sdb (btc_cl B1) (btc_cl B4)] ⇒ let [g ⊢ key_cl H1] = h1 in
    let [g ⊢ key_cl H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
  | [g ⊢ sdb (btc_cl B1) (btc_op B4)] ⇒ let [g ⊢ key_cl H1] = h1 in
    let [g ⊢ key_op \a.H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
  | [g ⊢ sdb (btc_op B1) (btc_cl B4)] ⇒ let [g ⊢ key_op \a.H1] = h1 in
    let [g ⊢ key_cl H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
  | [g ⊢ sdb (btc_op B1) (btc_op B4)] ⇒ let [g ⊢ key_op \a.H1] = h1 in
    let [g ⊢ key_op \a.H4] = h4 in (case sd2 of
       | [g ⊢ sdf (ftc_cl F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_cl F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_cl F2)] ⇒ ?
       | [g ⊢ sdf (ftc_op F3) (ftc_op F2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_cl B3) (btc_op B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_cl B2)] ⇒ ?
       | [g ⊢ sdb (btc_op B3) (btc_op B2)] ⇒ ?)
;


rec enrich_preserves_key: (g:ctx) (S:[g ⊢ ccsk.step X (ccsk.kl_base A K) Y]) (S+:[g ⊢ ccskp.step X T Y])
 [g ⊢ enrich S S+] → [g ⊢ key_pl T K] =
 ?
 ;

% Propagation of coinitial independence (PCI):
% Given t:step X KL1 Y, u:step X KL2 Z, u':step Y KL2 W and t':step Z KL1 W,
% where (t,t') and (u,u') have same direction,
% if t and u are independent, then u' and inv_tr(t) are independent.
rec ccsk_pci: (g:ctx) (T:[g ⊢ ccsk.step X KL1 Y]) (U:[g ⊢ ccsk.step X KL2 Z])
  (U':[g ⊢ ccsk.step Y KL2 W]) (T':[g ⊢ ccsk.step Z KL1 W]) (RT:[g ⊢ ccsk.step Y KL1 X])
  [g ⊢ ccsk_same_direction T T'] → [g ⊢ ccsk_same_direction U U'] → [g ⊢ ccsk_indep_tr T U] → 
  [g ⊢ ccsk_inv_tr T RT] → [g ⊢ ccsk_indep_tr U' RT] =
/ total (ccsk_pci _ _ _ _ _ _ _ t _ _ _ _ _ _) /
fn sdt,sdu,i,hr ⇒ let [g ⊢ ccsk_ind_tr ENT ENU I _] = i in
let [g ⊢ ENT]:[g ⊢ enrich T T+] = [g ⊢ ENT] in
let [g ⊢ ENU]:[g ⊢ enrich U U+] = [g ⊢ ENU] in
let [g ⊢ _]:[g ⊢ ccsk_same_direction T T'] = sdt in
let [g ⊢ _]:[g ⊢ ccsk_same_direction U U'] = sdu in
let {ENT':[g ⊢ enrich T' T'+]}[g ⊢ ex_en ENT'] = total_enrich [g ⊢ T'] in
let {ENU':[g ⊢ enrich U' U'+]}[g ⊢ ex_en ENU'] = total_enrich [g ⊢ U'] in
let [g ⊢ SDT+]:[g ⊢ same_direction T+ T'+] = sdir_ccsk_to_ccskp sdt [g ⊢ ENT] [g ⊢ ENT'] in
let [g ⊢ SDU+]:[g ⊢ same_direction U+ U'+] = sdir_ccsk_to_ccskp sdu [g ⊢ ENU] [g ⊢ ENU'] in
let [g ⊢ ccsk_it T RT] = hr in
let {ENRT:[g ⊢ enrich RT RT+]}[g ⊢ ex_en ENRT] = total_enrich [g ⊢ RT] in
let [g ⊢ HR+]:[g ⊢ inv_tr T+ RT+] = inv_ccsk_to_ccskp hr [g ⊢ ENT] [g ⊢ ENRT] in
let [g ⊢ it T+ RT+] = [g ⊢ HR+] in
let [g ⊢ I'] = symmetric_indep_pl [g ⊢ I] in
let [g ⊢ _]:[g ⊢ ccsk.step _ (kl_base _ _) _] = [g ⊢ T] in
let [g ⊢ _]:[g ⊢ ccsk.step _ (kl_base _ _) _] = [g ⊢ U] in
let [g ⊢ HT] = enrich_preserves_key [g ⊢ ENT] in
let [g ⊢ HU] = enrich_preserves_key [g ⊢ ENU] in
let [g ⊢ HT'] = enrich_preserves_key [g ⊢ ENT'] in
let [g ⊢ HU'] = enrich_preserves_key [g ⊢ ENU'] in
let [g ⊢ refpl] = unique_pr_labels_in_diamonds [_ ⊢ T+] [_ ⊢ U'+] [_ ⊢ U+] [_ ⊢ T'+] [_ ⊢ SDT+] [_ ⊢ SDU+] [_ ⊢ HT] [_ ⊢ HT'] in
let [g ⊢ refpl] = unique_pr_labels_in_diamonds [_ ⊢ U+] [_ ⊢ T'+] [_ ⊢ T+] [_ ⊢ U'+] [_ ⊢ SDU+] [_ ⊢ SDT+] [_ ⊢ HU] [_ ⊢ HU'] in
[g ⊢ ccsk_ind_tr ENU' ENRT I' (ctr _ _ (ccsk.st_s* RT))]
;