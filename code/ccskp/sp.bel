%%% SP: square property

% If a process X makes a closed forward transition F into the process X',
% and a key K does not occur in X' (i.e., notin K X' holds), then K does
% not occur in X as well (notin K X).
rec notin_propagates_to_source_fc: (g:ctx) [g ⊢ fstep_cl X T X'] →
   [g ⊢ notin K[] X'] → [g ⊢ notin K[] X] =
/ total f (notin_propagates_to_source_fc _ _ _ _ _ f _) /
fn f,n ⇒ case f of
  | [g ⊢ fc_pref _] ⇒ let [g ⊢ not_kpref _ N] = n in [g ⊢ not_pref N]
  | [g ⊢ fc_kpref F _ _] ⇒ let [g ⊢ not_kpref I N] = n in
    let [g ⊢ N'] = notin_propagates_to_source_fc [g ⊢ F] [g ⊢ N] in [g ⊢ not_kpref I N']
  | [g ⊢ fc_suml F1 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in [g ⊢ not_sum N1' N2]
  | [g ⊢ fc_sumr F2 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_sum N1 N2']
  | [g ⊢ fc_parl F1 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in [g ⊢ not_par N1' N2]
  | [g ⊢ fc_parr F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_par N1 N2']
  | [g ⊢ fc_synl F1 _ _ F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_synr F1 _ _ F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fc [g ⊢ F1] [g ⊢ N1] in
    let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_nu \a.F] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g,a:names ⊢ N'] = notin_propagates_to_source_fc [_ ⊢ F] [_ ⊢ N] in [g ⊢ not_nu \a.N']
;

% If a process X makes an open forward transition F into the process X',
% and a key K does not occur in X' (i.e., notin K X' holds), then K does
% not occur in X as well (notin K X).
rec notin_propagates_to_source_fo: (g:ctx) [g ⊢ fstep_op X T X'] →
   [g ⊢ notin K[] X'] → [g ⊢ notin K[] X] =
/ total f (notin_propagates_to_source_fo _ _ _ _ _ f _) /
fn f,n ⇒ case f of
  | [g ⊢ fo_nu_cl (\_._) (\_._) (\a.F)] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g,a:names ⊢ N'] = notin_propagates_to_source_fc [_ ⊢ F] [_ ⊢ N] in [g ⊢ not_nu \a.N']
  | [g ⊢ fo_kpref F (\_._) _] ⇒ let [g ⊢ not_kpref I N] = n in
    let [g ⊢ N'] = notin_propagates_to_source_fo [g ⊢ F] [g ⊢ N] in [g ⊢ not_kpref I N']
  | [g ⊢ fo_suml F1 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fo [g ⊢ F1] [g ⊢ N1] in [g ⊢ not_sum N1' N2]
  | [g ⊢ fo_sumr F2 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_sum N1 N2']
  | [g ⊢ fo_parl F1 (\_._) _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N1'] = notin_propagates_to_source_fo [g ⊢ F1] [g ⊢ N1] in [g ⊢ not_par N1' N2]
  | [g ⊢ fo_parr F2 (\_._) _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F2] [g ⊢ N2] in [g ⊢ not_par N1 N2']
  | [g ⊢ fo_nu_op \a.F] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g,a:names ⊢ N'] = notin_propagates_to_source_fo [_ ⊢ F] [_ ⊢ N] in [g ⊢ not_nu \a.N']
;

% If a process X makes a closed forward transition F into the process X',
% and a key K does not occur in X (i.e., notin K X holds), then
% then any key different than K does not occur in X' (notin K X').
rec notin_propagates_to_target_fc: (g:ctx) [g ⊢ fstep_cl X T X'] →
  [g ⊢ key T M[]] → [g ⊢ notin K[] X] → [g ⊢ neq M[] K[]] → [g ⊢ notin K[] X'] =
/ total f (notin_propagates_to_target_fc _ _ _ _ _ _ f _ _ _) /
fn f,h,n,i ⇒ case f of
  | [g ⊢ fc_pref _] ⇒ let [g ⊢ key_base] = h in
    let [g ⊢ not_pref N] = n in
    let [g ⊢ I] = symmetric_neq i in [g ⊢ not_kpref I N]
  | [g ⊢ fc_kpref F _ _] ⇒ let [g ⊢ not_kpref I' N] = n in
    let [g ⊢ N'] = notin_propagates_to_target_fc [g ⊢ F] h [g ⊢ N] i in [g ⊢ not_kpref I' N']
  | [g ⊢ fc_suml F1 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ key_suml H1] = h in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in [g ⊢ not_sum N1' N2]
  | [g ⊢ fc_sumr F2 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g ⊢ key_sumr H2] = h in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_sum N1 N2']
  | [g ⊢ fc_parl F1 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_parl H1] = h in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in [g ⊢ not_par N1' N2]
  | [g ⊢ fc_parr F2 _ _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_parr H2] = h in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_par N1 N2']
  | [g ⊢ fc_synl F1 _ H1 F2 _ H2] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_sync H1'] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_synr F1 _ H1 F2 _ H2] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g ⊢ key_sync H1'] = h in
    let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
    let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F1] [g ⊢ H1] [g ⊢ N1] i in
    let [g ⊢ N2'] = notin_propagates_to_target_fc [g ⊢ F2] [g ⊢ H2] [g ⊢ N2] i in [g ⊢ not_par N1' N2']
  | [g ⊢ fc_nu \a.F] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g ⊢ H] = h in
    let [g ⊢ I] = i in
    let [g,a:names ⊢ N'] = notin_propagates_to_target_fc [_ ⊢ F] [_ ⊢ H[..]] [_ ⊢ N] [_ ⊢ I[..]] in [g ⊢ not_nu \a.N']
;

% If a process X makes an open forward transition F into the process X',
% and a key K does not occur in X (i.e., notin K X holds), then
% then any key different than K does not occur in X' (notin K X').
rec notin_propagates_to_target_fo: (g:ctx) [g ⊢ fstep_op X (open \a.T) X'] →
  [g,a:names ⊢ key T M[]] → [g ⊢ notin K[] X] → [g ⊢ neq M[] K[]] → [g ⊢ notin K[] X'] =
/ total f (notin_propagates_to_target_fo _ _ _ _ _ _ f _ _ _) /
fn f,h,n,i ⇒ case f of
  | [g ⊢ fo_nu_cl (\a.O) (\a.L) (\a.F)] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g,a:names ⊢ H] = h in
    let [g ⊢ I] = i in
    let [g,a:names ⊢ N'] = notin_propagates_to_target_fc [_ ⊢ F] [_ ⊢ H[..]] [_ ⊢ N] [_ ⊢ I[..]] in [g ⊢ not_nu \a.N']
  | [g ⊢ fo_kpref F (\_._) _] ⇒ let [g ⊢ not_kpref I' N] = n in
    let [g ⊢ N'] = notin_propagates_to_target_fo [g ⊢ F] h [g ⊢ N] i in [g ⊢ not_kpref I' N']
  | [g ⊢ fo_suml F1 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g,a:names ⊢ key_suml H1] = h in
    let [g ⊢ N1'] = notin_propagates_to_target_fo [g ⊢ F1] [_ ⊢ H1] [g ⊢ N1] i in [g ⊢ not_sum N1' N2]
  | [g ⊢ fo_sumr F2 _] ⇒ let [g ⊢ not_sum N1 N2] = n in
    let [g,a:names ⊢ key_sumr H2] = h in
    let [g ⊢ N2'] = notin_propagates_to_target_fo [g ⊢ F2] [_ ⊢ H2] [g ⊢ N2] i in [g ⊢ not_sum N1 N2']
  | [g ⊢ fo_parl F1 (\_._) _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g,a:names ⊢ key_parl H1] = h in
    let [g ⊢ N1'] = notin_propagates_to_target_fo [g ⊢ F1] [_ ⊢ H1] [g ⊢ N1] i in [g ⊢ not_par N1' N2]
  | [g ⊢ fo_parr F2 (\_._) _] ⇒ let [g ⊢ not_par N1 N2] = n in
    let [g,a:names ⊢ key_parr H2] = h in
    let [g ⊢ N2'] = notin_propagates_to_target_fo [g ⊢ F2] [_ ⊢ H2] [g ⊢ N2] i in [g ⊢ not_par N1 N2']
  | [g ⊢ fo_nu_op \a.F] ⇒ let [g ⊢ not_nu \a.N] = n in
    let [g,a:names ⊢ H] = h in
    let [g ⊢ I] = i in
    let [g,a:names ⊢ N'] = notin_propagates_to_target_fo [_ ⊢ F] [_ ⊢ H[..]] [_ ⊢ N] [_ ⊢ I[..]] in [g ⊢ not_nu \a.N']
;

% If a process X' makes a closed backward transition B into the process X,
% and a key K does not occur in X (i.e., notin K X holds), then
% then any key different than K does not occur in X' (notin K X').
rec notin_propagates_to_source_bc: (g:ctx) [g ⊢ bstep_cl X' T X] →
  [g ⊢ key T M[]] → [g ⊢ notin K[] X] → [g ⊢ neq M[] K[]] → [g ⊢ notin K[] X'] =
/ total b (notin_propagates_to_source_bc _ _ _ _ _ _ b _ _ _) /
fn b,h,n,i ⇒ let [g ⊢ F] = loop_lemma_two_cl b in
notin_propagates_to_target_fc [g ⊢ F] h n i
;

% If a process X' makes an open backward transition B into the process X,
% and a key K does not occur in X (i.e., notin K X holds), then
% then any key different than K does not occur in X' (notin K X').
rec notin_propagates_to_source_bo: (g:ctx) [g ⊢ bstep_op X' (open \a.T) X] →
  [g,a:names ⊢ key T M[]] → [g ⊢ notin K[] X] → [g ⊢ neq M[] K[]] → [g ⊢ notin K[] X'] =
/ total b (notin_propagates_to_source_bo _ _ _ _ _ _ b _ _ _) /
fn b,h,n,i ⇒ let [g ⊢ F] = loop_lemma_two_op b in
notin_propagates_to_target_fo [g ⊢ F] h n i
;

% If a process X' makes a closed backward transition B into the process X,
% and a key K does not occur in X' (i.e., notin K X' holds), then K does
% not occur in X as well (notin K X).
rec notin_propagates_to_target_bc: (g:ctx) [g ⊢ bstep_cl X' T X] →
  [g ⊢ notin K[] X'] → [g ⊢ notin K[] X] =
/ total b (notin_propagates_to_target_bc _ _ _ _ _ b _) /
fn b,n ⇒ let [g ⊢ F] = loop_lemma_two_cl b in
notin_propagates_to_source_fc [g ⊢ F] n
;

% If a process X' makes an open backward transition B into the process X,
% and a key K does not occur in X' (i.e., notin K X' holds), then K does
% not occur in X as well (notin K X).
rec notin_propagates_to_target_bo: (g:ctx) [g ⊢ bstep_op X' (open \a.T) X] →
  [g ⊢ notin K[] X'] → [g ⊢ notin K[] X] =
/ total b (notin_propagates_to_target_bo _ _ _ _ _ b _) /
fn b,n ⇒ let [g ⊢ F] = loop_lemma_two_op b in
notin_propagates_to_source_fo [g ⊢ F] n
;


% If two closed proof labels depending on a name "a" are independent,
% they remain independent even if we replace one of the two "a"s with a fresh name "b".
rec ind_rename: (g:ctx) [g,a:names ⊢ indep_cl T1 T2] → [g,a:names,b:names ⊢ indep_cl T1[..,a] T2[..,b]] =
/ total i (ind_rename _ _ _ i) /
fn i ⇒ case i of
  | [g,a:names ⊢ i_c1l I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_c1l I']
  | [g,a:names ⊢ i_c1r I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_c1r I']
  | [g,a:names ⊢ i_p1l I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_p1l I']
  | [g,a:names ⊢ i_p1r I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_p1r I']
  | [g,a:names ⊢ i_p2l H1 H2 N[..]] ⇒ [g,a:names,b:names ⊢ i_p2l H1[..,a] H2[..,b] N[..]]
  | [g,a:names ⊢ i_p2r H1 H2 N[..]] ⇒ [g,a:names,b:names ⊢ i_p2r H1[..,a] H2[..,b] N[..]]
  | [g,a:names ⊢ i_s1l I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_s1l I']
  | [g,a:names ⊢ i_s1r I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_s1r I']
  | [g,a:names ⊢ i_s2l I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_s2l I']
  | [g,a:names ⊢ i_s2r I] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [_ ⊢ I] in [_ ⊢ i_s2r I']
  | [g,a:names ⊢ i_s3 I1 I2] ⇒ let [g,a:names,b:names ⊢ I1'] = ind_rename [_ ⊢ I1] in
    let [g,a:names,b:names ⊢ I2'] = ind_rename [_ ⊢ I2] in [_ ⊢ i_s3 I1' I2']
;


% Existence of transitions closing a square diagram for the 
% forward-forward, closed-closed case
LF square_ffcc: fstep_cl X T1 X1 → fstep_cl X1 T2 Y → type =
  | s_ffcc: fstep_cl X T2 X2 → fstep_cl X2 T1 Y → square_ffcc (F1:fstep_cl X T1 X1) (F2:fstep_cl X1 T2 Y)
;

% First auxiliary lemma for SP, closed-closed case:
% Given two composable forward closed transitions with independent proof labels,
% there exist two forward closed transitions closing the square diagram.
rec sp_ffcc: (g:ctx) {F1:[g ⊢ fstep_cl X T1 X1]} {F2:[g ⊢ fstep_cl X1 T2 Y]}
  [g ⊢ indep (p_cl T1) (p_cl T2)] → [g ⊢ square_ffcc F1 F2] =
/ total f1 (sp_ffcc _ _ _ _ _ _ f1 _ _) /
mlam F1,F2 ⇒ fn i ⇒ let [g ⊢ i_cc I] = i in
case [g ⊢ F1] of
  | [g ⊢ fc_pref D1] ⇒ impossible [g ⊢ I]
  | [g ⊢ fc_kpref F1' H1 N1] ⇒ let [g ⊢ fc_kpref F2' H2 N2] = [g ⊢ F2] in
    let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I] in
    [g ⊢ s_ffcc (fc_kpref F2'' H2 N2) (fc_kpref F1'' H1 N1)]
  | [g ⊢ fc_suml F1' D1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml F2' _] ⇒ let [g ⊢ i_c1l I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I'] in
         [g ⊢ s_ffcc (fc_suml F2'' D1) (fc_suml F1'' D1)]
       | [g ⊢ fc_sumr F2' D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fc_sumr F1' D1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml F2' D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ fc_sumr F2' _] ⇒ let [g ⊢ i_c1r I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I'] in
         [g ⊢ s_ffcc (fc_sumr F2'' D1) (fc_sumr F1'' D1)])
  | [g ⊢ fc_parl F1' H1 N1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ let [g ⊢ i_p1l I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I'] in
         [g ⊢ s_ffcc (fc_parl F2'' H2 N2) (fc_parl F1'' H1 N1)]
       | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g ⊢ i_p2l H1' H2' N] = [g ⊢ I] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
         let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffcc (fc_parr F2' H2 N2') (fc_parl F1' H1 N1')]
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s1l I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc FL2' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ FL2] [g ⊢ i_cc I'] in
         let [g ⊢ V1] = valid_in_fstep_cl [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FL2] in
         let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I'] [g ⊢ H1] [g ⊢ HL2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffcc (fc_synl FL2' LL2 HL2 FR2 LR2 HR2) (fc_parl F1'' H1 N1')]
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s1l I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc FL2' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ FL2] [g ⊢ i_cc I'] in
         let [g ⊢ V1] = valid_in_fstep_cl [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FL2] in
         let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I'] [g ⊢ H1] [g ⊢ HL2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffcc (fc_synr FL2' LL2 HL2 FR2 LR2 HR2) (fc_parl F1'' H1 N1')])
  | [g ⊢ fc_parr F1' H1 N1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ let [g ⊢ i_p2r H1' H2' N] = [g ⊢ I] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
         let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffcc (fc_parl F2' H2 N2') (fc_parr F1' H1 N1')]
       | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g ⊢ i_p1r I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_cc I'] in
         [g ⊢ s_ffcc (fc_parr F2'' H2 N2) (fc_parr F1'' H1 N1)]
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s1r I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc FR2' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ FR2] [g ⊢ i_cc I'] in
         let [g ⊢ V1] = valid_in_fstep_cl [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FR2] in
         let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I'] [g ⊢ H1] [g ⊢ HR2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffcc (fc_synl FL2 LL2 HL2 FR2' LR2 HR2) (fc_parr F1'' H1 N1')]
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s1r I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc FR2' F1''] = sp_ffcc [g ⊢ F1'] [g ⊢ FR2] [g ⊢ i_cc I'] in
         let [g ⊢ V1] = valid_in_fstep_cl [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FR2] in
         let [g ⊢ N] = indep_impl_diff_keys [g ⊢ V1] [g ⊢ V2] [g ⊢ I'] [g ⊢ H1] [g ⊢ HR2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffcc (fc_synr FL2 LL2 HL2 FR2' LR2 HR2) (fc_parr F1'' H1 N1')])
  | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ let [g ⊢ i_s2l I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' FL1'] = sp_ffcc [g ⊢ FL1] [g ⊢ F2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_ffcc (fc_parl F2'' H2 N2') (fc_synl FL1' LL1 HL1 FR1 LR1 HR1)]
       | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g ⊢ i_s2r I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' FR1'] = sp_ffcc [g ⊢ FR1] [g ⊢ F2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_ffcc (fc_parr F2'' H2 N2') (fc_synl FL1 LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_ffcc FL2' FL1'] = sp_ffcc [g ⊢ FL1] [g ⊢ FL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_ffcc FR2' FR1'] = sp_ffcc [g ⊢ FR1] [g ⊢ FR2] [g ⊢ i_cc IR] in
         [g ⊢ s_ffcc (fc_synl FL2' LL2 HL2 FR2' LR2 HR2) (fc_synl FL1' LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_ffcc FL2' FL1'] = sp_ffcc [g ⊢ FL1] [g ⊢ FL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_ffcc FR2' FR1'] = sp_ffcc [g ⊢ FR1] [g ⊢ FR2] [g ⊢ i_cc IR] in
         [g ⊢ s_ffcc (fc_synr FL2' LL2 HL2 FR2' LR2 HR2) (fc_synl FL1' LL1 HL1 FR1' LR1 HR1)])
  | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ let [g ⊢ i_s2l I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' FL1'] = sp_ffcc [g ⊢ FL1] [g ⊢ F2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_ffcc (fc_parl F2'' H2 N2') (fc_synr FL1' LL1 HL1 FR1 LR1 HR1)]
       | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g ⊢ i_s2r I'] = [g ⊢ I] in
         let [g ⊢ s_ffcc F2'' FR1'] = sp_ffcc [g ⊢ FR1] [g ⊢ F2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_ffcc (fc_parr F2'' H2 N2') (fc_synr FL1 LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_ffcc FL2' FL1'] = sp_ffcc [g ⊢ FL1] [g ⊢ FL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_ffcc FR2' FR1'] = sp_ffcc [g ⊢ FR1] [g ⊢ FR2] [g ⊢ i_cc IR] in
         [g ⊢ s_ffcc (fc_synl FL2' LL2 HL2 FR2' LR2 HR2) (fc_synr FL1' LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_ffcc FL2' FL1'] = sp_ffcc [g ⊢ FL1] [g ⊢ FL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_ffcc FR2' FR1'] = sp_ffcc [g ⊢ FR1] [g ⊢ FR2] [g ⊢ i_cc IR] in
         [g ⊢ s_ffcc (fc_synr FL2' LL2 HL2 FR2' LR2 HR2) (fc_synr FL1' LL1 HL1 FR1' LR1 HR1)])
  | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
    let [g,a:names ⊢ s_ffcc F2'' F1''] = sp_ffcc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_cc I[..]] in
    [g ⊢ s_ffcc (fc_nu \a.F2'') (fc_nu \a.F1'')]
;


% Existence of transitions closing a square diagram for the 
% forward-forward, closed-open case
LF square_ffco: fstep_cl X T1 X1 → fstep_op X1 T2 Y → type =
  | s_ffco: fstep_op X T2 X2 → fstep_cl X2 T1 Y → square_ffco (F1:fstep_cl X T1 X1) (F2:fstep_op X1 T2 Y)
;

% First auxiliary lemma for SP, closed-open case:
% Given two composable forward transitions, respectively closed and open, with independent
% proof labels, there exist two forward transitions closing the square diagram.
rec sp_ffco: (g:ctx) {F1:[g ⊢ fstep_cl X T1 X1]} {F2:[g ⊢ fstep_op X1 T2 Y]}
  [g ⊢ indep (p_cl T1) (p_op T2)] → [g ⊢ square_ffco F1 F2] =
/ total f2 (sp_ffco _ _ _ _ _ _ _ f2 _) /
mlam F1,F2 ⇒ fn i ⇒ let [g ⊢ i_co \a.I] = i in
case [g ⊢ F2] of
  | [g ⊢ fo_nu_cl (\a.O2) (\a.L2) (\a.F2')] ⇒ let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in
    let [g,a:names ⊢ s_ffcc F2'' F1''] = sp_ffcc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_cc I] in
    [g ⊢ s_ffco (fo_nu_cl (\a.O2) (\a.L2) (\a.F2'')) (fc_nu \a.F1'')]
  | [g ⊢ fo_kpref F2' (\a.H2) N2] ⇒ let [g ⊢ fc_kpref F1' H1 N1] = [g ⊢ F1] in
    let [g ⊢ s_ffco F2'' F1''] = sp_ffco [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_co \a.I] in
    [g ⊢ s_ffco (fo_kpref F2'' (\a.H2) N2) (fc_kpref F1'' H1 N1)]
  | [g ⊢ fo_suml F2' D2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_suml F1' _] ⇒ let [g,a:names ⊢ i_c1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' F1''] = sp_ffco [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_ffco (fo_suml F2'' D2) (fc_suml F1'' D2)]
       | [g ⊢ fc_sumr F1' _] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fo_sumr F2' D2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_suml F1' _] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ fc_sumr F1' _] ⇒ let [g,a:names ⊢ i_c1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' F1''] = sp_ffco [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_ffco (fo_sumr F2'' D2) (fc_sumr F1'' D2)])
  | [g ⊢ fo_parl F2' (\a.H2) N2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_parl F1' H1 N1] ⇒ let [g,a:names ⊢ i_p1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' F1''] = sp_ffco [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_ffco (fo_parl F2'' (\a.H2) N2) (fc_parl F1'' H1 N1)]
       | [g ⊢ fc_parr F1' H1 N1] ⇒ let [g,a:names ⊢ i_p2r H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H1[..]] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fo [g ⊢ F2'] [_ ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffco (fo_parl F2' (\a.H2) N2') (fc_parr F1' H1 N1')]
       | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' FL1'] = sp_ffco [g ⊢ FL1] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_ffco (fo_parl F2'' (\a.H2) N2') (fc_synl FL1' LL1 HL1 FR1 LR1 HR1)]
       | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' FL1'] = sp_ffco [g ⊢ FL1] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_ffco (fo_parl F2'' (\a.H2) N2') (fc_synr FL1' LL1 HL1 FR1 LR1 HR1)])
  | [g ⊢ fo_parr F2' (\a.H2) N2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_parl F1' H1 N1] ⇒ let [g,a:names ⊢ i_p2l H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H1[..]] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fo [g ⊢ F2'] [_ ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffco (fo_parr F2' (\a.H2) N2') (fc_parl F1' H1 N1')]
       | [g ⊢ fc_parr F1' H1 N1] ⇒ let [g,a:names ⊢ i_p1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' F1''] = sp_ffco [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_ffco (fo_parr F2'' (\a.H2) N2) (fc_parr F1'' H1 N1)]
       | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' FR1'] = sp_ffco [g ⊢ FR1] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_ffco (fo_parr F2'' (\a.H2) N2') (fc_synl FL1 LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffco F2'' FR1'] = sp_ffco [g ⊢ FR1] [g ⊢ F2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_ffco (fo_parr F2'' (\a.H2) N2') (fc_synr FL1 LL1 HL1 FR1' LR1 HR1)])
  | [g ⊢ fo_nu_op \a.F2'] ⇒ let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in
    let [g,a:names ⊢ s_ffco F2'' F1''] = sp_ffco [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_co \a.I[..]] in
    [g ⊢ s_ffco (fo_nu_op \a.F2'') (fc_nu \a.F1'')]
;


% Existence of transitions closing a square diagram for the 
% forward-forward, open-closed case
LF square_ffoc: fstep_op X T1 X1 → fstep_cl X1 T2 Y → type =
  | s_ffoc: fstep_cl X T2 X2 → fstep_op X2 T1 Y → square_ffoc (F1:fstep_op X T1 X1) (F2:fstep_cl X1 T2 Y)
;

% First auxiliary lemma for SP, open-closed case:
% Given two composable forward transitions, respectively open and closed, with independent
% proof labels, there exist two forward transitions closing the square diagram.
rec sp_ffoc: (g:ctx) {F1:[g ⊢ fstep_op X T1 X1]} {F2:[g ⊢ fstep_cl X1 T2 Y]}
  [g ⊢ indep (p_op T1) (p_cl T2)] → [g ⊢ square_ffoc F1 F2] =
/ total f1 (sp_ffoc _ _ _ _ _ _ f1 _ _) /
mlam F1,F2 ⇒ fn i ⇒ let [g ⊢ i_oc \a.I] = i in
case [g ⊢ F1] of
  | [g ⊢ fo_nu_cl (\a.O1) (\a.L1) (\a.F1')] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
    let [g,a:names ⊢ s_ffcc F2'' F1''] = sp_ffcc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_cc I] in
    [g ⊢ s_ffoc (fc_nu \a.F2'') (fo_nu_cl (\a.O1) (\a.L1) (\a.F1''))]
  | [g ⊢ fo_kpref F1' (\a.H1) N1] ⇒ let [g ⊢ fc_kpref F2' H2 N2] = [g ⊢ F2] in
    let [g ⊢ s_ffoc F2'' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oc \a.I] in
    [g ⊢ s_ffoc (fc_kpref F2'' H2 N2) (fo_kpref F1'' (\a.H1) N1)]
  | [g ⊢ fo_suml F1' _] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml F2' D2] ⇒ let [g,a:names ⊢ i_c1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc F2'' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_ffoc (fc_suml F2'' D2) (fo_suml F1'' D2)]
       | [g ⊢ fc_sumr F2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fo_sumr F1' _] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_suml F2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ fc_sumr F2' D2] ⇒ let [g,a:names ⊢ i_c1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc F2'' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_ffoc (fc_sumr F2'' D2) (fo_sumr F1'' D2)])
  | [g ⊢ fo_parl F1' (\a.H1) N1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ let [g,a:names ⊢ i_p1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc F2'' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_ffoc (fc_parl F2'' H2 N2) (fo_parl F1'' (\a.H1) N1)]
       | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g,a:names ⊢ i_p2l H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H2[..]] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoc (fc_parr F2' H2 N2') (fo_parl F1' (\a.H1) N1')]
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc FL2' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ FL2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ vo_base (\_._) (\_._) (\a.V1)] = valid_in_fstep_op [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FL2] in
         let [g,a:names ⊢ N[..]] = indep_impl_diff_keys [g,a:names ⊢ V1] [_ ⊢ V2[..]] [_ ⊢ I'[..]] [_ ⊢ H1] [_ ⊢ HL2[..]] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoc (fc_synl FL2' LL2 HL2 FR2 LR2 HR2) (fo_parl F1'' (\a.H1) N1')]
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc FL2' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ FL2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ vo_base (\_._) (\_._) (\a.V1)] = valid_in_fstep_op [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FL2] in
         let [g,a:names ⊢ N[..]] = indep_impl_diff_keys [g,a:names ⊢ V1] [_ ⊢ V2[..]] [_ ⊢ I'[..]] [_ ⊢ H1] [_ ⊢ HL2[..]] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FR2] [g ⊢ HR2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoc (fc_synr FL2' LL2 HL2 FR2 LR2 HR2) (fo_parl F1'' (\a.H1) N1')])
  | [g ⊢ fo_parr F1' (\a.H1) N1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fc_parl F2' H2 N2] ⇒ let [g,a:names ⊢ i_p2r H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H2[..]] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ F2'] [g ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoc (fc_parl F2' H2 N2') (fo_parr F1' (\a.H1) N1')]
       | [g ⊢ fc_parr F2' H2 N2] ⇒ let [g,a:names ⊢ i_p1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc F2'' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_ffoc (fc_parr F2'' H2 N2) (fo_parr F1'' (\a.H1) N1)]
       | [g ⊢ fc_synl FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc FR2' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ FR2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ vo_base (\_._) (\_._) (\a.V1)] = valid_in_fstep_op [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FR2] in
         let [g,a:names ⊢ N[..]] = indep_impl_diff_keys [g,a:names ⊢ V1] [_ ⊢ V2[..]] [_ ⊢ I'[..]] [_ ⊢ H1] [_ ⊢ HR2[..]] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoc (fc_synl FL2 LL2 HL2 FR2' LR2 HR2) (fo_parr F1'' (\a.H1) N1')]
       | [g ⊢ fc_synr FL2 LL2 HL2 FR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoc FR2' F1''] = sp_ffoc [g ⊢ F1'] [g ⊢ FR2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ vo_base (\_._) (\_._) (\a.V1)] = valid_in_fstep_op [g ⊢ F1'] in
         let [g ⊢ V2] = valid_in_fstep_cl [g ⊢ FR2] in
         let [g,a:names ⊢ N[..]] = indep_impl_diff_keys [g,a:names ⊢ V1] [_ ⊢ V2[..]] [_ ⊢ I'[..]] [_ ⊢ H1] [_ ⊢ HR2[..]] in
         let [g ⊢ N1'] = notin_propagates_to_target_fc [g ⊢ FL2] [g ⊢ HL2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoc (fc_synr FL2 LL2 HL2 FR2' LR2 HR2) (fo_parr F1'' (\a.H1) N1')])
  | [g ⊢ fo_nu_op \a.F1'] ⇒ let [g ⊢ fc_nu \a.F2'] = [g ⊢ F2] in
    let [g,a:names ⊢ s_ffoc F2'' F1''] = sp_ffoc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_oc \a.I[..]] in
    [g ⊢ s_ffoc (fc_nu \a.F2'') (fo_nu_op \a.F1'')]
;


% Existence of transitions closing a square diagram for the 
% forward-forward, open-open case
LF square_ffoo: fstep_op X T1 X1 → fstep_op X1 T2 Y → type =
  | s_ffoo: fstep_op X T2 X2 → fstep_op X2 T1 Y → square_ffoo (F1:fstep_op X T1 X1) (F2:fstep_op X1 T2 Y)
;


% First auxiliary lemma for SP, open-open case:
% Given two composable open forward transitions with independent proof labels,
% there exist two forward open transitions closing the square diagram.
rec sp_ffoo: (g:ctx) {F1:[g ⊢ fstep_op X T1 X1]} {F2:[g ⊢ fstep_op X1 T2 Y]}
  [g ⊢ indep (p_op T1) (p_op T2)] → [g ⊢ square_ffoo F1 F2] =
/ total f1 (sp_ffoo _ _ _ _ _ _ f1 _ _) /
mlam F1,F2 ⇒ fn i ⇒ let [g ⊢ i_oo \a.I[..,a]] = i in
case [g ⊢ F1] of
  | [g ⊢ fo_nu_cl (\a.O1) (\a.L1) (\a.F1')] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fo_nu_cl (\a.O2) (\a.L2) (\a.F2')] ⇒
         let [g,a:names ⊢ s_ffcc F2'' F1''] = sp_ffcc [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_cc I] in
         [g ⊢ s_ffoo (fo_nu_cl (\a.O2) (\a.L2) (\a.F2'')) (fo_nu_cl (\a.O1) (\a.L1) (\a.F1''))]
       | [g ⊢ fo_nu_op \a.F2'] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [g,a:names ⊢ I] in 
         let [g,a:names ⊢ s_ffco F2'' F1''] = sp_ffco [_ ⊢ F1'] [_ ⊢ F2'] [g,a:names ⊢ i_co \b.I'[..,a,b]] in
         [g ⊢ s_ffoo (fo_nu_op \a.F2'') (fo_nu_cl (\a.O1) (\a.L1) (\a.F1''))])
  | [g ⊢ fo_kpref F1' (\a.H1) N1] ⇒ let [g ⊢ fo_kpref F2' (\a.H2) N2] = [g ⊢ F2] in
    let [g ⊢ s_ffoo F2'' F1''] = sp_ffoo [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oo \a.I] in
    [g ⊢ s_ffoo (fo_kpref F2'' (\a.H2) N2) (fo_kpref F1'' (\a.H1) N1)]
  | [g ⊢ fo_suml F1' _] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fo_suml F2' D2] ⇒ let [g,a:names ⊢ i_c1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoo F2'' F1''] = sp_ffoo [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_ffoo (fo_suml F2'' D2) (fo_suml F1'' D2)]
       | [g ⊢ fo_sumr F2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fo_sumr F1' _] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fo_suml F2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ fo_sumr F2' D2] ⇒ let [g,a:names ⊢ i_c1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoo F2'' F1''] = sp_ffoo [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_ffoo (fo_sumr F2'' D2) (fo_sumr F1'' D2)])
  | [g ⊢ fo_parl F1' (\a.H1) N1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fo_parl F2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p1l I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoo F2'' F1''] = sp_ffoo [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_ffoo (fo_parl F2'' (\a.H2) N2) (fo_parl F1'' (\a.H1) N1)]
       | [g ⊢ fo_parr F2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p2l H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fo [g ⊢ F2'] [_ ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoo (fo_parr F2' (\a.H2) N2') (fo_parl F1' (\a.H1) N1')])
  | [g ⊢ fo_parr F1' (\a.H1) N1] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fo_parl F2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p2r H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_fo [g ⊢ F2'] [_ ⊢ H2] [g ⊢ N1] (symmetric_neq [g ⊢ N]) in
         [g ⊢ s_ffoo (fo_parl F2' (\a.H2) N2') (fo_parr F1' (\a.H1) N1')]
       | [g ⊢ fo_parr F2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p1r I'] = [_ ⊢ I] in
         let [g ⊢ s_ffoo F2'' F1''] = sp_ffoo [g ⊢ F1'] [g ⊢ F2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_ffoo (fo_parr F2'' (\a.H2) N2) (fo_parr F1'' (\a.H1) N1)])
  | [g ⊢ fo_nu_op \a.F1'] ⇒ (case [g ⊢ F2] of
       | [g ⊢ fo_nu_cl (\a.O2) (\a.L2) (\a.F2')] ⇒ let [g,a:names,b:names ⊢ I'[..,b,a]] = ind_rename [g,a:names ⊢ I] in 
         let [g,a:names ⊢ s_ffoc F2'' F1''] = sp_ffoc [_ ⊢ F1'] [_ ⊢ F2'] [g,a:names ⊢ i_oc \b.I'[..,a,b]] in
         [g ⊢ s_ffoo (fo_nu_cl (\a.O2) (\a.L2) (\a.F2'')) (fo_nu_op \a.F1'')]
       | [g ⊢ fo_nu_op \a.F2'] ⇒ 
         let [g,a:names ⊢ s_ffoo F2'' F1''] = sp_ffoo [_ ⊢ F1'] [_ ⊢ F2'] [_ ⊢ i_oo \a.I[..]] in
         [g ⊢ s_ffoo (fo_nu_op \a.F2'') (fo_nu_op \a.F1'')])
;




% Existence of transitions closing a square diagram for the 
% forward-backward, closed-closed case
LF square_fbcc: fstep_cl X T1 X1 → bstep_cl X1 T2 Y → type =
  | s_fbcc: bstep_cl X T2 X2 → fstep_cl X2 T1 Y → square_fbcc (F1:fstep_cl X T1 X1) (B2:bstep_cl X1 T2 Y)
;

% Second auxiliary lemma for SP, closed-closed case:
% Given two composable transitions, where the former is forward closed and the latter is
% backward closed, and with independent proof labels, there exist a forward and
% a backward transition closing the square diagram.
rec sp_fbcc: (g:ctx) {F1:[g ⊢ fstep_cl X T1 X1]} {B2:[g ⊢ bstep_cl X1 T2 Y]}
  [g ⊢ indep (p_cl T1) (p_cl T2)] → [g ⊢ square_fbcc F1 B2] =
/ total f1 (sp_fbcc _ _ _ _ _ _ f1 _ _) /
mlam F1,B2 ⇒ fn i ⇒ let [g ⊢ i_cc I] = i in
case [g ⊢ F1] of
  | [g ⊢ fc_pref D1] ⇒ impossible [g ⊢ I]
  | [g ⊢ fc_kpref F1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_pref D2] ⇒ impossible [g ⊢ I]
       | [g ⊢ bc_kpref B2' H2 N2] ⇒ let [g ⊢ s_fbcc B2'' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_cc I] in
         [g ⊢ s_fbcc (bc_kpref B2'' H2 N2) (fc_kpref F1'' H1 N1)])
  | [g ⊢ fc_suml F1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' _] ⇒ let [g ⊢ i_c1l I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_cc I'] in
         [g ⊢ s_fbcc (bc_suml B2'' D1) (fc_suml F1'' D1)]
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fc_sumr F1' D1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ bc_sumr B2' _] ⇒ let [g ⊢ i_c1r I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_cc I'] in
         [g ⊢ s_fbcc (bc_sumr B2'' D1) (fc_sumr F1'' D1)])
  | [g ⊢ fc_parl F1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ i_p1l I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_cc I'] in
         [g ⊢ s_fbcc (bc_parl B2'' H2 N2) (fc_parl F1'' H1 N1)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ i_p2l H1' H2' N] = [g ⊢ I] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
         let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fbcc (bc_parr B2' H2 N2') (fc_parl F1' H1 N1')]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s1l I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc BL2' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ BL2] [g ⊢ i_cc I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BR2] [g ⊢ N1] in
         [g ⊢ s_fbcc (bc_synl BL2' LL2 HL2 BR2 LR2 HR2) (fc_parl F1'' H1 N1')]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s1l I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc BL2' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ BL2] [g ⊢ i_cc I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BR2] [g ⊢ N1] in
         [g ⊢ s_fbcc (bc_synr BL2' LL2 HL2 BR2 LR2 HR2) (fc_parl F1'' H1 N1')])
  | [g ⊢ fc_parr F1' H1 N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ i_p2r H1' H2' N] = [g ⊢ I] in
         let [g ⊢ refk] = functional_key [g ⊢ H1] [g ⊢ H1'] in
         let [g ⊢ refk] = functional_key [g ⊢ H2] [g ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fbcc (bc_parl B2' H2 N2') (fc_parr F1' H1 N1')]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ i_p1r I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_cc I'] in
         [g ⊢ s_fbcc (bc_parr B2'' H2 N2) (fc_parr F1'' H1 N1)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s1r I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc BR2' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ BR2] [g ⊢ i_cc I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BL2] [g ⊢ N1] in
         [g ⊢ s_fbcc (bc_synl BL2 LL2 HL2 BR2' LR2 HR2) (fc_parr F1'' H1 N1')]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s1r I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc BR2' F1''] = sp_fbcc [g ⊢ F1'] [g ⊢ BR2] [g ⊢ i_cc I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BL2] [g ⊢ N1] in
         [g ⊢ s_fbcc (bc_synr BL2 LL2 HL2 BR2' LR2 HR2) (fc_parr F1'' H1 N1')])
  | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ i_s2l I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' FL1'] = sp_fbcc [g ⊢ FL1] [g ⊢ B2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_fbcc (bc_parl B2'' H2 N2') (fc_synl FL1' LL1 HL1 FR1 LR1 HR1)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ i_s2r I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' FR1'] = sp_fbcc [g ⊢ FR1] [g ⊢ B2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_fbcc (bc_parr B2'' H2 N2') (fc_synl FL1 LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_fbcc BL2' FL1'] = sp_fbcc [g ⊢ FL1] [g ⊢ BL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_fbcc BR2' FR1'] = sp_fbcc [g ⊢ FR1] [g ⊢ BR2] [g ⊢ i_cc IR] in
         [g ⊢ s_fbcc (bc_synl BL2' LL2 HL2 BR2' LR2 HR2) (fc_synl FL1' LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_fbcc BL2' FL1'] = sp_fbcc [g ⊢ FL1] [g ⊢ BL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_fbcc BR2' FR1'] = sp_fbcc [g ⊢ FR1] [g ⊢ BR2] [g ⊢ i_cc IR] in
         [g ⊢ s_fbcc (bc_synr BL2' LL2 HL2 BR2' LR2 HR2) (fc_synl FL1' LL1 HL1 FR1' LR1 HR1)])
  | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g ⊢ i_s2l I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' FL1'] = sp_fbcc [g ⊢ FL1] [g ⊢ B2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_fbcc (bc_parl B2'' H2 N2') (fc_synr FL1' LL1 HL1 FR1 LR1 HR1)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g ⊢ i_s2r I'] = [g ⊢ I] in
         let [g ⊢ s_fbcc B2'' FR1'] = sp_fbcc [g ⊢ FR1] [g ⊢ B2'] [g ⊢ i_cc I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_fbcc (bc_parr B2'' H2 N2') (fc_synr FL1 LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_fbcc BL2' FL1'] = sp_fbcc [g ⊢ FL1] [g ⊢ BL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_fbcc BR2' FR1'] = sp_fbcc [g ⊢ FR1] [g ⊢ BR2] [g ⊢ i_cc IR] in
         [g ⊢ s_fbcc (bc_synl BL2' LL2 HL2 BR2' LR2 HR2) (fc_synr FL1' LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g ⊢ i_s3 IL IR] = [g ⊢ I] in
         let [g ⊢ s_fbcc BL2' FL1'] = sp_fbcc [g ⊢ FL1] [g ⊢ BL2] [g ⊢ i_cc IL] in
         let [g ⊢ s_fbcc BR2' FR1'] = sp_fbcc [g ⊢ FR1] [g ⊢ BR2] [g ⊢ i_cc IR] in
         [g ⊢ s_fbcc (bc_synr BL2' LL2 HL2 BR2' LR2 HR2) (fc_synr FL1' LL1 HL1 FR1' LR1 HR1)])
  | [g ⊢ fc_nu \a.F1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in
    let [g,a:names ⊢ s_fbcc B2'' F1''] = sp_fbcc [_ ⊢ F1'] [_ ⊢ B2'] [_ ⊢ i_cc I[..]] in
    [g ⊢ s_fbcc (bc_nu \a.B2'') (fc_nu \a.F1'')]
;


% Existence of transitions closing a square diagram for the 
% forward-backward, closed-open case
LF square_fbco: fstep_cl X T1 X1 → bstep_op X1 T2 Y → type =
  | s_fbco: bstep_op X T2 X2 → fstep_cl X2 T1 Y → square_fbco (F1:fstep_cl X T1 X1) (B2:bstep_op X1 T2 Y)
;

% Second auxiliary lemma for SP, closed-open case:
% Given two composable transitions, where the former is forward closed and the latter is
% backward open, and with independent proof labels, there exist a forward and
% a backward transition closing the square diagram.
rec sp_fbco: (g:ctx) {F1:[g ⊢ fstep_cl X T1 X1]} {B2:[g ⊢ bstep_op X1 T2 Y]}
  [g ⊢ indep (p_cl T1) (p_op T2)] → [g ⊢ square_fbco F1 B2] =
/ total b2 (sp_fbco _ _ _ _ _ _ _ b2 _) /
mlam F1,B2 ⇒ fn i ⇒ let [g ⊢ i_co \a.I] = i in
case [g ⊢ B2] of
  | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in
    let [g,a:names ⊢ s_fbcc B2'' F1''] = sp_fbcc [_ ⊢ F1'] [_ ⊢ B2'] [_ ⊢ i_cc I] in
    [g ⊢ s_fbco (bo_nu_cl (\a.O2) (\a.L2) (\a.B2'')) (fc_nu \a.F1'')]
  | [g ⊢ bo_kpref B2' (\a.H2) N2] ⇒ let [g ⊢ fc_kpref F1' H1 N1] = [g ⊢ F1] in
    let [g ⊢ s_fbco B2'' F1''] = sp_fbco [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_co \a.I] in
    [g ⊢ s_fbco (bo_kpref B2'' (\a.H2) N2) (fc_kpref F1'' H1 N1)]
  | [g ⊢ bo_suml B2' D2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_suml F1' _] ⇒ let [g,a:names ⊢ i_c1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' F1''] = sp_fbco [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_fbco (bo_suml B2'' D2) (fc_suml F1'' D2)]
       | [g ⊢ fc_sumr F1' _] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ bo_sumr B2' D2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_suml F1' _] ⇒ impossible target_is_not_std_fc [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ fc_sumr F1' _] ⇒ let [g,a:names ⊢ i_c1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' F1''] = sp_fbco [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_fbco (bo_sumr B2'' D2) (fc_sumr F1'' D2)])
  | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_parl F1' H1 N1] ⇒ let [g,a:names ⊢ i_p1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' F1''] = sp_fbco [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_fbco (bo_parl B2'' (\a.H2) N2) (fc_parl F1'' H1 N1)]
       | [g ⊢ fc_parr F1' H1 N1] ⇒ let [g,a:names ⊢ i_p2r H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H1[..]] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bo [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fbco (bo_parl B2' (\a.H2) N2') (fc_parr F1' H1 N1')]
       | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2l I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' FL1'] = sp_fbco [g ⊢ FL1] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_fbco (bo_parl B2'' (\a.H2) N2') (fc_synl FL1' LL1 HL1 FR1 LR1 HR1)]
       | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2l I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' FL1'] = sp_fbco [g ⊢ FL1] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FR1] [g ⊢ N2] in
         [g ⊢ s_fbco (bo_parl B2'' (\a.H2) N2') (fc_synr FL1' LL1 HL1 FR1 LR1 HR1)])
  | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ (case [g ⊢ F1] of
       | [g ⊢ fc_parl F1' H1 N1] ⇒ let [g,a:names ⊢ i_p2l H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H1[..]] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bo [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fbco (bo_parr B2' (\a.H2) N2') (fc_parl F1' H1 N1')]
       | [g ⊢ fc_parr F1' H1 N1] ⇒ let [g,a:names ⊢ i_p1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' F1''] = sp_fbco [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         [g ⊢ s_fbco (bo_parr B2'' (\a.H2) N2) (fc_parr F1'' H1 N1)]
       | [g ⊢ fc_synl FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2r I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' FR1'] = sp_fbco [g ⊢ FR1] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_fbco (bo_parr B2'' (\a.H2) N2') (fc_synl FL1 LL1 HL1 FR1' LR1 HR1)]
       | [g ⊢ fc_synr FL1 LL1 HL1 FR1 LR1 HR1] ⇒ let [g,a:names ⊢ i_s2r I'] = [_ ⊢ I] in
         let [g ⊢ s_fbco B2'' FR1'] = sp_fbco [g ⊢ FR1] [g ⊢ B2'] [g ⊢ i_co \a.I'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fc [g ⊢ FL1] [g ⊢ N2] in
         [g ⊢ s_fbco (bo_parr B2'' (\a.H2) N2') (fc_synr FL1 LL1 HL1 FR1' LR1 HR1)])
  | [g ⊢ bo_nu_op \a.B2'] ⇒ let [g ⊢ fc_nu \a.F1'] = [g ⊢ F1] in
    let [g,a:names ⊢ s_fbco B2'' F1''] = sp_fbco [_ ⊢ F1'] [_ ⊢ B2'] [_ ⊢ i_co \a.I[..]] in
    [g ⊢ s_fbco (bo_nu_op \a.B2'') (fc_nu \a.F1'')]
;


% Existence of transitions closing a square diagram for the 
% forward-backward, open-closed case
LF square_fboc: fstep_op X T1 X1 → bstep_cl X1 T2 Y → type =
  | s_fboc: bstep_cl X T2 X2 → fstep_op X2 T1 Y → square_fboc (F1:fstep_op X T1 X1) (B2:bstep_cl X1 T2 Y)
;

% Second auxiliary lemma for SP, open-closed case:
% Given two composable transitions, where the former is forward open and the latter is
% backward closed, and with independent proof labels, there exist a forward and
% a backward transition closing the square diagram.
rec sp_fboc: (g:ctx) {F1:[g ⊢ fstep_op X T1 X1]} {B2:[g ⊢ bstep_cl X1 T2 Y]}
  [g ⊢ indep (p_op T1) (p_cl T2)] → [g ⊢ square_fboc F1 B2] =
/ total f1 (sp_fboc _ _ _ _ _ _ f1 _ _) /
mlam F1,B2 ⇒ fn i ⇒ let [g ⊢ i_oc \a.I] = i in
case [g ⊢ F1] of
  | [g ⊢ fo_nu_cl (\a.O1) (\a.L1) (\a.F1')] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in
    let [g,a:names ⊢ s_fbcc B2'' F1''] = sp_fbcc [_ ⊢ F1'] [_ ⊢ B2'] [_ ⊢ i_cc I] in
    [g ⊢ s_fboc (bc_nu \a.B2'') (fo_nu_cl (\a.O1) (\a.L1) (\a.F1''))]
  | [g ⊢ fo_kpref F1' (\a.H1) N1] ⇒ let [g ⊢ bc_kpref B2' H2 N2] = [g ⊢ B2] in
    let [g ⊢ s_fboc B2'' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oc \a.I] in
    [g ⊢ s_fboc (bc_kpref B2'' H2 N2) (fo_kpref F1'' (\a.H1) N1)]
  | [g ⊢ fo_suml F1' _] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ let [g,a:names ⊢ i_c1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc B2'' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_fboc (bc_suml B2'' D2) (fo_suml F1'' D2)]
       | [g ⊢ bc_sumr B2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fo_sumr F1' _] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_suml B2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ bc_sumr B2' D2] ⇒ let [g,a:names ⊢ i_c1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc B2'' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_fboc (bc_sumr B2'' D2) (fo_sumr F1'' D2)])
  | [g ⊢ fo_parl F1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g,a:names ⊢ i_p1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc B2'' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_fboc (bc_parl B2'' H2 N2) (fo_parl F1'' (\a.H1) N1)]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g,a:names ⊢ i_p2l H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H2[..]] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fboc (bc_parr B2' H2 N2') (fo_parl F1' (\a.H1) N1')]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc BL2' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ BL2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BR2][g ⊢ N1] in
         [g ⊢ s_fboc (bc_synl BL2' LL2 HL2 BR2 LR2 HR2) (fo_parl F1'' (\a.H1) N1')]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc BL2' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ BL2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BR2] [g ⊢ N1] in
         [g ⊢ s_fboc (bc_synr BL2' LL2 HL2 BR2 LR2 HR2) (fo_parl F1'' (\a.H1) N1')])
  | [g ⊢ fo_parr F1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bc_parl B2' H2 N2] ⇒ let [g,a:names ⊢ i_p2r H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [g,a:names ⊢ H2[..]] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fboc (bc_parl B2' H2 N2') (fo_parr F1' (\a.H1) N1')]
       | [g ⊢ bc_parr B2' H2 N2] ⇒ let [g,a:names ⊢ i_p1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc B2'' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oc \a.I'] in
         [g ⊢ s_fboc (bc_parr B2'' H2 N2) (fo_parr F1'' (\a.H1) N1)]
       | [g ⊢ bc_synl BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc BR2' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ BR2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BL2] [g ⊢ N1] in
         [g ⊢ s_fboc (bc_synl BL2 LL2 HL2 BR2' LR2 HR2) (fo_parr F1'' (\a.H1) N1')]
       | [g ⊢ bc_synr BL2 LL2 HL2 BR2 LR2 HR2] ⇒ let [g,a:names ⊢ i_s1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fboc BR2' F1''] = sp_fboc [g ⊢ F1'] [g ⊢ BR2] [g ⊢ i_oc \a.I'] in
         let [g ⊢ N1'] = notin_propagates_to_target_bc [g ⊢ BL2] [g ⊢ N1] in
         [g ⊢ s_fboc (bc_synr BL2 LL2 HL2 BR2' LR2 HR2) (fo_parr F1'' (\a.H1) N1')])
  | [g ⊢ fo_nu_op \a.F1'] ⇒ let [g ⊢ bc_nu \a.B2'] = [g ⊢ B2] in
    let [g,a:names ⊢ s_fboc B2'' F1''] = sp_fboc [_ ⊢ F1'] [_ ⊢ B2'] [_ ⊢ i_oc \a.I[..]] in
    [g ⊢ s_fboc (bc_nu \a.B2'') (fo_nu_op \a.F1'')]
;


% Existence of transitions closing a square diagram for the 
% forward-backward, open-open case
LF square_fboo: fstep_op X T1 X1 → bstep_op X1 T2 Y → type =
  | s_fboo: bstep_op X T2 X2 → fstep_op X2 T1 Y → square_fboo (F1:fstep_op X T1 X1) (B2:bstep_op X1 T2 Y)
;


% Second auxiliary lemma for SP, open-open case:
% Given two composable transitions, where the former is forward open and the latter is
% backward open, and with independent proof labels, there exist a forward and
% a backward transition closing the square diagram.
rec sp_fboo: (g:ctx) {F1:[g ⊢ fstep_op X T1 X1]} {B2:[g ⊢ bstep_op X1 T2 Y]}
  [g ⊢ indep (p_op T1) (p_op T2)] → [g ⊢ square_fboo F1 B2] =
/ total f1 (sp_fboo _ _ _ _ _ _ f1 _ _) /
mlam F1,B2 ⇒ fn i ⇒ let [g ⊢ i_oo \a.I[..,a]] = i in
case [g ⊢ F1] of
  | [g ⊢ fo_nu_cl (\a.O1) (\a.L1) (\a.F1')] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒
         let [g,a:names ⊢ s_fbcc B2'' F1''] = sp_fbcc [_ ⊢ F1'] [_ ⊢ B2'] [_ ⊢ i_cc I] in
         [g ⊢ s_fboo (bo_nu_cl (\a.O2) (\a.L2) (\a.B2'')) (fo_nu_cl (\a.O1) (\a.L1) (\a.F1''))]
       | [g ⊢ bo_nu_op \a.B2'] ⇒ let [g,a:names,b:names ⊢ I'] = ind_rename [g,a:names ⊢ I] in 
         let [g,a:names ⊢ s_fbco B2'' F1''] = sp_fbco [_ ⊢ F1'] [_ ⊢ B2'] [g,a:names ⊢ i_co \b.I'[..,a,b]] in
         [g ⊢ s_fboo (bo_nu_op \a.B2'') (fo_nu_cl (\a.O1) (\a.L1) (\a.F1''))])
  | [g ⊢ fo_kpref F1' (\a.H1) N1] ⇒ let [g ⊢ bo_kpref B2' (\a.H2) N2] = [g ⊢ B2] in
    let [g ⊢ s_fboo B2'' F1''] = sp_fboo [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oo \a.I] in
    [g ⊢ s_fboo (bo_kpref B2'' (\a.H2) N2) (fo_kpref F1'' (\a.H1) N1)]
  | [g ⊢ fo_suml F1' _] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_suml B2' D2] ⇒ let [g,a:names ⊢ i_c1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fboo B2'' F1''] = sp_fboo [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_fboo (bo_suml B2'' D2) (fo_suml F1'' D2)]
       | [g ⊢ bo_sumr B2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2])
  | [g ⊢ fo_sumr F1' _] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_suml B2' D2] ⇒ impossible target_is_not_std_fo [g ⊢ F1'] [g ⊢ D2]
       | [g ⊢ bo_sumr B2' D2] ⇒ let [g,a:names ⊢ i_c1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fboo B2'' F1''] = sp_fboo [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_fboo (bo_sumr B2'' D2) (fo_sumr F1'' D2)])
  | [g ⊢ fo_parl F1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p1l I'] = [_ ⊢ I] in
         let [g ⊢ s_fboo B2'' F1''] = sp_fboo [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_fboo (bo_parl B2'' (\a.H2) N2) (fo_parl F1'' (\a.H1) N1)]
       | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p2l H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bo [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fboo (bo_parr B2' (\a.H2) N2') (fo_parl F1' (\a.H1) N1')])
  | [g ⊢ fo_parr F1' (\a.H1) N1] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_parl B2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p2r H1' H2' N[..]] = [_ ⊢ I] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H1] [_ ⊢ H1'] in
         let [g,a:names ⊢ refk] = functional_key [_ ⊢ H2] [_ ⊢ H2'] in
         let [g ⊢ N2'] = notin_propagates_to_source_fo [g ⊢ F1'] [g ⊢ N2] in
         let [g ⊢ N1'] = notin_propagates_to_target_bo [g ⊢ B2'] [g ⊢ N1] in
         [g ⊢ s_fboo (bo_parl B2' (\a.H2) N2') (fo_parr F1' (\a.H1) N1')]
       | [g ⊢ bo_parr B2' (\a.H2) N2] ⇒ let [g,a:names ⊢ i_p1r I'] = [_ ⊢ I] in
         let [g ⊢ s_fboo B2'' F1''] = sp_fboo [g ⊢ F1'] [g ⊢ B2'] [g ⊢ i_oo \a.I'] in
         [g ⊢ s_fboo (bo_parr B2'' (\a.H2) N2) (fo_parr F1'' (\a.H1) N1)])
  | [g ⊢ fo_nu_op \a.F1'] ⇒ (case [g ⊢ B2] of
       | [g ⊢ bo_nu_cl (\a.O2) (\a.L2) (\a.B2')] ⇒ let [g,a:names,b:names ⊢ I'[..,b,a]] = ind_rename [g,a:names ⊢ I] in 
         let [g,a:names ⊢ s_fboc B2'' F1''] = sp_fboc [_ ⊢ F1'] [_ ⊢ B2'] [g,a:names ⊢ i_oc \b.I'[..,a,b]] in
         [g ⊢ s_fboo (bo_nu_cl (\a.O2) (\a.L2) (\a.B2'')) (fo_nu_op \a.F1'')]
       | [g ⊢ bo_nu_op \a.B2'] ⇒ 
         let [g,a:names ⊢ s_fboo B2'' F1''] = sp_fboo [_ ⊢ F1'] [_ ⊢ B2'] [_ ⊢ i_oo \a.I[..]] in
         [g ⊢ s_fboo (bo_nu_op \a.B2'') (fo_nu_op \a.F1'')])
;



% Existence of transitions closing a square diagram for the 
% backward-forward, closed-closed case
LF square_bfcc: bstep_cl X T1 X1 → fstep_cl X1 T2 Y → type =
  | s_bfcc: fstep_cl X T2 X2 → bstep_cl X2 T1 Y → square_bfcc (B1:bstep_cl X T1 X1) (F2:fstep_cl X1 T2 Y)
;

% Third auxiliary lemma for SP, closed-closed case:
% Given two composable transitions, where the former is backward closed and the latter is
% forward closed, and with independent proof labels, there exist a forward
% and a backward transition closing the square diagram.
rec sp_bfcc: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {F2:[g ⊢ fstep_cl X1 T2 Y]}
  [g ⊢ indep (p_cl T1) (p_cl T2)] → [g ⊢ square_bfcc B1 F2] =
/ total b1 (sp_bfcc _ _ _ _ _ _ b1 _ _) /
?
;

% Existence of transitions closing a square diagram for the 
% backward-forward, closed-open case
LF square_bfco: bstep_cl X T1 X1 → fstep_op X1 T2 Y → type =
  | s_bfco: fstep_op X T2 X2 → bstep_cl X2 T1 Y → square_bfco (B1:bstep_cl X T1 X1) (F2:fstep_op X1 T2 Y)
;

% Third auxiliary lemma for SP, closed-open case:
% Given two composable transitions, where the former is backward closed and the latter is
% forward open, and with independent proof labels, there exist a forward
% and a backward transition closing the square diagram.
rec sp_bfco: (g:ctx) {B1:[g ⊢ bstep_cl X T1 X1]} {F2:[g ⊢ fstep_op X1 T2 Y]}
  [g ⊢ indep (p_cl T1) (p_op T2)] → [g ⊢ square_bfco B1 F2] =
/ total f2 (sp_bfco _ _ _ _ _ _ _ f2 _) /
?
;

% Existence of transitions closing a square diagram for the 
% backward-forward, open-closed case
LF square_bfoc: bstep_op X T1 X1 → fstep_cl X1 T2 Y → type =
  | s_bfoc: fstep_cl X T2 X2 → bstep_op X2 T1 Y → square_bfoc (B1:bstep_op X T1 X1) (F2:fstep_cl X1 T2 Y)
;

% Third auxiliary lemma for SP, open-closed case:
% Given two composable transitions, where the former is backward open and the latter is
% forward closed, and with independent proof labels, there exist a forward
% and a backward transition closing the square diagram.
rec sp_bfoc: (g:ctx) {B1:[g ⊢ bstep_op X T1 X1]} {F2:[g ⊢ fstep_cl X1 T2 Y]}
  [g ⊢ indep (p_op T1) (p_cl T2)] → [g ⊢ square_bfoc B1 F2] =
/ total b1 (sp_bfoc _ _ _ _ _ _ b1 _ _) /
?
;

% Existence of transitions closing a square diagram for the 
% backward-forward, open-open case
LF square_bfoo: bstep_op X T1 X1 → fstep_op X1 T2 Y → type =
  | s_bfoo: fstep_op X T2 X2 → bstep_op X2 T1 Y → square_bfoo (B1:bstep_op X T1 X1) (F2:fstep_op X1 T2 Y)
;


% Third auxiliary lemma for SP, open-open case:
% Given two composable transitions, where the former is backward open and the latter is
% forward open, and with independent proof labels, there exist a forward
% and a backward transition closing the square diagram.
rec sp_bfoo: (g:ctx) {B1:[g ⊢ bstep_op X T1 X1]} {F2:[g ⊢ fstep_op X1 T2 Y]}
  [g ⊢ indep (p_op T1) (p_op T2)] → [g ⊢ square_bfoo B1 F2] =
/ total b1 (sp_bfoo _ _ _ _ _ _ b1 _ _) /
?
;



% Existence of combined transitions closing a square diagram
LF square: step X T1 X1 → step X T2 X2 → type =
  | sq: step X1 T2 Y → step X2 T1 Y → square (S1:step X T1 X1) (S2:step X T2 X2)
;


% Square Property:
% Given two coinitial combined transitions with independent proof labels,
% there exist two cofinal combined transition closing the square diagram.
rec sp: (g:ctx) {S1:[g ⊢ step X T1 X1]} {S2:[g ⊢ step X T2 X2]}
  [g ⊢ indep T1 T2] → [g ⊢ square S1 S2] =
/ total s1 (sp _ _ _ _ _ _ s1 _ _) /
mlam S1,S2 ⇒ fn i ⇒ case [_ ⊢ S1] of
  | [g ⊢ sc (fwc F1)] ⇒ (case [g ⊢ S2] of
       | [g ⊢ sc (fwc F2)] ⇒ let [g ⊢ B1] = loop_lemma_one_cl [g ⊢ F1] in
         let [g ⊢ s_bfcc F2' B1'] = sp_bfcc [g ⊢ B1] [g ⊢ F2] i in
         let [g ⊢ F1'] = loop_lemma_two_cl [g ⊢ B1'] in [g ⊢ sq (sc (fwc F2')) (sc (fwc F1'))]
       | [g ⊢ so (fwo F2)] ⇒ let [g ⊢ B1] = loop_lemma_one_cl [g ⊢ F1] in
         let [g ⊢ s_bfco F2' B1'] = sp_bfco [g ⊢ B1] [g ⊢ F2] i in
         let [g ⊢ F1'] = loop_lemma_two_cl [g ⊢ B1'] in [g ⊢ sq (so (fwo F2')) (sc (fwc F1'))]
       | [g ⊢ sc (bwc B2)] ⇒ let [g ⊢ F2] = loop_lemma_two_cl [g ⊢ B2] in
         let [g ⊢ i_cc I] = i in
         let [g ⊢ I'] = symmetric_indep [g ⊢ I] in
         let [g ⊢ s_ffcc F1' F2'] = sp_ffcc [g ⊢ F2] [g ⊢ F1] [g ⊢ i_cc I'] in
         let [g ⊢ B2'] = loop_lemma_one_cl [g ⊢ F2'] in [g ⊢ sq (sc (bwc B2')) (sc (fwc F1'))]
       | [g ⊢ so (bwo B2)] ⇒ let [g ⊢ F2] = loop_lemma_two_op [g ⊢ B2] in
         let [g ⊢ i_co \a.I] = i in
         let [g,a:names ⊢ I'] = symmetric_indep [_ ⊢ I] in
         let [g ⊢ s_ffoc F1' F2'] = sp_ffoc [g ⊢ F2] [g ⊢ F1] [g ⊢ i_oc \a.I'] in
         let [g ⊢ B2'] = loop_lemma_one_op [g ⊢ F2'] in [g ⊢ sq (so (bwo B2')) (sc (fwc F1'))])
  | [g ⊢ so (fwo F1)] ⇒ (case [g ⊢ S2] of
       | [g ⊢ sc (fwc F2)] ⇒ let [g ⊢ B1] = loop_lemma_one_op [g ⊢ F1] in
         let [g ⊢ s_bfoc F2' B1'] = sp_bfoc [g ⊢ B1] [g ⊢ F2] i in
         let [g ⊢ F1'] = loop_lemma_two_op [g ⊢ B1'] in [g ⊢ sq (sc (fwc F2')) (so (fwo F1'))]
       | [g ⊢ so (fwo F2)] ⇒ let [g ⊢ B1] = loop_lemma_one_op [g ⊢ F1] in
         let [g ⊢ s_bfoo F2' B1'] = sp_bfoo [g ⊢ B1] [g ⊢ F2] i in
         let [g ⊢ F1'] = loop_lemma_two_op [g ⊢ B1'] in [g ⊢ sq (so (fwo F2')) (so (fwo F1'))]
       | [g ⊢ sc (bwc B2)] ⇒ let [g ⊢ F2] = loop_lemma_two_cl [g ⊢ B2] in
         let [g ⊢ i_oc \a.I] = i in
         let [g,a:names ⊢ I'] = symmetric_indep [_ ⊢ I] in
         let [g ⊢ s_ffco F1' F2'] = sp_ffco [g ⊢ F2] [g ⊢ F1] [g ⊢ i_co \a.I'] in
         let [g ⊢ B2'] = loop_lemma_one_cl [g ⊢ F2'] in [g ⊢ sq (sc (bwc B2')) (so (fwo F1'))]
       | [g ⊢ so (bwo B2)] ⇒ let [g ⊢ F2] = loop_lemma_two_op [g ⊢ B2] in
         let [g ⊢ i_oo \a.I] = i in
         let [g,a:names ⊢ I'] = symmetric_indep [_ ⊢ I] in
         let [g ⊢ s_ffoo F1' F2'] = sp_ffoo [g ⊢ F2] [g ⊢ F1] [g ⊢ i_oo \a.I'] in
         let [g ⊢ B2'] = loop_lemma_one_op [g ⊢ F2'] in [g ⊢ sq (so (bwo B2')) (so (fwo F1'))])
  | [g ⊢ sc (bwc B1)] ⇒ let [g ⊢ F1] = loop_lemma_two_cl [g ⊢ B1] in
    (case [g ⊢ S2] of
       | [g ⊢ sc (fwc F2)] ⇒ let [g ⊢ s_ffcc F2' F1'] = sp_ffcc [g ⊢ F1] [g ⊢ F2] i in
         let [g ⊢ B1'] = loop_lemma_one_cl [g ⊢ F1'] in [g ⊢ sq (sc (fwc F2')) (sc (bwc B1'))]
       | [g ⊢ so (fwo F2)] ⇒ let [g ⊢ s_ffco F2' F1'] = sp_ffco [g ⊢ F1] [g ⊢ F2] i in
         let [g ⊢ B1'] = loop_lemma_one_cl [g ⊢ F1'] in [g ⊢ sq (so (fwo F2')) (sc (bwc B1'))]
       | [g ⊢ sc (bwc B2)] ⇒ let [g ⊢ s_fbcc B2' F1'] = sp_fbcc [g ⊢ F1] [g ⊢ B2] i in
         let [g ⊢ B1'] = loop_lemma_one_cl [g ⊢ F1'] in [g ⊢ sq (sc (bwc B2')) (sc (bwc B1'))]
       | [g ⊢ so (bwo B2)] ⇒ let [g ⊢ s_fbco B2' F1'] = sp_fbco [g ⊢ F1] [g ⊢ B2] i in
         let [g ⊢ B1'] = loop_lemma_one_cl [g ⊢ F1'] in [g ⊢ sq (so (bwo B2')) (sc (bwc B1'))])
  | [g ⊢ so (bwo B1)] ⇒ let [g ⊢ F1] = loop_lemma_two_op [g ⊢ B1] in
    (case [g ⊢ S2] of
       | [g ⊢ sc (fwc F2)] ⇒ let [g ⊢ s_ffoc F2' F1'] = sp_ffoc [g ⊢ F1] [g ⊢ F2] i in
         let [g ⊢ B1'] = loop_lemma_one_op [g ⊢ F1'] in [g ⊢ sq (sc (fwc F2')) (so (bwo B1'))]
       | [g ⊢ so (fwo F2)] ⇒ let [g ⊢ s_ffoo F2' F1'] = sp_ffoo [g ⊢ F1] [g ⊢ F2] i in
         let [g ⊢ B1'] = loop_lemma_one_op [g ⊢ F1'] in [g ⊢ sq (so (fwo F2')) (so (bwo B1'))]
       | [g ⊢ sc (bwc B2)] ⇒ let [g ⊢ s_fboc B2' F1'] = sp_fboc [g ⊢ F1] [g ⊢ B2] i in
         let [g ⊢ B1'] = loop_lemma_one_op [g ⊢ F1'] in [g ⊢ sq (sc (bwc B2')) (so (bwo B1'))]
       | [g ⊢ so (bwo B2)] ⇒ let [g ⊢ s_fboo B2' F1'] = sp_fboo [g ⊢ F1] [g ⊢ B2] i in
         let [g ⊢ B1'] = loop_lemma_one_op [g ⊢ F1'] in [g ⊢ sq (so (bwo B2')) (so (bwo B1'))])
;