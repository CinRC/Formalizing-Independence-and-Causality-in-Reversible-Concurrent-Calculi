%%% IRE: independence respects events

% The statement of IRE requires the definition of the relation ~ of equivalence of transitions,
% that relates two transitions if they correspond to the same event.
% We define it here and show that the definition is well-posed.

% Equality of names
LF eqn: names → names → type =
  | refn: eqn A A
;

% Predicate expressing equality or inequality of names:
% eq_or_neq_nam A B holds iff A = B or A != B
inductive eq_or_neq_nam: (g:ctx) [g ⊢ names] → [g ⊢ names] → ctype =
  | dn_eq: [g ⊢ eqn A B] → eq_or_neq_nam [g ⊢ A] [g ⊢ B]
  | dn_neq: ([g ⊢ eqn A B] → [g ⊢ false]) → eq_or_neq_nam [g ⊢ A] [g ⊢ B]
;

% If A = B in a context g,a:names, with both A != a and B != a, then A = B in the context g
rec str_names: (g:ctx) [g,a:names ⊢ eqn A[..] B[..]] → [g ⊢ eqn A B] =
/ total e (str_names _ _ _ e) /
fn E ⇒ let [g,a:names ⊢ refn] = E in [g ⊢ refn]
;

% Decidable equality for names:
% Given two names in a context g, they are either equal or not equal
rec dec_eq_names: {g:ctx} {A:[g ⊢ names]} {B:[g ⊢ names]} eq_or_neq_nam [g ⊢ A] [g ⊢ B] =
/ total g (dec_eq_names g _ _) /
mlam g,A,B ⇒ case [g] of
  | [] ⇒ impossible [⊢ A]
  | [g',a:names] ⇒ (case [_ ⊢ A] of
       | [g',a:names ⊢ a] ⇒ (case [_ ⊢ B] of
            | [g',a:names ⊢ a] ⇒ dn_eq [_ ⊢ refn]
            | [g',a:names ⊢ #q[..]] ⇒ dn_neq (fn e ⇒ impossible e))
       | [g',a:names ⊢ #p[..]] ⇒ (case [_ ⊢ B] of
            | [g',a:names ⊢ a] ⇒ dn_neq (fn e ⇒ impossible e)
            | [g',a:names ⊢ #q[..]] ⇒ (case dec_eq_names [g'] [g' ⊢ #p[..]] [g' ⊢ #q[..]] of
                 | dn_eq [g' ⊢ refn] ⇒ dn_eq [_ ⊢ refn]
                 | dn_neq f ⇒ dn_neq (fn e ⇒ impossible f (str_names e)))))
;


inductive neql: (g:ctx) [g ⊢ labels] → [g ⊢ labels] → ctype =
  | nrefn: {g:ctx} {L:[g ⊢ labels]} {L':[g ⊢ labels]} ([g ⊢ eql L L'] → [g ⊢ false]) → neql [g ⊢ L] [g ⊢ L']
;

% Predicate expressing equality or inequality of labels:
% eq_or_neq_lab L L' holds iff L = L' or L != L'
inductive eq_or_neq_lab: (g:ctx) [g ⊢ labels] → [g ⊢ labels] → ctype =
  | dl_eq: [g ⊢ eql L L'] → eq_or_neq_lab [g ⊢ L] [g ⊢ L']
  | dl_neq: neql [g ⊢ L] [g ⊢ L'] → eq_or_neq_lab [g ⊢ L] [g ⊢ L']
;

% If inp A = inp B, then A = B
rec eq_inp_impl_names: (g:ctx) [g ⊢ eql (inp A) (inp B)] → [g ⊢ eqn A B] =
/ total (eq_inp_impl_names) /
fn e ⇒ let [g ⊢ refl] = e in [g ⊢ refn]
;

% If out A = out B, then A = B
rec eq_out_impl_names: (g:ctx) [g ⊢ eql (out A) (out B)] → [g ⊢ eqn A B] =
/ total (eq_out_impl_names) /
fn e ⇒ let [g ⊢ refl] = e in [g ⊢ refn]
;

% Decidable equality for labels:
% Given two labels in a context g, they are either equal or not equal
rec dec_eq_labels: (g:ctx) {L:[g ⊢ labels]} {L':[g ⊢ labels]} eq_or_neq_lab [g ⊢ L] [g ⊢ L'] =
%/ total l (dec_eq_labels _ l _) /
mlam L,L' ⇒ case [_ ⊢ L] of
  | [g ⊢ inp A] ⇒ (case [g ⊢ L'] of
       | [g ⊢ inp B] ⇒ (case dec_eq_names [g] [g ⊢ A] [g ⊢ B] of
                           | dn_eq [g ⊢ refn] ⇒ dl_eq [g ⊢ refl]
                           | dn_neq f ⇒ dl_neq (nrefn [g] [g ⊢ L] [g ⊢ L'] (fn e ⇒ let [g ⊢ refl] = e in impossible f [_ ⊢ refn])))%impossible f (eq_inp_impl_names e)
)%{       | [g ⊢ out B] ⇒ dl_neq (nrefn (fn e ⇒ impossible e))
       | [g ⊢ tau] ⇒ dl_neq (nrefn (fn e ⇒ impossible e)))
  | [g ⊢ out A] ⇒ (case [g ⊢ L'] of
       | [g ⊢ inp B] ⇒ dl_neq (nrefn (fn e ⇒ impossible e))
       | [g ⊢ out B] ⇒ (case dec_eq_names [g] [g ⊢ A] [g ⊢ B] of
                           | dn_eq [g ⊢ refn] ⇒ dl_eq [g ⊢ refl]
                           | dn_neq f ⇒ dl_neq (nrefn (fn e ⇒ impossible f (eq_out_impl_names e))))
       | [g ⊢ tau] ⇒ dl_neq (nrefn (fn e ⇒ impossible e)))
  | [g ⊢ tau] ⇒ (case [g ⊢ L'] of
       | [g ⊢ inp B] ⇒ dl_neq (nrefn (fn e ⇒ impossible e))
       | [g ⊢ out B] ⇒ dl_neq (nrefn (fn e ⇒ impossible e))
       | [g ⊢ tau] ⇒ dl_eq [g ⊢ refl])}%
;

%let D: eq_or_neq_lab [a:names,b:names ⊢ inp a] [a:names,b:names ⊢ inp b] = dl_neq (nrefn (fn e ⇒ impossible e));

%{
% Independence respects events (IRE):
% Given three transitions t,t' and u, if t~t' (t and t' are equivalent) and t' and u are independent,
% then also t and u are independent.
rec pci: (g:ctx) (T:[g ⊢ step X1 T1 Y1]) (T':[g ⊢ step X2 T2 Y2]) (U:[g ⊢ step X3 T3 Y3])
  [g ⊢ equiv_tr T T'] → [g ⊢ indep_tr T' U] → [g ⊢ indep_tr T U] =
/ total (ire _ _ _ _ _ _ _ _ _ _ t _ _ _ _) /
?
%fn i,d ⇒ let [g ⊢ ind_tr I] = i in
%let [g ⊢ it T S] = d in 
%let [g ⊢ I'] = symmetric_indep_pl [g ⊢ I] in [g ⊢ ind_tr I']
;
}%